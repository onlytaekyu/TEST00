<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>DB 접근제어 콘솔</title>
  <!-- CodeMirror (CDN). 운영에선 내부 호스팅 권장 -->
  <script type="text/javascript" nonce="8810704988604c3989e9bc73530" src="//local.adguard.org?ts=1765434149898&amp;type=content-script&amp;dmn=download.mail.naver.com&amp;url=https%3A%2F%2Fdownload.mail.naver.com%2Ffile%2Fdownload%2Feach%2F%3FattachType%3Dnormal%26mailSN%3D55689%26attachIndex%3D2%26virus%3D1%26domain%3Dmail.naver.com&amp;app=chrome.exe&amp;css=3&amp;js=1&amp;rel=1&amp;rji=1&amp;sbe=1"></script><script type="text/javascript" nonce="8810704988604c3989e9bc73530" src="//local.adguard.org?ts=1765434149898&amp;name=AdGuard%20Extra&amp;type=user-script"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/codemirror.min.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/theme/material-darker.min.css" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/codemirror.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/sql/sql.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/keymap/vim.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/keymap/emacs.min.js"></script>
  <!-- CodeMirror autocomplete addon -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/addon/hint/show-hint.min.css" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/addon/hint/show-hint.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/addon/hint/sql-hint.min.js"></script>
  <!-- Font Awesome -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" />
  <style>
    :root{
      /* 하나금융 시그니처 그린 계열 (조정 가능) */
      --hana-primary: #00857C; /* main */
      --hana-primary-600:#00786F; /* hover */
      --hana-accent:#00B4A2;

      --header-h: 48px; --sidebar-w: 280px; --min-sidebar-w: 200px; --max-sidebar-w: 420px;
      --resizer-w: 6px; --resizer-h: 6px; --editor-min-h: 180px; --result-min-h: 120px;
      --border: 1px solid #e5e7eb; --bg: #f8fafc; --panel: #ffffff; --ink: #0f172a; --muted: #64748b;
      --brand: var(--hana-accent); --menu-bg: var(--hana-primary); --menu-ink: #e8fbf8; --menu-hover: var(--hana-primary-600);
      --tab-bg: #f1f5f9; --tab-active: #ffffff; --chip-bg: #e2e8f0; --chip-ink: #334155;
      --danger: #ef4444; --ok: #16a34a; --warn-ink:#b45309;
      /* 프로필 색상 정책 */
  .profile-avatar{
    width:20px;
    height:20px;
    border-radius:50%;
    background:#00b894;
    color:#ffffff;
    display:flex;
    align-items:center;
    justify-content:center;
    font-size:11px;
  }

      --prof-ro: #2563eb;        /* 파랑 */
      --prof-limited: #f59e0b;   /* 호박 */
      --prof-ops: #db2777;       /* 로즈 */
    }
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;background:var(--bg);color:var(--ink);font:14px/1.4 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;}
    a{color:inherit;text-decoration:none}
    button{cursor:pointer;border:1px solid #cbd5e1;background:#fff;border-radius:8px;padding:6px 10px}
    button:hover{background:#f8fafc}
    .app{display:flex;flex-direction:column;height:100vh;overflow:hidden}

    /* Header */
    .header{display:flex;align-items:center;justify-content:space-between;height:var(--header-h);flex:0 0 var(--header-h);padding:0 12px;background:var(--menu-bg);color:var(--menu-ink);border-bottom:var(--border)}
    .brand{display:flex;align-items:center;gap:10px;font-weight:700}
    .brand .dot{width:10px;height:10px;border-radius:50%;background:var(--brand)}
    .menubar{display:flex;gap:8px}
    .menu{position:relative}
    .menu>.title{padding:8px 10px;border-radius:6px}
    .menu:hover>.title{background:var(--menu-hover)}
    .dropdown{position:absolute;top:100%;left:0;min-width:220px;background:#0f172a;color:#e2e8f0;border-radius:8px;box-shadow:0 8px 24px rgba(0,0,0,.25);display:none;z-index:10}
    .menu:hover .dropdown{display:block}
    .dropdown a{display:block;padding:8px 12px}
    .dropdown a:hover{background:#1e293b}
    .status{display:flex;align-items:center;gap:8px}
    .chip{background:var(--chip-bg);color:var(--chip-ink);padding:4px 8px;border-radius:999px;font-size:12px}
    .header-actions{display:flex;align-items:center;gap:12px;margin-left:auto;}
    .header-icon-btn{position:relative;display:flex;align-items:center;justify-content:center;width:32px;height:32px;border-radius:999px;border:1px solid rgba(148,163,184,.6);background:transparent;color:inherit;cursor:pointer;font-size:14px;}
    .header-icon-btn .badge{position:absolute;top:-4px;right:-4px;min-width:16px;height:16px;border-radius:999px;background:#ef4444;color:#fff;font-size:10px;display:flex;align-items:center;justify-content:center;padding:0 4px;}
    .header-user{position:relative;display:flex;align-items:center;}
    .header-user-toggle{display:flex;align-items:center;gap:8px;padding:4px 10px;border-radius:999px;border:1px solid rgba(148,163,184,.6);background:rgba(15,23,42,.15);color:inherit;cursor:pointer;font-size:13px;}
    .header-user-toggle .avatar-circle{width:24px;height:24px;border-radius:999px;background:#00b894;color:#ffffff;display:flex;align-items:center;justify-content:center;font-weight:700;font-size:13px;}
    .header-user-name{max-width:140px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;}
    .header-user-dropdown{position:absolute;top:calc(100% + 6px);right:0;min-width:170px;background:#0f172a;border-radius:8px;border:1px solid rgba(148,163,184,.7);box-shadow:0 12px 30px rgba(15,23,42,.45);padding:6px 0;z-index:40;display:none;}
    .header-user-dropdown.open{display:block;}
    .header-user-dropdown button{width:100%;padding:6px 12px;font-size:13px;text-align:left;background:transparent;border:none;color:#e2e8f0;display:flex;align-items:center;gap:8px;cursor:pointer;}
    .header-user-dropdown button:hover{background:rgba(148,163,184,.25);}
    .header-user-dropdown .logout{color:#fecaca;}
    .header-user-dropdown .logout:hover{background:rgba(248,113,113,.35);}
    .header-user-divider{border:none;border-top:1px solid rgba(148,163,184,.6);margin:4px 0;}
    .header-icon-btn:hover{
      background:rgba(148,163,184,.18);
      border-color:rgba(148,163,184,.9);
      color:#e5e7eb;
    }
    .header-user-toggle:hover{
      background:rgba(148,163,184,.24);
      border-color:rgba(148,163,184,.9);
      color:#e5e7eb;
    }


    /* Main */
    .main{display:grid;grid-template-columns:auto var(--resizer-w) 1fr;flex:1 1 auto;min-height:0}

    /* Sidebar */
    .sidebar{width:var(--sidebar-w);min-width:var(--min-sidebar-w);max-width:var(--max-sidebar-w);background:var(--panel);border-right:var(--border);display:flex;flex-direction:column}
    .sidebar .title{padding:10px 12px;border-bottom:var(--border);display:flex;align-items:center;justify-content:space-between}
    .tree{flex:1;overflow:auto;padding:8px 6px 12px}
    .tree ul{list-style:none;margin:0;padding-left:16px}
    .tree li{margin:2px 0}
    .node{display:flex;align-items:center;gap:6px;padding:4px 6px;border-radius:6px;cursor:default;position:relative}
    .node:hover{background:#f1f5f9}
    .node:focus{outline:2px solid #c7f2ed; background:#ecfeff}
    .node .tw{display:inline-block;width:12px;text-align:center;cursor:pointer}
    .node .tag{font-size:11px;color:#64748b;margin-left:auto}
    .col-icon{
      display:inline-flex;
      align-items:center;
      justify-content:center;
      width:18px;
      height:16px;
      font-size:10px;
      border-radius:3px;
      padding:0 2px;
      font-weight:600;
    }
    .col-text{background:#e0f2fe;color:#0369a1;}
    .col-number{background:#fee2e2;color:#b91c1c;}
    .col-date{background:#ede9fe;color:#5b21b6;}
    .conn-dot{font-size:8px;margin-right:6px}
    .conn-on{color:var(--ok)}
    .conn-off{color:#f87171}

    .db-pin-btn{
      border:none;
      background:transparent;
      cursor:pointer;
      padding:0 2px;
      margin-left:4px;
      font-size:11px;
      color:#6b7280;
    }
    .db-pin-btn.pinned{
      color:#facc15;
    }
    #dbTree li[data-conn-id].db-pinned > .node{
      font-weight:600;
    }

    .badge-prof{border-radius:8px;padding:2px 6px;font-size:11px;margin-left:6px;color:#fff}
    .prof-ro{background:var(--prof-ro)}
    .prof-limited{background:var(--prof-limited)}
    .prof-ops{background:var(--prof-ops)}

    .v-resizer{width:var(--resizer-w);cursor:col-resize;background:linear-gradient(90deg,#e5e7eb,#cbd5e1)}

    /* Content (Tabs + Editor + Bottom 탭 영역) */
    .content{display:grid;grid-template-rows:auto auto auto auto var(--resizer-h) 1fr;height:100%}
    .tabs-wrapper{display:flex;align-items:center;background:var(--tab-bg);border-bottom:var(--border);position:relative;width:100%;max-width:100%;overflow:hidden;}
    .tab-scroll{display:none;border:none;background:transparent;padding:0 4px;cursor:pointer;min-width:24px;height:100%;}
    .tab-scroll[disabled]{opacity:.3;cursor:default;}
    .tab-overflow-btn{border:none;background:transparent;padding:0 4px;cursor:pointer;min-width:24px;height:100%;font-size:14px;}
    .tabs{display:flex;align-items:center;gap:6px;flex:1 1 auto;min-width:0;overflow:hidden;padding:6px;flex-wrap:nowrap;}
    .tab-overflow-menu{position:fixed;top:100%;margin-top:2px;background:#ffffff;border:var(--border);box-shadow:0 2px 6px rgba(0,0,0,.15);border-radius:4px;min-width:260px;width:auto;max-height:260px;overflow-y:auto;overflow-x:hidden;z-index:20;font-size:12px;padding:2px 0;box-sizing:border-box;}
    .tab-overflow-item{display:block;padding:4px 10px;cursor:pointer;white-space:nowrap;text-align:left;box-sizing:border-box;}
    .tab-overflow-item:hover{background:#e5e7eb;}
.tab{flex:0 0 auto;display:flex;align-items:center;gap:8px;background:var(--tab-bg);border:1px solid #e2e8f0;border-bottom:none;border-radius:10px 10px 0 0;padding:6px 10px;cursor:pointer;position:relative}
    .tab.dragging{opacity:.2;cursor:grabbing;}
    
    .tab.drop-before::before,
    .tab.drop-after::after{
      content:'';
      position:absolute;
      top:2px;
      bottom:2px;
      width:3px;
      background:var(--hana-accent);
    }
    .tab.drop-before::before{ left:0; }
    .tab.drop-after::after{ right:0; }

    .tab.active{background:#A7D8B7;opacity:1;font-weight:bold}
    .tab .close{opacity:.6}
    .tab .close:hover{opacity:1}
    
    .tab-title{
      display:inline-block;
      white-space:nowrap;
    }
    .tab-title-edit{
      font-size:12px;
      padding:2px 6px;
      border:1px solid #9cc7ff;
      border-radius:3px;
      box-sizing:border-box;
      max-width:140px;
      min-width:40px;
      display:inline-block;
      background:#fff;
      color:#000;
    }
    .tab-title-edit-error{
      position:absolute;
      left:4px;
      bottom:100%;
      margin-bottom:2px;
      background:#fffbe6;
      border:1px solid #ffb84d;
      color:#c45a00;
      font-size:10px;
      padding:1px 4px;
      border-radius:3px;
      white-space:nowrap;
      z-index:9999;
    }
    .tab-rename-toast{
      position:fixed;
      left:50%;
      top:64px;
      transform:translateX(-50%);
      background:#fffbe6;
      border:1px solid #ffb84d;
      color:#c45a00;
      font-size:12px;
      padding:4px 10px;
      border-radius:4px;
      white-space:nowrap;
      box-shadow:0 2px 4px rgba(0,0,0,0.15);
      z-index:10000;
      opacity:0;
      pointer-events:none;
      transition:opacity .15s ease-out, transform .15s ease-out;
    }
    .tab-rename-toast.show{
      opacity:1;
      transform:translateX(-50%) translateY(4px);
    }


/* 핀 고정 탭 표시 */
    .tab.pinned::before{
      content:'\1F4CC';
      font-size:11px;
      margin-right:4px;
    }
    /* 탭 색상 밑줄 */
    .tab.color-blue{border-bottom:3px solid #3b82f6;}
    .tab.color-green{border-bottom:3px solid #22c55e;}
    .tab.color-yellow{border-bottom:3px solid #eab308;}
    .tab.color-red{border-bottom:3px solid #ef4444;}

    .tab .conn-badge{display:inline-flex;align-items:center;gap:6px}
    .tab .tab-prof{margin-left:2px}
    .tab-add{margin-left:auto}

    
    /* 환경 배너 (에디터 상단, 탭 아래 / 툴바 위) */
    .env-banner{
      display:flex;
      align-items:flex-start;
      gap:10px;
      padding:8px 12px;
      border-bottom:var(--border);
      font-size:12px;
      background:#f9fafb;
      color:#111827;
    }
    .env-banner-icon{
      margin-top:2px;
      flex:0 0 auto;
      width:20px;
      height:20px;
      border-radius:999px;
      display:flex;
      align-items:center;
      justify-content:center;
      font-size:12px;
    }
    .env-banner-title{
      font-weight:600;
      margin-bottom:2px;
    }
    .env-banner-meta{
      font-size:11px;
      font-weight:500;
      margin-bottom:2px;
    }
    .env-banner-head{
      display:flex;
      flex-wrap:wrap;
      align-items:baseline;
      gap:8px;
      margin-bottom:2px;
    }
    .env-banner-title{
      font-weight:600;
      margin-bottom:0;
    }
    .env-banner-meta{
      display:inline-flex;
      align-items:center;
      font-size:11px;
      font-weight:500;
      margin-bottom:0;
      padding:1px 8px;
      border-radius:999px;
      border:1px solid currentColor;
      background-color:rgba(255,255,255,0.4);
    }
    .env-banner-desc{
      font-size:11px;
      color:var(--muted);
    }
    /* 환경별 색상 (DEV/QA/PROD) */
    .env-banner--dev{
      background:#ecfdf5;
      border-bottom:1px solid #bbf7d0;
      color:#166534;
    }
    .env-banner--dev .env-banner-icon{
      background:#bbf7d0;
      color:#14532d;
    }
    .env-banner--qa{
      background:#eff6ff;
      border-bottom:1px solid #bfdbfe;
      color:#1d4ed8;
    }
    .env-banner--qa .env-banner-icon{
      background:#bfdbfe;
      color:#1e3a8a;
    }
    .env-banner--prod{
      background:#fef2f2;
      border-bottom:1px solid #fecaca;
      color:#991b1b;
    }
    .env-banner--prod .env-banner-icon{
      background:#fee2e2;
      color:#b91c1c;
    }
    .env-banner--hidden{
      display:none;
    }

    .toolbar{display:flex;align-items:center;gap:8px;padding:8px;border-bottom:var(--border);background:var(--panel)}
    .toolbar .sp{flex:1}
    .toolbar button{font-size:12px;padding:4px 8px}
    .toolbar button i{margin-right:2px}

    .editor{background:var(--panel);padding:0 0 8px 0}
    /* 환경별 에디터 영역 색상 (DEV/QA/PROD) */
    body.env-dev .editor{background:#f0fdf4}
    body.env-qa .editor{background:#eff6ff}
    body.env-prod .editor{background:#fef2f2}

    .codewrap{position:relative;border-top:var(--border)}
    /* CodeMirror takes over */
    .CodeMirror{height:320px;min-height:var(--editor-min-h);font-size:13px;border-bottom:var(--border)}
    body.env-dev .CodeMirror{background:#f9fefb}
    body.env-qa .CodeMirror{background:#f8fbff}
    body.env-prod .CodeMirror{background:#fff7f7}

    .h-resizer{height:var(--resizer-h);cursor:row-resize;background:linear-gradient(180deg,#e5e7eb,#cbd5e1)}

    /* Bottom tab area (결과 / DDL / 히스토리 / 즐겨찾기 / 서버 API) */
    .bottom-area{
      display:flex;
      flex-direction:column;
      min-height:0;
      background:var(--panel);
      border-top:var(--border);
    }
    .bottom-tabs{
      display:flex;
      align-items:center;
      gap:4px;
      padding:4px 8px;
      background:var(--tab-bg);
      border-bottom:var(--border);
      flex-shrink:0;
    }
    .bottom-tabs .bottom-tab{
      border-radius:999px;
      border:1px solid #cbd5e1;
      background:#e5e7eb;
      padding:4px 10px;
      font-size:12px;
      display:inline-flex;
      align-items:center;
      gap:4px;
      cursor:pointer;
    }
    .bottom-tabs .bottom-tab.bottom-tab--with-badge{
      position:relative;
    }
    .bottom-tab-badge{
      position:absolute;
      top:-6px;
      right:-6px;
      min-width:16px;
      height:16px;
      border-radius:999px;
      background:#ef4444;
      color:#fff;
      font-size:10px;
      display:flex;
      align-items:center;
      justify-content:center;
      padding:0 4px;
    }

    .bottom-tabs .bottom-tab.active{
      background:#A7D8B7;
      font-weight:600;
    }
    .bottom-content{
      position:relative;
      flex:1;
      min-height:0;
    }

    .result{
      position:absolute;
      inset:0;
      background:var(--panel);
      border-top:none;
      display:none;
      flex-direction:column;
    }
    .result-header{display:flex;align-items:center;gap:8px;padding:8px;border-bottom:var(--border);flex-shrink:0}
    .result-body{flex:1;min-height:var(--result-min-h);overflow:auto}

    /* Favorites / Template panel (bottom) */
    .favtpl-body{
      /* reuse result-body base styles */
      display:flex;
      flex-direction:column;
      overflow:hidden;
    }
    .favtpl-inner{
      display:flex;
      flex-direction:column;
      gap:4px;
      padding:4px 6px 6px 6px;
      min-height:0;
    }
    .favtpl-tabs{
      display:inline-flex;
      gap:4px;
      align-items:center;
      flex-wrap:wrap;
    }
    .favtpl-tab-btn{
      border-radius:999px;
      border:1px solid #cbd5e1;
      background:#f9fafb;
      padding:2px 8px;
      font-size:11px;
      cursor:pointer;
      display:inline-flex;
      align-items:center;
      gap:4px;
    }
    .favtpl-tab-btn.active{
      background:#047857;
      color:#ecfdf5;
      border-color:#047857;
      font-weight:600;
    }
    .favtpl-tab-btn .badge-chip{
      font-size:10px;
      background:rgba(255,255,255,.2);
      padding:0 4px;
      border-radius:999px;
    }
    .favtpl-panel{
      min-height:60px;
      display:flex;
      flex-direction:column;
      flex:1 1 auto;
      min-height:0;
    }
    .favtpl-panel.hidden{
      display:none;
    }
    .favtpl-filter-bar{
      display:flex;
      flex-wrap:wrap;
      gap:4px;
      margin:4px 0;
      font-size:11px;
      color:#4b5563;
    }
    .favtpl-filter-bar label{
      display:flex;
      align-items:center;
      gap:4px;
    }
    .favtpl-filter-bar select,
    .favtpl-filter-bar input{
      font-size:11px;
      padding:2px 4px;
    }
    .favtpl-main{
      display:flex;
      gap:6px;
      min-height:0;
      flex:1 1 auto;
      overflow:hidden;
    }
    .favtpl-list{
      flex:1;
      min-width:0;
      overflow-y:auto;
    }
    .favtpl-list table{
      width:100%;
      border-collapse:collapse;
      font-size:11px;
    }
    .favtpl-list tbody tr{
      cursor:pointer;
    }
    .favtpl-list tbody tr:nth-child(odd){
      background:#f9fafb;
    }
    .favtpl-list tbody tr:hover{
      background:#e0f2fe;
    }
    .favtpl-list td{
      padding:4px 6px;
      border-bottom:1px solid #e5e7eb;
      vertical-align:top;
    }
    .favtpl-name{
      font-weight:600;
    }
    .favtpl-desc{
      font-size:10px;
      color:#6b7280;
      margin-top:2px;
    }
    .favtpl-meta-row{
      margin-top:3px;
      display:flex;
      flex-wrap:wrap;
      gap:3px;
    }
    .favtpl-badge{
      display:inline-flex;
      align-items:center;
      padding:0 5px;
      border-radius:999px;
      font-size:10px;
      background:#e5e7eb;
      color:#374151;
    }
    .favtpl-badge.sys-PRD{background:#fee2e2;color:#b91c1c;}
    .favtpl-badge.sys-DEV{background:#dbeafe;color:#1d4ed8;}
    .favtpl-badge.sys-STG{background:#fef3c7;color:#b45309;}
    .favtpl-badge.cat-MONITOR{background:#dcfce7;color:#166534;}
    .favtpl-badge.cat-HISTORY{background:#e0f2fe;color:#075985;}
    .favtpl-badge.cat-BATCH{background:#fae8ff;color:#7e22ce;}
    .favtpl-badge.cat-ETC{background:#e5e7eb;color:#374151;}
    .favtpl-badge.biz-MSG{background:#fef9c3;color:#854d0e;}
    .favtpl-badge.biz-PORTAL{background:#e0f2fe;color:#1d4ed8;}
    .favtpl-badge.biz-COMMON{background:#ecfdf5;color:#166534;}
    .favtpl-badge.biz-ETC{background:#e5e7eb;color:#374151;}
    .favtpl-preview{
      width:40%;
      min-width:180px;
      display:flex;
      flex-direction:column;
      gap:4px;
    }
    .favtpl-preview textarea{
      width:100%;
      min-height:80px;
      font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size:11px;
      padding:4px;
      border:1px solid #d1d5db;
      border-radius:4px;
      resize:vertical;
      background:#f9fafb;
    }
    .favtpl-preview-info{
      font-size:10px;
      color:#6b7280;
      display:flex;
      justify-content:space-between;
      gap:4px;
      flex-wrap:wrap;
    }
    .favtpl-head{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:8px;
      margin:2px 0 4px 0;
      flex-wrap:wrap;
    }
    .favtpl-hint{
      font-size:10px;
      color:#6b7280;
      white-space:nowrap;
    }


    table.grid{width:100%;border-collapse:collapse}
    table.grid thead th{position:sticky;top:0;background:#f8fafc;border-bottom:var(--border);font-weight:600}
    table.grid th,table.grid td{border-bottom:1px solid #f1f5f9;padding:6px 8px;white-space:nowrap}
    .muted{color:var(--muted)}
    .right{margin-left:auto}
    .badge{display:inline-block;padding:2px 6px;border-radius:6px;background:#f1f5f9;color:#111827;font-size:12px}
    .spin{width:14px;height:14px;border-radius:50%;border:2px solid #94a3b8;border-top-color:transparent;display:inline-block;animation:spin 1s linear infinite}
    @keyframes spin{to{transform:rotate(360deg)}}
    .warn{color:var(--danger)}
    .ok{color:var(--ok)}
    .hidden{display:none!important}
    .test-pass{color:#16a34a}
    .test-fail{color:#ef4444}

    /* Context Menu */
    .ctx-menu{position:fixed;z-index:2100;background:#fff;border:1px solid #e5e7eb;border-radius:8px;box-shadow:0 8px 24px rgba(0,0,0,.12);min-width:180px;overflow:hidden}
    .ctx-menu ul{list-style:none;margin:0;padding:4px 0}
    .ctx-menu li{padding:8px 12px;cursor:pointer;display:flex;align-items:center;gap:8px}
    .ctx-menu li:hover{background:#f1f5f9}
    .ctx-menu li.disabled{
      color:#9ca3af;
      cursor:default;
      pointer-events:none;
    }
        /* Scroll fix: allow flex children to scroll independently */
    .sidebar,.right,.result-panel,.result-body{min-height:0;}

    /* SQL 키워드(붉게 표시되는 토큰) 굵게 표시 */
    .CodeMirror .cm-keyword{
      font-weight: bold;
      color: #a626a4;
    }

    /* SQL 기본 함수 토큰 (MAX, SUM 등) 강조 색상 */
    .CodeMirror .cm-sql-builtin-func{
      font-weight: bold;
      color: #c18401;
    }


    /* 문자열 리터럴 색상 (문자/문자열) */
    .CodeMirror .cm-string{
      color: #50a14f;
    }

  
  /* Export audit modal */
  .export-modal-backdrop{
    position:fixed;
    inset:0;
    background:rgba(0,0,0,0.4);
    display:none;
    align-items:center;
    justify-content:center;
    z-index:2000;
  }
  .export-modal-backdrop.show{
    display:flex;
  }
  .export-modal{
    background:#fff;
    border-radius:8px;
    min-width:420px;
    max-width:640px;
    box-shadow:0 4px 12px rgba(0,0,0,0.3);
    padding:16px 20px;
    font-size:13px;
  }
  .export-modal h3{
    margin:0 0 8px;
    font-size:15px;
  }
  .export-modal .meta{
    font-size:12px;
    color:#555;
    margin-bottom:8px;
    line-height:1.4;
  }
  .export-modal textarea{
    width:100%;
    min-height:80px;
    resize:vertical;
    font-size:12px;
    padding:6px;
  }
  .export-modal-header{
    position:relative;
    padding-right:32px;
  }

  .export-modal .field{
    margin-bottom:8px;
  }
  .export-modal .field label{
    display:block;
    font-weight:600;
    margin-bottom:4px;
  }
  .export-modal .danger{
    background:#fff3cd;
    border:1px solid #ffeeba;
    padding:6px 8px;
    border-radius:4px;
    font-size:12px;
    margin-bottom:8px;
    color:#856404;
  }
  .export-modal .btn-row{
    display:flex;
    justify-content:flex-end;
    gap:8px;
    margin-top:10px;
  }
  .export-modal .btn-row button{
    padding:4px 10px;
    font-size:12px;
  }

  /* 현재 탭 SQL 저장 모달 레이아웃 보정 */
  #personalSqlSaveBackdrop .export-modal-grid{
    display:flex;
    flex-direction:column;
    gap:12px;
  }

  /* Query History Sidebar (현재 DB 기준) */
  #queryHistorySidebar{
    position:fixed;
    top:80px;
    right:16px;
    width:360px;
    max-height:calc(100vh - 100px);
    background:#ffffff;
    border-radius:8px;
    box-shadow:0 10px 25px rgba(0,0,0,0.25);
    display:none;
    flex-direction:column;
    z-index:2050;
  }
  #queryHistorySidebar.show{
    display:flex;
  }
  #queryHistorySidebar header{
    display:flex;
    align-items:flex-start;
    justify-content:space-between;
    padding:8px 10px;
    border-bottom:1px solid #e5e7eb;
    background:#f9fafb;
    gap:8px;
  }
  #queryHistorySidebar header h3{
    margin:0;
    font-size:13px;
    font-weight:600;
    display:flex;
    align-items:center;
    gap:6px;
  }
  #queryHistorySidebar header .muted{
    font-size:11px;
    color:#6b7280;
    margin-top:2px;
  }
  #queryHistorySidebar header .title-wrap{
    display:flex;
    flex-direction:column;
    gap:0;
  }
  #queryHistorySidebar .body{
    padding:6px 8px 8px;
    overflow-y:auto;
    font-size:12px;
  }
  #queryHistorySidebar .item{
    padding:6px 6px;
    border-radius:4px;
    cursor:pointer;
    border:1px solid transparent;
    margin-bottom:4px;
  }
  #queryHistorySidebar .item:hover{
    background:#f3f4f6;
    border-color:#e5e7eb;
  }
  #queryHistorySidebar .item .meta{
    font-size:11px;
    color:#6b7280;
    margin-bottom:2px;
  }
  #queryHistorySidebar .item .sql{
    font-family:SFMono-Regular,Menlo,Monaco,Consolas,'Liberation Mono','Courier New',monospace;
    white-space:nowrap;
    overflow:hidden;
    text-overflow:ellipsis;
  }
  #queryHistorySidebar .empty{
    font-size:12px;
    color:#9ca3af;
    padding:8px 4px;
  }
  #personalSqlSaveBackdrop .export-group{
    margin:0;
  }
  #personalSqlSaveBackdrop .export-group + .export-group{
    border-top:1px solid #e5e7eb;
    padding-top:8px;
  }

  /* My Info modal (light theme) */
  #myInfoBackdrop .export-modal{
    max-width:1220px;
    width:100%;
    color:#111827;
  }
  #myInfoBackdrop .shell{
    display:flex;
    flex-direction:column;
    gap:12px;
  }
  #myInfoBackdrop header{
    display:flex;
    align-items:flex-start;
    justify-content:space-between;
    gap:12px;
    margin-bottom:4px;
  }
  #myInfoBackdrop .title-area h1{
    margin:0;
    font-size:18px;
    display:flex;
    align-items:center;
    gap:8px;
  }
  #myInfoBackdrop .title-badge{
    font-size:11px;
    padding:2px 8px;
    border-radius:999px;
    border:1px solid #d1d5db;
    background:#f9fafb;
    color:#4b5563;
  }
  #myInfoBackdrop .title-sub{
    margin-top:4px;
    font-size:12px;
    color:#6b7280;
  }
  #myInfoBackdrop .pill-meta{
    display:flex;
    align-items:center;
    gap:8px;
    font-size:11px;
    color:#6b7280;
  }
  #myInfoBackdrop .pill-meta span{
    padding:3px 7px;
    border-radius:999px;
    border:1px solid #e5e7eb;
    background:#f9fafb;
    display:flex;
    align-items:center;
    gap:4px;
  }
  #myInfoBackdrop .pill-dot{
    width:7px;
    height:7px;
    border-radius:999px;
    display:inline-block;
  }
  #myInfoBackdrop main{
    display:grid;
    grid-template-columns:minmax(0,1.35fr) minmax(0,1.1fr);
    gap:12px;
    margin-top:6px;
  }
  @media (max-width:1024px){
    #myInfoBackdrop main{
      grid-template-columns:1fr;
    }
  }
  #myInfoBackdrop .card{
    background:#f9fafb;
    border-radius:8px;
    border:1px solid #e5e7eb;
    padding:10px 12px;
  }
  #myInfoBackdrop .card-header{
    display:flex;
    align-items:flex-start;
    justify-content:space-between;
    gap:10px;
    margin-bottom:6px;
  }
  #myInfoBackdrop .card-title{
    font-size:13px;
    font-weight:600;
    display:flex;
    align-items:center;
    gap:6px;
  }
  #myInfoBackdrop .card-title-icon{
    width:18px;
    height:18px;
    border-radius:999px;
    display:flex;
    align-items:center;
    justify-content:center;
    font-size:11px;
    background:#dcfce7;
    color:#15803d;
  }
  #myInfoBackdrop .card-title-icon.sec{
    background:#e0f2fe;
    color:#0369a1;
  }
  #myInfoBackdrop .card-title-icon.warn{
    background:#fee2e2;
    color:#b91c1c;
  }
  #myInfoBackdrop .card-desc{
    font-size:11px;
    color:#6b7280;
  }
  #myInfoBackdrop .card-toolbar{
    display:flex;
    align-items:center;
    gap:6px;
    font-size:11px;
  }
  #myInfoBackdrop .tag-soft{
    padding:3px 7px;
    border-radius:999px;
    border:1px solid #e5e7eb;
    color:#4b5563;
    background:#f9fafb;
  }
  #myInfoBackdrop .tag-soft.accent{
    border-color:#22c55e;
    color:#166534;
    background:#dcfce7;
  }
  #myInfoBackdrop .tag-soft.warn{
    border-color:#f97316;
    color:#9a3412;
    background:#ffedd5;
  }
  #myInfoBackdrop .profile-grid{
    display:grid;
    grid-template-columns:120px minmax(0,1fr);
    gap:8px 12px;
    font-size:12px;
  }
  @media (max-width:640px){
    #myInfoBackdrop .profile-grid{
      grid-template-columns:1fr;
    }
  }
  #myInfoBackdrop .avatar-block{
    display:flex;
    flex-direction:column;
    align-items:center;
    gap:6px;
  }
  #myInfoBackdrop .avatar-ring{
    width:70px;
    height:70px;
    border-radius:999px;
    background:#00b894;
    color:#ffffff;
    display:flex;
    align-items:center;
    justify-content:center;
    font-weight:700;
    font-size:28px;
  }
  #myInfoBackdrop .avatar-label{
    font-size:11px;
    color:#6b7280;
  }
  #myInfoBackdrop dl.profile-fields{
    margin:0;
    display:grid;
    grid-template-columns:110px minmax(0,1fr);
    row-gap:4px;
    column-gap:6px;
  }
  #myInfoBackdrop dl.profile-fields dt{
    font-size:11px;
    color:#6b7280;
  }
  #myInfoBackdrop dl.profile-fields dd{
    margin:0;
    font-size:12px;
    color:#111827;
  }
  #myInfoBackdrop .hint{
    margin-top:4px;
    font-size:10px;
    color:#9ca3af;
  }
  #myInfoBackdrop .roles-list{
    list-style:none;
    padding:0;
    margin:0;
    display:flex;
    flex-direction:column;
    gap:4px;
    font-size:12px;
  }
  #myInfoBackdrop .roles-list li{
    display:flex;
    align-items:flex-start;
    gap:6px;
  }
  #myInfoBackdrop .roles-label{
    min-width:74px;
    font-size:11px;
    color:#6b7280;
  }
  #myInfoBackdrop .roles-badges{
    display:flex;
    flex-wrap:wrap;
    gap:4px;
  }
  #myInfoBackdrop .badge{
    padding:2px 6px;
    border-radius:999px;
    border:1px solid #e5e7eb;
    font-size:11px;
    background:#fff;
    color:#111827;
  }
  #myInfoBackdrop .section-grid{
    display:grid;
    grid-template-columns:minmax(0,1.1fr) minmax(0,1fr);
    gap:8px;
  }
  @media (max-width:900px){
    #myInfoBackdrop .section-grid{
      grid-template-columns:1fr;
    }
  }
  #myInfoBackdrop .log-list{
    list-style:none;
    padding:0;
    margin:4px 0 0;
    display:flex;
    flex-direction:column;
    gap:4px;
    font-size:11px;
  }
  #myInfoBackdrop .log-item{
    padding:4px 6px;
    border-radius:6px;
    border:1px solid #e5e7eb;
    background:#fff;
    display:flex;
    flex-direction:column;
    gap:2px;
  }
  #myInfoBackdrop .log-main{
    display:flex;
    justify-content:space-between;
    gap:8px;
  }
  #myInfoBackdrop .log-meta{
    font-size:10px;
    color:#6b7280;
  }
  #myInfoBackdrop .foot-hint{
    font-size:10px;
    color:#9ca3af;
    text-align:right;
    margin-top:4px;
  }
  #myInfoBackdrop .db-access-toolbar{
    display:flex;
    align-items:center;
    gap:8px;
    margin-bottom:8px;
    font-size:11px;
    color:#6b7280;
  }
  #myInfoBackdrop .db-access-toolbar .segmented{
    display:inline-flex;
    border-radius:999px;
    border:1px solid #e5e7eb;
    overflow:hidden;
  }
  #myInfoBackdrop .db-access-toolbar button{
    border:none;
    background:transparent;
    color:inherit;
    font-size:11px;
    padding:4px 10px;
  }
  #myInfoBackdrop .db-access-toolbar button.is-active{
    background:#e5e7eb;
    color:#111827;
  }
  #myInfoBackdrop #dbSearchInput{
    flex:1;
    min-width:0;
    padding:4px 8px;
    border-radius:999px;
    border:1px solid #e5e7eb;
    font-size:11px;
  }
  #myInfoBackdrop #dbSearchInput:focus{
    outline:none;
    border-color:#3b82f6;
    box-shadow:0 0 0 1px rgba(59,130,246,0.4);
  }
  #myInfoBackdrop .table-wrap{
    border-radius:8px;
    border:1px solid #d1d5db;
    background:#fff;
    overflow:hidden;
  }
  #myInfoBackdrop table{
    width:100%;
    border-collapse:collapse;
    font-size:11px;
  }
  #myInfoBackdrop thead{
    background:#f3f4f6;
  }
  #myInfoBackdrop thead th{
    padding:6px 7px;
    font-weight:500;
    color:#374151;
    border-bottom:1px solid #e5e7eb;
    text-align:left;
    white-space:nowrap;
  }
  #myInfoBackdrop tbody tr{
    border-bottom:1px solid #e5e7eb;
  }
  #myInfoBackdrop tbody tr:nth-child(even){
    background:#f9fafb;
  }
  #myInfoBackdrop tbody td{
    padding:5px 7px;
    white-space:nowrap;
    text-overflow:ellipsis;
    overflow:hidden;
    max-width:200px;
  }
  #myInfoBackdrop .env-pill{
    display:inline-flex;
    align-items:center;
    gap:4px;
    padding:2px 6px;
    border-radius:999px;
    font-size:10px;
    border:1px solid #22c55e;
    color:#166534;
    background:#dcfce7;
  }
  #myInfoBackdrop .env-pill.prod{
    border-color:#f97316;
    color:#9a3412;
    background:#ffedd5;
  }
  #myInfoBackdrop .role-pill{
    padding:2px 6px;
    border-radius:999px;
    border:1px solid #e5e7eb;
    font-size:10px;
    color:#111827;
    background:#fff;
  }
  #myInfoBackdrop .mini-table{
    width:100%;
    border-collapse:collapse;
    font-size:11px;
    margin-top:4px;
  }
  #myInfoBackdrop .mini-table th,
  #myInfoBackdrop .mini-table td{
    padding:4px 4px;
    text-align:left;
    border-bottom:1px solid #e5e7eb;
  }
  #myInfoBackdrop .mini-table th{
    font-weight:500;
    color:#374151;
  }
  #myInfoBackdrop .mini-table tbody tr:nth-child(even){
    background:#f9fafb;
  }
  #myInfoBackdrop .status-pill{
    padding:2px 6px;
    border-radius:999px;
    font-size:10px;
    border:1px solid #e5e7eb;
    background:#fff;
  }
  #myInfoBackdrop .status-pill.wait{
    border-color:#facc15;
    color:#854d0e;
    background:#fef9c3;
  }
  #myInfoBackdrop .status-pill.ok{
    border-color:#22c55e;
    color:#166534;
    background:#dcfce7;
  }
  #myInfoBackdrop .status-pill.reject{
    border-color:#f97316;
    color:#9a3412;
    background:#ffedd5;
  }
  #myInfoBackdrop .myinfo-footer{
    margin-top:10px;
    text-align:right;
  }
  .plan-summary-badge{
    display:inline-flex;
    align-items:center;
    gap:4px;
    padding:2px 6px;
    border-radius:999px;
    font-size:11px;
    border:1px solid transparent;
    margin-left:8px;
  }
  .plan-ok{
    color:var(--ok);
    border-color:var(--ok);
    background:#ecfdf3;
  }
  .plan-warn{
    color:var(--warn-ink);
    border-color:var(--warn-ink);
    background:#fffbeb;
  }
  .plan-danger{
    color:var(--danger);
    border-color:var(--danger);
    background:#fef2f2;
  }
  .plan-summary-badge i{
    font-size:11px;
  }



  
  /* === Connection Settings modal === */
  .conn-settings-modal{
    max-width:720px;
    width:720px;
  }
  .conn-settings-body{
    display:flex;
    flex-direction:column;
    gap:12px;
  }
  .conn-settings-grid{
    display:grid;
    grid-template-columns:1.2fr 1.3fr;
    gap:12px 16px;
    align-items:flex-start;
  }
  .conn-settings-group{
    display:flex;
    flex-direction:column;
    gap:4px;
  }
  .conn-settings-group label{
    font-size:12px;
    font-weight:600;
    color:#374151;
  }
  .conn-settings-input,
  .conn-settings-select{
    width:100%;
    padding:4px 6px;
    border:1px solid #d1d5db;
    border-radius:4px;
    font-size:12px;
  }
  .conn-settings-input:focus,
  .conn-settings-select:focus{
    outline:none;
    border-color:#0ea5e9;
    box-shadow:0 0 0 1px rgba(14,165,233,0.3);
  }
  .conn-settings-row{
    display:flex;
    gap:8px;
  }
  .conn-settings-row .conn-settings-group{
    flex:1;
  }
  .conn-settings-footer{
    border-top:1px solid #e5e7eb;
    margin-top:8px;
    padding-top:8px;
    display:flex;
    justify-content:space-between;
    gap:8px;
    align-items:center;
  }
  .conn-settings-footer-left{
    font-size:11px;
    color:#6b7280;
  }
  .conn-settings-footer-right{
    display:flex;
    gap:8px;
  }
  .conn-settings-modal{
    position:relative;
  }
  .conn-settings-modal .conn-settings-close-btn{
    position:absolute;
    top:8px;
    right:10px;
  }
  .conn-settings-modal .export-modal-header{
    position:relative;
    padding-right:32px;
  }
  #personalSqlLoadBackdrop .export-modal-header{
    position:relative;
    padding-right:32px;
  }

  .export-modal-header > button{
    position:absolute;
    top:8px;
    right:8px;
  }


/* === Table Edit (DBeaver-style) modal === */
  .table-edit-modal{
    max-width:960px;
    width:960px;
  }

  .table-edit-body{
    display:flex;
    flex-direction:column;
    gap:8px;
  }

  .te-header{
    padding-bottom:4px;
  }

  .te-table-name{
    font-size:13px;
    font-weight:600;
  }

  .te-table-meta{
    font-size:11px;
    color:#6b7280;
  }

  .te-tabs{
    display:flex;
    gap:4px;
    border-bottom:1px solid #e5e7eb;
    margin-top:4px;
  }

  .te-tab-btn{
    border:none;
    background:none;
    padding:6px 10px;
    font-size:12px;
    cursor:pointer;
    border-bottom:2px solid transparent;
  }

  .te-tab-btn.active{
    border-bottom-color:#00857C;
    font-weight:600;
  }

  .te-main-panes{
    margin-top:4px;
  }

  .te-pane{
    display:none;
    max-height:420px;
    overflow:auto;
  }

  .te-pane.active{
    display:block;
  }

  .te-subtabs{
    display:flex;
    flex-wrap:wrap;
    gap:4px;
    border-bottom:1px solid #e5e7eb;
    padding:4px 0;
    margin-bottom:4px;
  }

  .te-subtab-btn{
    border:none;
    background:none;
    font-size:11px;
    padding:3px 8px;
    border-radius:999px;
    cursor:pointer;
  }

  .te-subtab-btn.active{
    background:#00857C;
    color:#fff;
  }

  .te-subpane{
    display:none;
  }

  .te-subpane.active{
    display:block;
  }

  .te-table-wrapper{
    border:1px solid #e5e7eb;
    border-radius:6px;
    overflow:auto;
  }

  .te-grid{
    width:100%;
    border-collapse:collapse;
  }

  .te-grid th,
  .te-grid td{
    padding:4px 6px;
    font-size:11px;
    border-bottom:1px solid #e5e7eb;
  }

  .te-grid th{
    background:#f9fafb;
    text-align:left;
  }

  .te-placeholder{
    font-size:12px;
    color:#6b7280;
    padding:12px 4px;
  }

  .te-ddl{
    font-family: SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;
    font-size:11px;
    background:#0b1120;
    color:#e5e7eb;
    padding:8px;
    border-radius:4px;
    overflow:auto;
  }
  /* --- Admin / Management overlay ---------------------------------------- */
  .admin-overlay{
    position:fixed;
    inset:0;
    background:rgba(15,23,42,0.55);
    display:none;
    align-items:stretch;
    justify-content:center;
    z-index:1200;
  }
  .admin-overlay.show{
    display:flex;
  }
  .admin-shell{
    background:#ffffff;
    color:var(--ink);
    width:960px;
    max-width:calc(100% - 80px);
    max-height:calc(100% - 80px);
    display:flex;
    box-shadow:0 20px 40px rgba(15,23,42,0.4);
    border-radius:10px;
    overflow:hidden;
    border:1px solid #e5e7eb;
  }
  .admin-sidebar{
    width:260px;
    background:#f1f5f9;
    border-right:1px solid #e5e7eb;
    padding:12px 10px;
    display:flex;
    flex-direction:column;
    gap:4px;
  }
  .admin-sidebar h3{
    margin:4px 4px 8px;
    font-size:14px;
    font-weight:600;
    color:var(--hana-primary);
    display:flex;
    align-items:center;
    gap:6px;
  }
  .admin-nav-section{
    margin-bottom:8px;
  }
  .admin-nav-section-title{
    font-size:11px;
    font-weight:600;
    color:var(--muted);
    text-transform:uppercase;
    letter-spacing:.04em;
    margin:4px 6px;
  }
  .admin-nav button{
    width:100%;
    text-align:left;
    border-radius:6px;
    border:none;
    padding:5px 8px;
    font-size:12px;
    background:transparent;
    cursor:pointer;
  }
  .admin-nav button:hover{
    background:#e2f3f0;
  }
  .admin-nav button.active{
    background:var(--hana-primary);
    color:#e8fbf8;
  }
  .admin-content{
    flex:1;
    display:flex;
    flex-direction:column;
    padding:12px 14px;
    gap:8px;
  }
  .admin-header{
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap:8px;
    border-bottom:1px solid #e5e7eb;
    padding-bottom:6px;
  }
  .admin-header h2{
    font-size:16px;
    margin:0;
    display:flex;
    align-items:center;
    gap:6px;
  }
  .admin-header .badge{
    font-size:11px;
    padding:2px 6px;
    border-radius:999px;
    background:#ecfdf3;
    color:var(--hana-primary);
    border:1px solid #bbf7d0;
  }
  .admin-body{
    flex:1;
    overflow:auto;
    padding-right:4px;
  }
  .admin-grid{
    display:grid;
    grid-template-columns:repeat(auto-fill,minmax(230px,1fr));
    gap:8px;
  }
  .admin-card{
    border-radius:8px;
    border:1px solid #e5e7eb;
    padding:8px 9px;
    font-size:12px;
    background:#ffffff;
  }
  .admin-card h4{
    margin:0 0 4px;
    font-size:13px;
    display:flex;
    align-items:center;
    gap:4px;
  }
  .admin-card p{
    margin:0;
    color:var(--muted);
    font-size:12px;
    line-height:1.4;
  }
  .admin-tags{
    margin-top:4px;
    display:flex;
    flex-wrap:wrap;
    gap:4px;
  }
  .admin-tag{
    font-size:10px;
    padding:2px 5px;
    border-radius:999px;
    border:1px solid #e5e7eb;
    background:#f8fafc;
    color:#64748b;
  }
  .admin-footer{
    margin-top:4px;
    text-align:right;
    font-size:11px;
    color:var(--muted);
  }
  .admin-close{
    border:none;
    background:transparent;
    cursor:pointer;
    font-size:14px;
    color:var(--muted);
  }
  @media (max-width:900px){
    .admin-shell{
      width:100%;
      max-width:calc(100% - 24px);
    }
    .admin-sidebar{
      display:none;
    }
  }


  /* Query progress overlay (Hana style) */
  .query-progress-overlay{
    position: fixed;
    inset: 0;
    background: rgba(15,23,42,0.35);
    display: none;
    align-items: center;
    justify-content: center;
    z-index: 9999;
    pointer-events: none;
  }
  .query-progress-overlay.is-active{
    display: flex;
    pointer-events: auto;
  }
  .qp-inner{
    background: rgba(15,23,42,0.94);
    border-radius: 18px;
    box-shadow: 0 18px 45px rgba(15,23,42,0.55);
    padding: 20px 28px 18px;
    min-width: 260px;
    max-width: 360px;
    display: flex;
    flex-direction: column;
    gap: 10px;
    align-items: stretch;
    border: 1px solid rgba(148,163,184,0.4);
  }
  .qp-logo-wrap{
    display: flex;
    align-items: center;
    gap: 10px;
    margin-bottom: 4px;
  }
  .qp-logo-pulse{
    width: 30px;
    height: 30px;
    border-radius: 999px;
    display: flex;
    align-items: center;
    justify-content: center;
    background: radial-gradient(circle at 30% 20%, #22e4b8 0, #00a89d 40%, #036666 100%);
    box-shadow: 0 0 0 0 rgba(34,228,184,0.55);
    animation: qp-pulse 1.4s ease-out infinite;
  }
  .qp-logo-circle{
    width: 20px;
    height: 20px;
    border-radius: 999px;
    background: #0f172a;
    display: flex;
    align-items: center;
    justify-content: center;
    position: relative;
  }
  .qp-logo-bar{
    width: 9px;
    height: 14px;
    border-radius: 999px;
    background: linear-gradient(180deg,#22e4b8,#a3e635);
    box-shadow: 0 0 0 1px rgba(15,23,42,0.7);
  }
  .qp-logo-label{
    font-size: 13px;
    font-weight: 600;
    letter-spacing: 0.02em;
    color: #e5f0ff;
  }
  .qp-bar{
    position: relative;
    width: 100%;
    height: 4px;
    border-radius: 999px;
    background: rgba(30,64,175,0.3);
    overflow: hidden;
  }
  .qp-bar-fill{
    position: absolute;
    inset: 0;
    width: 45%;
    background: linear-gradient(90deg,#22e4b8,#a3e635);
    transform: translateX(-120%);
    animation: qp-slide 1.1s ease-in-out infinite;
  }
  .qp-text{
    margin-top: 2px;
    font-size: 12px;
    color: #cbd5f5;
    text-align: right;
  }

  @keyframes qp-slide{
    0%{ transform: translateX(-120%); }
    50%{ transform: translateX(0%); }
    100%{ transform: translateX(120%); }
  }
  @keyframes qp-pulse{
    0%{ box-shadow: 0 0 0 0 rgba(34,228,184,0.45); transform: scale(1); }
    70%{ box-shadow: 0 0 0 12px rgba(34,228,184,0); transform: scale(1.04); }
    100%{ box-shadow: 0 0 0 0 rgba(34,228,184,0); transform: scale(1); }
  }

.table-edit-modal {
  position: relative;
}

.table-edit-modal .table-edit-close-btn {
  position: absolute;
  top: 8px;
  right: 10px;
}

.table-edit-modal .export-modal-header{
  padding-right: 28px;
}



  .approval-close-btn {
  position: absolute;
  top: 8px;
  right: 10px;
}
.approval-modal {
  max-height: calc(100vh - 20px);
  display: flex;
  flex-direction: column;
}
.approval-modal .export-modal-body {
  flex: 1 1 auto;
  min-height: 0;
  overflow-y: auto;
}



.approval-modal .export-modal-header{
  position: relative;
  padding-right: 28px;
}

    /* DB Tree folder toolbar & selection/drag */
    .dbtree-folder-toolbar{
      display:flex;
      align-items:center;
      gap:4px;
      margin-left:auto;
    }
    .dbtree-folder-toolbar button{
      position:relative;
      border:none;
      background:transparent;
      padding:0;
      cursor:pointer;
      display:inline-flex;
      align-items:center;
      justify-content:center;
      width:26px;
      height:20px;
    }
    .dbtree-folder-toolbar button i.fa-folder{
      color:#f7d154;
      font-size:16px;
    }
    .dbtree-folder-toolbar button i.dbtree-folder-plus{
      position:absolute;
      right:-2px;
      bottom:-2px;
      font-size:10px;
      color:var(--hana-primary-600,#00786F);
    }

    #dbTree .node.dbtree-selected{
      background:#e1f3ff;
      outline:1px solid #9cc7ff;
      border-radius:6px;
    }
    #dbTree .node.dbtree-dragging{
      opacity:.4;
    }
    #dbTree li.dbtree-drop-target > .node{
      outline:1px dashed #4a90e2;
      background:#f0f7ff;
    }

    /* DB 필터링 시 숨김 처리용 */
    #dbTree .dbfilter-hidden{
      display:none !important;
    }

    /* DB 이름 옆 (필터링됨) 태그 */
    #dbTree .dbfilter-tag{
      margin-left:4px;
      font-size:11px;
      color:#c45a00;
    }



    
    /* DB 필터 모달 헤더/푸터 정렬 및 닫기 버튼 */
    #dbFilterBackdrop .export-modal-header{
      position:relative;
      padding-right:32px;
    }
    #dbFilterBackdrop .dbfilter-close-btn{
      position:absolute;
      top:8px;
      right:8px;
      border:none;
      background:transparent;
      font-size:18px;
      line-height:1;
      cursor:pointer;
    }
    #dbFilterBackdrop .export-modal-footer{
      display:flex;
      justify-content:flex-end;
      gap:8px;
    }

    /* DB 필터 모달 인풋 폭 조정 */
    #dbFilterBackdrop #dbFilterInput{
      width:100%;
      box-sizing:border-box;
    }
#dbTree .dbtree-folder-edit{
  font-size:12px;
  padding:4px 6px;
  margin-left:2px;
  border:1px solid #9cc7ff;
  border-radius:3px;
  box-sizing:border-box;
  display:inline-block;
  min-width:140px;
  max-width:240px;
  line-height:1.4;
}

    #dbTree li > .node{
      position:relative;
    }
    #dbTree .dbtree-folder-edit-error{
      position:absolute;
      left:2px;
      top:100%;
      margin-top:2px;
      background:#fffbe6;
      border:1px solid #ffb84d;
      color:#c45a00;
      font-size:10px;
      padding:1px 4px;
      border-radius:3px;
      white-space:nowrap;
      z-index:10;
      pointer-events:none;
    }


  /* 부재중 & 대결자 관리 모달 전용 스타일 (modal.html에서 가져옴) */
.modal-backdrop {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.35);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 200;
    }
    .modal-backdrop.open {
      display: flex;
    }
    .modal {
      background: #fff;
      border-radius: 10px;
      width: 980px;
      max-width: 95vw;
      max-height: 90vh;
      display: flex;
      flex-direction: column;
      box-shadow: 0 8px 30px rgba(0,0,0,0.25);
    }
    .modal-header {
      padding: 12px 16px;
      border-bottom: 1px solid #e5e7eb;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .modal-title {
      font-size: 15px;
      font-weight: 600;
    }
    .modal-close-btn {
      border: none;
      background: transparent;
      cursor: pointer;
      font-size: 18px;
      line-height: 1;
      color: #666;
    }
    .modal-body {
      padding: 12px 16px 16px 16px;
      overflow: auto;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }
    .modal-footer {
      padding: 10px 16px;
      border-top: 1px solid #e5e7eb;
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 12px;
    }

    /* 탭 */
    .tab-header {
      display: inline-flex;
      border-radius: 999px;
      padding: 2px;
      background: #f3f4f6;
      gap: 2px;
      margin-bottom: 4px;
    }
    .tab-btn {
      border-radius: 999px;
      border: none;
      background: transparent;
      padding: 6px 14px;
      font-size: 13px;
      cursor: pointer;
      color: #555;
    }
    .tab-btn.active {
      background: #005f4f;
      color: #fff;
    }
    .tab-panel {
      display: none;
    }
    .tab-panel.active {
      display: block;
    }

    /* 현재 상태 카드 */
    .status-card {
      border-radius: 8px;
      background: #f0fdf4;
      border: 1px solid #bbf7d0;
      padding: 12px;
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      gap: 12px;
      font-size: 13px;
    }
    .status-card.inactive {
      background: #f9fafb;
      border-color: #e5e7eb;
    }
    .status-chip {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      padding: 2px 8px;
      border-radius: 999px;
      font-size: 11px;
      font-weight: 500;
    }
    .status-chip.active {
      background: #16a34a;
      color: #fff;
    }
    .status-chip.planned {
      background: #2563eb;
      color: #fff;
    }
    .status-chip.expired {
      background: #9ca3af;
      color: #fff;
    }
    .status-meta {
      margin-top: 4px;
      color: #555;
    }
    .status-actions {
      display: flex;
      flex-direction: column;
      gap: 6px;
      align-items: flex-end;
    }

    /* 폼 레이아웃 */
    .form-grid {
      display: grid;
      grid-template-columns: 1fr 1fr 2.1fr;
      gap: 12px;
      margin-top: 4px;
      margin-bottom: 8px;
    }
    .form-group-wide{
      grid-column: 1 / -1;
    }
    .form-section {
      margin-top: 10px;
      padding-top: 10px;
      border-top: 1px solid #e5e7eb;
    }
    .form-section:first-of-type {
      margin-top: 0;
      padding-top: 0;
      border-top: none;
    }

    .form-group {
      display: flex;
      flex-direction: column;
      gap: 4px;
      font-size: 13px;
    }
    .form-label {
      font-weight: 500;
      color: #374151;
    }
    .form-label span.req {
      color: #dc2626;
      margin-left: 2px;
    }
    .form-control, .form-select, .form-textarea {
      border-radius: 6px;
      border: 1px solid #d1d5db;
      padding: 6px 8px;
      font-size: 13px;
    }
    .form-control:focus,
    .form-select:focus,
    .form-textarea:focus {
      outline: none;
      border-color: #005f4f;
      box-shadow: 0 0 0 1px rgba(0,95,79,0.2);
    }
    .form-textarea {
      resize: vertical;
      min-height: 96px;
    }
    .inline-row {
      display: flex;
      gap: 8px;
      align-items: center;
    }
    .inline-row > .form-control{
      flex: 1 1 auto;
      min-width: 0;
    }
    .inline-row > button{
      flex: 0 0 auto;
    }
    .checkbox-group {
      display: flex;
      flex-wrap: wrap;
      gap: 6px 12px;
    }
    .checkbox-item {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      font-size: 12px;
    }
    .helper-text {
      font-size: 11px;
      color: #6b7280;
    }
    .error-text {
      font-size: 11px;
      color: #dc2626;
      margin-top: 2px;
    }

    /* 버튼 */
    .btn {
      border-radius: 6px;
      border: 1px solid transparent;
      padding: 6px 12px;
      font-size: 13px;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 4px;
    }
    .btn-primary {
      background: #005f4f;
      color: #fff;
      border-color: #005f4f;
    }
    .btn-primary:hover {
      background: #00463c;
      color: #fff;
      border-color: #00463c;
    }

    .btn-primary:disabled {
      background: #9ca3af;
      border-color: #9ca3af;
      cursor: default;
    }
    .btn-outline {
      background: #fff;
      color: #374151;
      border-color: #d1d5db;
    }
    .btn-ghost {
      background: transparent;
      color: #374151;
      border-color: transparent;
    }
    .btn-sm {
      padding: 4px 8px;
      font-size: 12px;
    }
    .btn-sort {
      border-radius: 999px;
      border-color: #d1d5db;
      background: #fff;
    }
    .btn-sort:hover {
      background: #f3f4f6;
    }


    .quick-buttons {
      display: flex;
      gap: 6px;
      flex-wrap: wrap;
    }

    /* 이력 테이블 */
    table {
      border-collapse: collapse;
      width: 100%;
      font-size: 12px;
      background: #fff;
      border-radius: 8px;
      overflow: hidden;
    }
    thead {
      background: #f9fafb;
    }
    th, td {
      border-bottom: 1px solid #e5e7eb;
      padding: 6px 8px;
      text-align: left;
    }
    #historyTbody td {
      text-align: center;
    }
    #historyTbody td.reason-cell {
      text-align: left;
    }

    th {
      font-weight: 600;
      color: #4b5563;
      white-space: nowrap;
    }
    tbody tr:hover {
      background: #f3f4f6;
    }
    td.nowrap {
      white-space: nowrap;
    }
    .badge {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 2px 8px;
      border-radius: 999px;
      font-size: 11px;
    }
    .badge-used {
      background: #dcfce7;
      color: #166534;
    }
    .badge-planned {
      background: #dbeafe;
      color: #1d4ed8;
    }
    .badge-expired {
      background: #e5e7eb;
      color: #374151;
    }
    .badge-force {
      background: #fee2e2;
      color: #b91c1c;
    }

        .empty-text {
      font-size: 12px;
      color: #6b7280;
      padding: 8px 0;
    }

    .right {
      margin-left: auto;
    }

    /* 스크롤바 약간 정리 */
    ::-webkit-scrollbar {
      width: 6px;
      height: 6px;
    }
    ::-webkit-scrollbar-track {
      background: transparent;
    }
    ::-webkit-scrollbar-thumb {
      background: #cbd5f5;
      border-radius: 999px;
    }
  

    /* Tab context color dots */
    #tabCtx li[data-act="tab-color-default"] i.fa-circle { color: #9ca3af; }
    #tabCtx li[data-act="tab-color-blue"] i.fa-circle { color: #2563eb; }
    #tabCtx li[data-act="tab-color-green"] i.fa-circle { color: #16a34a; }
    #tabCtx li[data-act="tab-color-yellow"] i.fa-circle { color: #eab308; }
    #tabCtx li[data-act="tab-color-red"] i.fa-circle { color: #dc2626; }

</style>
</head>
<body>
<div class="app">
  <!-- Header / Menubar -->
  <header class="header">
    <div class="brand"><span class="dot"></span> DB 접근제어 콘솔</div>
    <nav class="menubar">
            <div class="menu">
        <div class="title">파일</div>
        <div class="dropdown">
          <a href="#" onclick="ui.newEditorTabFromMenu();return false;">새 SQL 탭</a>
          <a href="#" onclick="ui.openSqlFile();return false;">SQL 파일 불러오기</a>
          <a href="#" onclick="ui.openSqlSaveModal();return false;">현재 탭 SQL 저장…</a>
          <a href="#" onclick="ui.openPersonalSqlLoad();return false;">서버 개인 저장소에서 SQL 불러오기…</a>
          <a href="#" onclick="actions.printCurrentSql();return false;">현재 SQL 인쇄…</a>
          <a href="#" onclick="actions.printCurrentResult();return false;">현재 결과 인쇄…</a>
        </div>
      </div>

<div class="menu"><div class="title">편집</div><div class="dropdown">
        <a href="#" onclick="ui.formatSql();return false;">서식 정리</a>
        <a href="#" onclick="ui.clearEditor();return false;">비우기</a>
      </div></div>
      <div class="menu"><div class="title">보기</div><div class="dropdown">
        <a href="#" onclick="dbamStub('세션 모니터');return false;">세션 모니터</a>
        <a href="#" onclick="dbamStub('실시간 SQL 모니터');return false;">실시간 SQL 모니터</a>
      </div></div>
      <div class="menu"><div class="title">실행</div><div class="dropdown">
        <a href="#" onclick="actions.runCurrent();return false;">실행 — 선택 또는 현재문 (Ctrl+Enter)</a>
        <a href="#" onclick="actions.runScript();return false;">스크립트 실행 — 위→아래 (Ctrl+Shift+Enter)</a>
        <a href="#" onclick="actions.explain();return false;">실행 계획 — 현재문</a>
      </div></div>
      <div class="menu"><div class="title">도구</div><div class="dropdown">
        <a href="#" onclick="onClickExportExcel();return false;"><i class="fa-solid fa-file-excel"></i> Excel 내보내기</a>
        <a href="#" onclick="favorites.addFromEditor();return false;"><i class="fa-solid fa-star"></i> 현재 SQL 즐겨찾기 추가</a>
        <a href="#" onclick="snapshots.createFromCurrentTab();return false;"><i class="fa-solid fa-link"></i> 스냅샷 저장</a>
        <a href="#" onclick="snapshots.importFromPrompt();return false;"><i class="fa-solid fa-folder-open"></i> 스냅샷 불러오기</a>
        <a href="#" onclick="tests.run();return false;"><i class="fa-solid fa-vial"></i> 자가진단(테스트)</a>
      </div></div>
      <div class="menu"><div class="title">관리</div><div class="dropdown">
        <a href="#" onclick="admin.open('orgUser');return false;"><i class="fa-solid fa-shield-halved"></i> 관리 콘솔 열기</a>
        <a href="#" onclick="admin.open('logAudit');return false;"><i class="fa-solid fa-list-check"></i> 로그/감사 뷰</a>
        <a href="#" onclick="admin.open('anomalyReport');return false;"><i class="fa-solid fa-wave-square"></i> 이상행위 조회·리포트</a>
      </div></div>
      <!-- 도움말 메뉴 -->
      <div class="menu"><div class="title">도움말</div><div class="dropdown">
        <a href="#" onclick="ui.openShortcutHelpModal();return false;"><i class="fa-solid fa-circle-question"></i> 단축키 / 스니펫 안내</a>
      </div></div>
          </nav>
    <div class="status">
      <!-- 연결 상태 chip은 내부 로직 유지를 위해 남겨두되, 헤더에서는 숨김 처리 -->
      <span id="connStatus" class="chip" style="display:none;">연결되지 않음</span>
      <div class="header-actions">
        <button type="button" id="headerNotifBtn" class="header-icon-btn" title="알림">
          <i class="fa-regular fa-bell"></i>
          <span class="badge" id="headerNotifBadge">3</span>
        </button>
        <div class="header-user" id="headerUser">
          <button type="button" id="headerUserToggle" class="header-user-toggle" aria-haspopup="true" aria-expanded="false">
            <span class="avatar-circle">H</span>
            <span class="header-user-name" id="headerUserName">홍길동</span>
            <i class="fa-solid fa-caret-down"></i>
          </button>
          <div class="header-user-dropdown" 

id="headerUserDropdown">
            <button type="button" data-action="profile">
              <i class="fa-solid fa-user"></i><span>내 정보</span>
            </button>
            <button type="button" data-action="settings">
              <i class="fa-solid fa-gear"></i><span>내 설정…</span>
            </button>
            <button type="button" data-action="delegate">
              <i class="fa-solid fa-user-clock"></i><span>부재중 / 대결자 설정</span>
            </button>
            <button type="button" data-action="password">
              <i class="fa-solid fa-key"></i><span>비밀번호 변경</span>
            </button>
            <hr class="header-user-divider" />
            <button type="button" class="logout" data-action="logout">
              <i class="fa-solid fa-right-from-bracket"></i><span>로그아웃</span>
            </button>
          </div>


        </div>
      </div>
    </div>
  </header>

  <!-- Main: Sidebar | Resizer | Content -->
  <section class="main">
    <!-- Sidebar (DB Tree) -->
    <aside id="sidebar" class="sidebar">
      <div class="title">
        <strong>Database</strong>
        <div class="dbtree-folder-toolbar">
          <button type="button" id="dbtreeAddFolderBtn" title="폴더 추가">
            <i class="fa-regular fa-folder"></i>
            <i class="fa-solid fa-plus dbtree-folder-plus"></i>
          </button>
          <button type="button" id="dbtreeAddDbBtn" title="Database 추가">
            <i class="fa-solid fa-database"></i>
            <i class="fa-solid fa-plus dbtree-folder-plus"></i>
          </button>
        </div>
      </div>
      <div class="tree" id="dbTree">
        <div class="muted" style="padding:8px 6px">연결 후 목록이 표시됩니다.</div>
      </div>
    </aside>
    <div id="vResizer" class="v-resizer" title="좌/우 크기 조절"></div>

    <!-- Content Area -->
    <section class="content">
      <!-- Tabs -->
      <div class="tabs-wrapper">
        <button class="tab-scroll tab-scroll-left" onclick="ui.scrollTabs(-1)" title="왼쪽으로 스크롤">&lsaquo;</button>
        <div id="tabs" class="tabs">
          <!-- dynamic tabs -->
        </div>
        <button id="tabOverflowBtn" class="tab-overflow-btn hidden" onclick="ui.toggleTabOverflowMenu()" title="더 많은 탭">»</button>
        <button class="tab-scroll tab-scroll-right" onclick="ui.scrollTabs(1)" title="오른쪽으로 스크롤">&rsaquo;</button>
        <div id="tabOverflowMenu" class="tab-overflow-menu hidden"></div>
      </div>

      <!-- Environment Banner (운영 DB 경고) -->
      <div id="envBanner" class="env-banner env-banner--hidden" aria-live="polite">
        <div class="env-banner-icon">
          <i class="fa-solid fa-triangle-exclamation"></i>
        </div>
        <div class="env-banner-body">
          <div class="env-banner-head">
            <div id="envBannerTitle" class="env-banner-title">운영 DB에 접속 중입니다.</div>
            <div id="envBannerMeta" class="env-banner-meta">PROD · 고위험 환경</div>
          </div>
          <div id="envBannerDesc" class="env-banner-desc">운영 DB에서의 쿼리 실행 및 다운로드에는 강화된 통제·승인 정책이 적용됩니다.</div>
        </div>
      </div>

      <!-- Editor Toolbar -->
      <div class="toolbar">
        <button onclick="actions.runCurrent()"><i class="fa-solid fa-play"></i> 실행 (Ctrl+Enter)</button>
        <button onclick="actions.runScript()"><i class="fa-solid fa-forward"></i> 스크립트 실행 (Ctrl+Shift+Enter)</button>
        <button onclick="actions.cancelQuery()"><i class="fa-solid fa-stop"></i> 쿼리 정지</button>
        <button onclick="actions.explain()"><i class="fa-solid fa-magnifying-glass-chart"></i> 실행 계획(EXPLAIN)</button>
        <button id="btnAutoCommit" onclick="ui.toggleAutoCommit();return false;" title="Auto-commit ON/OFF">
          <i id="autoCommitIcon" class="fa-solid fa-toggle-on"></i>
          Auto-commit: <span id="autoCommitLabel">ON</span>
        </button>
        <button id="btnCommit" onclick="actions.commitTx();return false;" title="현재 연결 Commit" disabled>
          <i class="fa-solid fa-check"></i> Commit
        </button>
        <button id="btnRollback" onclick="actions.rollbackTx();return false;" title="현재 연결 Rollback" disabled>
          <i class="fa-solid fa-rotate-left"></i> Rollback
        </button>
        <div class="sp"></div>

        <!-- 스니펫/단축키 도움말 버튼 -->
        <button type="button"
                id="btnShortcutHelp"
                class="btn-icon"
                title="스니펫/단축키 도움말"
                onclick="ui.openShortcutHelpModal();">
          <i class="fa-solid fa-circle-question"></i>
        </button>

        <!-- 최근 쿼리 히스토리 사이드바 버튼 -->
        <button type="button"
                id="btnQueryHistorySidebar"
                class="btn-icon"
                title="최근 쿼리 히스토리 (현재 DB)"
                onclick="queryHistorySidebar.toggle();">
          <i class="fa-solid fa-clock-rotate-left"></i>
        </button>
      </div>

      <!-- Editor -->
      <div class="editor">
        <div class="codewrap">
          <textarea id="sqlEditor" placeholder="여기에 SQL을 작성하세요. 예) SELECT now();"></textarea>
        </div>
      </div>

      <!-- Horizontal Resizer -->
      <div id="hResizer" class="h-resizer" title="에디터/결과 높이 조절"></div>

      <!-- Bottom Area: 결과 / DDL / 히스토리 / 즐겨찾기 / 서버 API 탭 -->
      <div id="bottomArea" class="bottom-area" style="display:none;">
        <div class="bottom-tabs">
          <button type="button" class="bottom-tab active" data-panel="result">
            <i class="fa-solid fa-table"></i> 결과
          </button>
          <button type="button" class="bottom-tab" data-panel="ddlPanel">
            <i class="fa-solid fa-scroll"></i> DDL
          </button>
          <button type="button" class="bottom-tab" data-panel="historyPanel">
            <i class="fa-solid fa-clock-rotate-left"></i> 히스토리
          </button>
          <button type="button" class="bottom-tab" data-panel="sessionPanel">
            <i class="fa-solid fa-user-group"></i> 세션
          </button>
          <button type="button" class="bottom-tab bottom-tab--with-badge" data-panel="approvalPanel">
            <i class="fa-solid fa-stamp"></i> 쿼리 결재함
            <span id="approvalTodoBadge" class="bottom-tab-badge" style="display:none;">0</span>
          </button>
          <button type="button" class="bottom-tab" data-panel="favPanel">
            <i class="fa-solid fa-star"></i> 즐겨찾기
          </button>
          <button type="button" class="bottom-tab" data-panel="serverPanel">
            <i class="fa-solid fa-code"></i> 서버 API
          </button>
        </div>
        <div class="bottom-content">
          <!-- Result Panel (hidden until connected + executed) -->
          <div id="result" class="result">
            <div class="result-header">
              <strong><i class="fa-solid fa-table"></i> 결과</strong>
              <span id="execMeta" class="muted"></span>
              <div class="right">
                <button onclick="onClickExportExcel()"><i class="fa-solid fa-file-export"></i> Excel 내보내기</button>
                <button onclick="ui.clearResult()"><i class="fa-solid fa-eraser"></i> 지우기</button>
              </div>
            </div>
            <div class="result-body">
              <table id="grid" class="grid">
                <thead></thead>
                <tbody></tbody>
              </table>
              <div id="messages" class="muted" style="padding:10px"></div>
            </div>
          </div>

          <!-- DDL Panel -->
          <div id="ddlPanel" class="result hidden">
            <div class="result-header">
              <strong><i class="fa-solid fa-scroll"></i> DDL / 구조</strong>
              <span id="ddlTitle" class="muted"></span>
              <div class="right">
                <button onclick="ddlPanel.clear();return false;"><i class="fa-solid fa-eraser"></i> 지우기</button>
              </div>
            </div>
            <div class="result-body" style="min-height:100px;max-height:none;overflow:auto">
              <pre id="ddlText" style="white-space:pre; margin:0; font-family:monospace; font-size:12px;"></pre>
            </div>
          </div>

          <!-- Query History Panel -->
          <div id="historyPanel" class="result hidden">
            <div class="result-header">
              <strong><i class="fa-solid fa-clock-rotate-left"></i> 쿼리 히스토리</strong>
              <span class="muted" style="font-size:12px">더블클릭: 현재 탭으로 불러오기</span>
              <div class="right">
                <button onclick="historyPanel.clear();return false;"><i class="fa-solid fa-trash"></i> 모두 지우기</button>
              </div>
            </div>
            <div class="result-body" style="min-height:80px;max-height:none;overflow-y:auto;overflow-x:hidden">
              <div style="margin-bottom:4px;">
                <select id="historySelect" style="width:100%;font-size:12px;padding:2px 4px;">
                  <option value="">최근 실행 내역</option>
                </select>
              </div>
              <table id="historyGrid" class="grid">
                <thead>
                  <tr>
                    <th>시간</th>
                    <th>DB</th>
                    <th>탭</th>
                    <th>행수</th>
                    <th>실행(ms)</th>
                    <th>SQL</th>
                  </tr>
                </thead>
                <tbody></tbody>
              </table>
            </div>
          </div>

          <div id="approvalPanel" class="result hidden">
            <div class="result-header">
              <strong><i class="fa-solid fa-stamp"></i> 쿼리 결재함 (데모)</strong>
              <span class="muted" style="font-size:12px">민감 테이블/중요 쿼리에 대한 승인 요청·결재·실행 상태를 확인합니다. (브라우저 새로고침 시 목록은 초기화됩니다.)</span>
              <div class="right">
                <button type="button" onclick="approvalCenter.refresh();return false;"><i class="fa-solid fa-rotate"></i> 새로고침</button>
              </div>
            </div>
            <div class="result-body" style="min-height:120px;max-height:none;overflow-y:auto;overflow-x:hidden">
              <div style="margin-bottom:4px; display:flex; justify-content:space-between; align-items:center; font-size:12px;">
                <div style="color:#6b7280;">
                  아래 결재 요청 목록과 승인/반려/실행 동작은 현재 세션 사용자 기준으로 동작하는 데모입니다.
                </div>
                <div style="display:flex; align-items:center; gap:4px;">
                  <span style="color:#6b7280;">세션 사용자:</span>
                  <span id="sessionUserLabel" style="font-weight:600;">demoUser</span>
                  <button type="button" class="btn btn-sm" id="btnOpenSessionSwitch">
                    <i class="fa-solid fa-user-gear"></i> 세션 변경
                  </button>
                </div>
              </div>
              <div style="margin-bottom:6px; display:flex; gap:8px; align-items:center; font-size:12px;">
                <label style="display:flex; align-items:center; gap:4px;">
                  <span>보기:</span>
                  <select id="approvalFilter" onchange="approvalCenter.applyFilter(this.value)">
                    <option value="all">전체</option>
                    <option value="mine">내 요청</option>
                    <option value="todo">내 승인할 건</option>
                    <option value="approvedByMe">내가 승인한 것</option>
                    <option value="rejectedByMe">내가 반려한 것</option>
                    <option value="refByMe">내가 참조한 건</option>
                    <option value="completed">완료(승인/반려/실행)</option>
                  </select>
                </label>
                <label style="display:flex; align-items:center; gap:4px;">
                  <span>유형:</span>
                  <select id="approvalTypeFilter" onchange="approvalCenter.applyTypeFilter(this.value)">
                    <option value="all">전체</option>
                    <option value="sql">SQL만</option>
                    <option value="excel">엑셀만</option>
                  </select>
                </label>
                <label style="display:flex; align-items:center; gap:4px;">
                  <span>기간:</span>
                  <select id="approvalPeriod" onchange="approvalCenter.applyPeriod(this.value)">
                    <option value="7d">최근 7일</option>
                    <option value="30d" selected>최근 30일</option>
                    <option value="90d">최근 90일</option>
                    <option value="all">전체 기간</option>
                  </select>
                </label>
                <span class="muted" style="font-size:11px;">행을 클릭하면 상세 창에서 승인/반려/실행을 할 수 있습니다.</span>
              </div>
              <table id="approvalGrid" class="grid">
                <thead>
                  <tr>
                    <th style="text-align:center;">유형</th>
                    <th style="text-align:center;">상태</th>
                    <th style="text-align:center;">요청자</th>
                    <th style="text-align:center;">승인자</th>
                    <th style="text-align:center;">승인요청사유</th>
                    <th style="text-align:center;">허용 실행횟수</th>
                    <th style="text-align:center;">사용 실행횟수</th>
                    <th style="text-align:center;">유효 기간</th>
                    <th style="text-align:center;">요청시각</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td colspan="8" style="text-align:center; color:#6b7280; padding:8px;">아직 등록된 결재 요청이 없습니다.</td>
                  </tr>
                </tbody>
              </table>
            </div>
          </div>

          <!-- Favorites Panel -->
          <div id="favPanel" class="result hidden">
            <div class="result-header">
              <strong><i class="fa-solid fa-star"></i> 즐겨찾기 / 템플릿</strong>
              <span class="muted" style="font-size:12px">
                개인 즐겨찾기와 조직 공용 템플릿을 한 곳에서 관리합니다.
              </span>
              <div class="right">
                <button onclick="favorites.addFromEditor();return false;"><i class="fa-solid fa-plus"></i> 현재 SQL 추가</button>
              </div>
            </div>
            <div class="result-body favtpl-body" style="min-height:80px;max-height:none;overflow-x:hidden">
              <div class="favtpl-inner">
                                <div class="favtpl-head">
<div class="favtpl-tabs">
                  <button type="button" id="favtplTabPersonal" class="favtpl-tab-btn active" data-mode="personal">
                    개인 즐겨찾기
                  </button>
                  <button type="button" id="favtplTabOrg" class="favtpl-tab-btn" data-mode="org">
                    조직 공용 템플릿
                  </button>
                </div>
<div class="favtpl-hint">
                  클릭: 미리보기, 더블클릭: 현재 SQL 탭에 삽입 (개인 즐겨찾기 / 조직 템플릿 공통)
                </div>
                </div>

                <!-- 개인 즐겨찾기 영역 (새 UI, 리스트 + 미리보기) -->
                <div id="favPersonalWrap" class="favtpl-panel">
                  <div class="favtpl-filter-bar">
                    <label>시스템
                      <select id="favPersonalSys">
                        <option value="">전체</option>
                        <option value="DEV">DEV</option>
                        <option value="STG">STG</option>
                        <option value="PRD">PRD</option>
                      </select>
                    </label>
                    <label>카테고리
                      <select id="favPersonalCat">
                        <option value="">전체</option>
                        <option value="MONITOR">모니터링</option>
                        <option value="HISTORY">이력</option>
                        <option value="BATCH">배치</option>
                        <option value="ETC">기타</option>
                      </select>
                    </label>
                    <label>업무명
                      <select id="favPersonalBiz">
                        <option value="">전체</option>
                        <option value="MSG">메신저</option>
                        <option value="PORTAL">포탈</option>
                        <option value="COMMON">공통</option>
                        <option value="ETC">기타</option>
                      </select>
                    </label>
                    <label>검색
                      <input type="text" id="favPersonalKeyword" placeholder="이름 / SQL 본문" />
                    </label>
                  </div>
                  <div class="favtpl-main">
                    <div class="favtpl-list">
                      <table>
                        <tbody id="favPersonalBody"></tbody>
                      </table>
                    </div>
                    <div class="favtpl-preview">
                      <textarea id="favPersonalPreview" readonly placeholder="개인 즐겨찾기 SQL이 여기 미리보기로 표시됩니다."></textarea>
                      <div class="favtpl-preview-info">
                        <span id="favPersonalMetaLeft"></span>
                        <span id="favPersonalMetaRight"></span>
                      </div>
                    </div>
                  </div>
                </div>

                <!-- 조직 공용 템플릿 영역 (프로토타입) -->
                <div id="favOrgWrap" class="favtpl-panel hidden">
                  <div class="favtpl-filter-bar">
                    <label>시스템
                      <select id="favOrgSys">
                        <option value="">전체</option>
                        <option value="DEV">DEV</option>
                        <option value="STG">STG</option>
                        <option value="PRD">PRD</option>
                      </select>
                    </label>
                    <label>카테고리
                      <select id="favOrgCat">
                        <option value="">전체</option>
                        <option value="MONITOR">모니터링</option>
                        <option value="HISTORY">이력</option>
                        <option value="BATCH">배치</option>
                        <option value="ETC">기타</option>
                      </select>
                    </label>
                    <label>업무명
                      <select id="favOrgBiz">
                        <option value="">전체</option>
                        <option value="MSG">메신저</option>
                        <option value="PORTAL">포탈</option>
                        <option value="COMMON">공통</option>
                        <option value="ETC">기타</option>
                      </select>
                    </label>
                    <label>검색
                      <input type="text" id="favOrgKeyword" placeholder="이름 / 설명 / SQL / 태그" />
                    </label>
                  </div>
                  <div class="favtpl-main">
                    <div class="favtpl-list">
                      <table>
                        <tbody id="favOrgBody"></tbody>
                      </table>
                    </div>
                    <div class="favtpl-preview">
                      <textarea id="favOrgPreview" readonly placeholder="조직 공용 템플릿 SQL이 여기 미리보기로 표시됩니다."></textarea>
                      <div class="favtpl-preview-info">
                        <span id="favOrgMetaLeft"></span>
                        <span id="favOrgMetaRight"></span>
                      </div>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>


          <!-- Session Monitor Panel -->
          <div id="sessionPanel" class="result hidden">
            <div class="result-header">
              <strong><i class="fa-solid fa-user-group"></i> 현재 세션</strong>
              <span class="muted" style="font-size:12px">이 콘솔에서 열린 접속과 최근 실행 정보를 보여줍니다.</span>
              <div class="right">
                <button onclick="sessionMonitor.refresh();return false;"><i class="fa-solid fa-rotate"></i> 새로고침</button>
                <button onclick="sessionMonitor.clearClosed();return false;"><i class="fa-solid fa-broom"></i> 종료 세션 정리</button>
              </div>
            </div>
            <div class="result-body" style="min-height:80px;max-height:none;overflow-y:auto;overflow-x:hidden">
              <table id="sessionGrid" class="grid">
                <thead>
                  <tr>
                    <th>사용자</th>
                    <th>DB/연결</th>
                    <th>프로필</th>
                    <th>상태</th>
                    <th>위험도</th>
                    <th>최근 실행 (첫 줄)</th>
                    <th>업데이트</th>
                  </tr>
                </thead>
                <tbody></tbody>
              </table>
            </div>
          </div>

          <!-- Server API sample panel (toggle) -->
          <div id="serverPanel" class="result hidden">
            <div class="result-header">
              <strong><i class="fa-solid fa-code"></i> 서버 연동 샘플</strong>
              <span class="muted">Spring MVC + Timeout + MaxRows + EXPLAIN</span>
            </div>
            <div class="result-body" style="padding:10px">
<pre><code>// DTO
public record SqlExecRequest(String connId, String sql, Integer maxRows, Integer timeoutMs, boolean explain) {}
public record SqlExecResponse(List&lt;String&gt; columns, List&lt;Map&lt;String,Object&gt;&gt; rows, long elapsedMs) {}

// Controller
@RestController
@RequestMapping("/sql")
@RequiredArgsConstructor
public class SqlController {
  private final SqlService sqlService;

  @PostMapping("/execute")
  public ResponseEntity&lt;SqlExecResponse&gt; execute(@RequestBody SqlExecRequest req) {
    int maxRows = Optional.ofNullable(req.maxRows()).orElse(500);
    int timeoutMs = Optional.ofNullable(req.timeoutMs()).orElse(15000);
    long t0 = System.currentTimeMillis();
    List&lt;Map&lt;String,Object&gt;&gt; rows = sqlService.execute(req.connId(), req.sql(), maxRows, timeoutMs, req.explain());
    long elapsed = System.currentTimeMillis()-t0;
    List&lt;String&gt; columns = rows.isEmpty()? List.of() : new ArrayList&lt;&gt;(rows.get(0).keySet());
    return ResponseEntity.ok(new SqlExecResponse(columns, rows, elapsed));
  }
}

// Service (PostgreSQL 예시)
@Service
public class SqlService {
  public List&lt;Map&lt;String,Object&gt;&gt; execute(String connId, String sql, int maxRows, int timeoutMs, boolean explain) {
    String finalSql = explain ? "EXPLAIN " + sql : sql;
    try(Connection c = dataSourceFor(connId).getConnection();
        Statement st = c.createStatement()){
      st.setMaxRows(maxRows);
      st.setQueryTimeout(Math.max(1, timeoutMs/1000));
      try(ResultSet rs = st.executeQuery(finalSql)){
        return toList(rs);
      }
    } catch(SQLTimeoutException te){ throw new ResponseStatusException(HttpStatus.REQUEST_TIMEOUT, "Query timeout"); }
      catch(SQLException e){ throw new ResponseStatusException(HttpStatus.BAD_REQUEST, e.getMessage()); }
  }
  private DataSource dataSourceFor(String connId){ /* connId→DataSource 맵 조회 */ }
  private List&lt;Map&lt;String,Object&gt;&gt; toList(ResultSet rs) throws SQLException{ /* ResultSet→List 변환 */ }
}
</code></pre>
            </div>
          </div>
        </div>
      </div>

    </section>
  </section>
</div>


<!-- DB Tree Filter Modal -->
<div id="dbFilterBackdrop" class="export-modal-backdrop hidden" aria-hidden="true">
  <div class="export-modal small">
    <div class="export-modal-header">
      <h3>데이터베이스 필터</h3>
      <button type="button" class="dbfilter-close-btn" id="dbFilterCloseBtn" aria-label="닫기">×</button>
    </div>
    <div class="export-modal-body">
      <div class="form-row">
        <label>대상 DB</label>
        <div id="dbFilterTargetLabel" class="muted" style="padding:4px 0;"></div>
      </div>
      <div class="form-row">
        <label for="dbFilterInput">포함할 문자열</label>
        <input type="text" id="dbFilterInput" class="form-control"
               placeholder="테이블/오브젝트 이름에 포함될 문자열">
        <p class="muted" style="margin-top:4px;font-size:11px;">
          입력한 문자열이 이름에 포함된 객체만 표시됩니다. (대/소문자 구분 안 함)
        </p>
      </div>
    </div>
    <div class="export-modal-footer">
      <button type="button" class="btn" id="dbFilterCancelBtn">취소</button>
      <button type="button" class="btn primary" id="dbFilterApplyBtn">필터 적용</button>
    </div>
  </div>
</div>

<!-- Context Menu -->
<div id="ctxMenu" class="ctx-menu hidden" role="menu" aria-hidden="true">
  <ul>
    <li data-act="connect"><i class="fa-solid fa-plug"></i> 연결</li>
    <li data-act="reconnect"><i class="fa-solid fa-arrows-rotate"></i> 재접속</li>
    <li data-act="disconnect"><i class="fa-solid fa-plug-circle-xmark"></i> 연결 해제</li>
    <li data-act="sql-editor"><i class="fa-solid fa-pen-to-square"></i> SQL 에디터 열기</li>
    <li data-act="settings"><i class="fa-solid fa-gear"></i> 커넥션 설정</li>
    <li data-act="db-filter"><i class="fa-solid fa-filter"></i> 필터 적용…</li>
    <li data-act="db-filter-clear"><i class="fa-solid fa-filter-circle-xmark"></i> 필터 해제</li>
    <li data-act="conn-expand-all"><i class="fa-solid fa-angles-down"></i> 하위 모두 펼치기</li>
    <li data-act="conn-collapse-all"><i class="fa-solid fa-angles-up"></i> 하위 모두 접기</li>
    <li data-act="copy-conn"><i class="fa-solid fa-copy"></i> 복사 (Ctrl + C)</li>
        <li data-act="delete-conn"><i class="fa-solid fa-trash"></i> 삭제 (Delete)</li>
    <li data-act="rename-conn"><i class="fa-solid fa-pen"></i> 이름 변경 (F2)</li>
    <li data-act="refresh"><i class="fa-solid fa-rotate"></i> 새로고침 (Alt + R)</li>
  </ul>
</div>


<!-- Tree Object Context Menu -->
<div id="treeCtx" class="ctx-menu hidden" role="menu" aria-hidden="true">
  <ul></ul>
</div>

<!-- Editor Context Menu -->
<div id="editorCtx" class="ctx-menu hidden" role="menu" aria-hidden="true">
  <ul>
    <li data-act="runCurrent"><i class="fa-solid fa-play"></i> 실행 — 선택/현재문 (Ctrl+Enter)</li>
    <li data-act="runScript"><i class="fa-solid fa-forward"></i> 스크립트 실행 — 위→아래 (Ctrl+Shift+Enter)</li>
    <li data-act="format"><i class="fa-solid fa-wand-magic-sparkles"></i> 서식 정리 (Ctrl+Shift+F)</li>
    <li data-act="explain"><i class="fa-solid fa-magnifying-glass-chart"></i> 실행 계획 — 현재문</li>
    <li data-act="favSelection"><i class="fa-solid fa-star"></i> 선택 영역 즐겨찾기 추가</li>
  
<li data-act="code-in-list"><i class="fa-solid fa-list-ol"></i> 선택 영역을 IN (...) 리스트로 변환</li>
<li data-act="code-toggle-comment"><i class="fa-solid fa-slash"></i> 선택 영역 주석/해제 (Ctrl+/)</li>
<li data-act="code-run-selection"><i class="fa-solid fa-play"></i> 선택 부분만 실행</li>
</ul>
</div>

<!-- Tab Context Menu -->
<div id="tabCtx" class="ctx-menu hidden" role="menu" aria-hidden="true">
  <ul>
    <li data-act="tab-close"><i class="fa-solid fa-xmark"></i> 탭 닫기</li>
    <li data-act="tab-close-others"><i class="fa-solid fa-window-restore"></i> 다른 탭 닫기 (핀 제외)</li>
    <li data-act="tab-close-all"><i class="fa-solid fa-window-minimize"></i> 모든 탭 닫기 (핀 제외)</li>
    <li data-act="tab-pin-toggle"><i class="fa-solid fa-thumbtack"></i> 핀 고정</li>
    <li data-act="tab-rename"><i class="fa-solid fa-i-cursor"></i> 탭 이름 변경 (F2)</li>
    <li data-act="tab-save"><i class="fa-solid fa-floppy-disk"></i> SQL 저장</li>
  </ul>
</div>

<!-- Result Context Menu -->
<div id="resultCtx" class="ctx-menu hidden" role="menu" aria-hidden="true">
  <ul>
    <li data-act="export"><i class="fa-solid fa-file-export"></i> Excel 내보내기</li>
    <li data-act="export-insert"><i class="fa-solid fa-file-circle-plus"></i> INSERT 쿼리 내보내기</li>
    <li data-act="copy-sql"><i class="fa-solid fa-copy"></i> 쿼리 복사</li>
  </ul>
</div>

<!-- History / Recent Query Context Menu -->
<div id="historyCtx" class="ctx-menu hidden" role="menu" aria-hidden="true">
  <ul>
    <li data-act="add-favorite"><i class="fa-solid fa-star"></i> 즐겨찾기에 추가</li>
  </ul>
</div>

<!-- Favorite/Template Context Menu -->

<div id="favCtxMenu" class="ctx-menu hidden" role="menu" aria-hidden="true">
  <ul>
    <li data-act="edit"><i class="fa-solid fa-pen-to-square"></i> 수정</li>
    <li data-act="delete"><i class="fa-solid fa-trash"></i> 삭제</li>
  </ul>
</div>

<script>
let cm = null; // CodeMirror 인스턴스
const USE_DEMO = true; // false로 바꾸면 서버 호출(fetch) 경로 사용
const state = {
  connected: false,
  connId: null,
  history: [], // {ts, tsLabel, connId, connLabel, tabId, tabTitle, rowCount, elapsedMs, sql, sqlFirstLine}
  availableConns: [], // {id,label,profile}
  pinnedConnIds: [], // "자주 쓰는 연결" 핀 고정 대상 connId 목록
  connStates: {}, // { connId: boolean }
  connProfiles: {}, // { connId: 'RO'|'LIMITED'|'OPS' }
  connEnvs: {},     // { connId: 'DEV'|'PROD'|'QA'|'ETC'|'' }
  connFilters: {},  // { connId: { keyword: string } }
  tabs: [], // {id, title, connId, sql, result}}
  connAccessInfo: {}, // { connId: { reason, ticketId, activatedAt } }
  activeTabId: null,
  nextTab: 1,
  maxRows: 500,
  lastResult: {columns: [], rows: [], elapsedMs: 0, rowCount: 0},
  lastSql: '',
  currentAbortController: null,
  autoCommit: true,
  queryTimeoutMs: 15000,
  formatBreakLines: false,
  formatUpperAll: false,
  autoSaveEditor: false,
  autoSaveIntervalSec: 5
};


// ---------------- DB Tree Pin helpers ----------------
function isConnPinned(connId){
  try{
    if(!connId) return false;
    if(typeof state === 'undefined' || !state) return false;
    if(!Array.isArray(state.pinnedConnIds)) return false;
    return state.pinnedConnIds.indexOf(connId) >= 0;
  }catch(e){
    console.warn('isConnPinned error', e);
    return false;
  }
}

function setConnPinned(connId, pinned){
  try{
    if(!connId) return;
    if(typeof state === 'undefined' || !state) return;
    if(!Array.isArray(state.pinnedConnIds)){
      state.pinnedConnIds = [];
    }
    var arr = state.pinnedConnIds;
    var idx = arr.indexOf(connId);
    if(pinned){
      if(idx === -1) arr.push(connId);
    }else{
      if(idx !== -1) arr.splice(idx, 1);
    }
  }catch(e){
    console.warn('setConnPinned error', e);
  }
}

function updateConnPinUI(li, btn, connId){
  try{
    var pinned = isConnPinned(connId);
    if(btn){
      if(pinned){
        btn.classList.add('pinned');
        btn.setAttribute('title', '핀 해제');
      }else{
        btn.classList.remove('pinned');
        btn.setAttribute('title', '핀 고정');
      }
    }
    if(li){
      if(pinned){
        li.classList.add('db-pinned');
      }else{
        li.classList.remove('db-pinned');
      }
    }
  }catch(e){
    console.warn('updateConnPinUI error', e);
  }
}

function attachConnPinControl(li, connId){
  try{
    if(!li || !connId) return;
    var nodeEl = li.querySelector(':scope > .node');
    if(!nodeEl) return;
    var btn = nodeEl.querySelector('.db-pin-btn');
    if(!btn){
      btn = document.createElement('button');
      btn.type = 'button';
      btn.className = 'db-pin-btn';
      btn.innerHTML = '<i class="fa-solid fa-thumbtack"></i>';
      btn.addEventListener('click', function(e){
        try{
          e.stopPropagation();
          e.preventDefault();
          var nowPinned = !isConnPinned(connId);
          setConnPinned(connId, nowPinned);
          updateConnPinUI(li, btn, connId);
          var parentUl = li.parentElement;
          if(parentUl && typeof sortDbTreeDepth === 'function'){
            sortDbTreeDepth(parentUl);
          }
        }catch(err){
          console.warn('attachConnPinControl click error', err);
        }
      });
      nodeEl.appendChild(btn);
    }
    updateConnPinUI(li, btn, connId);
  }catch(e){
    console.warn('attachConnPinControl error', e);
  }
}

function sortDbTreeDepth(parentUl){
  try{
    if(!parentUl) return;
    var items = Array.from(parentUl.querySelectorAll(':scope > li'));
    if(!items.length) return;
    var folders = [];
    var pinned = [];
    var dbs = [];
    var others = [];
    items.forEach(function(li){
      if(!li || !li.dataset){
        others.push(li);
        return;
      }
      var kind = li.dataset.kind || '';
      var connId = li.dataset.connId || '';
      if(kind === 'folder'){
        folders.push(li);
      }else if(connId){
        if(isConnPinned(connId)){
          pinned.push(li);
        }else{
          dbs.push(li);
        }
      }else{
        others.push(li);
      }
    });
    if(!folders.length && !pinned.length && !dbs.length){
      return;
    }
    items.forEach(function(li){
      parentUl.removeChild(li);
    });
    folders.concat(pinned, dbs, others).forEach(function(li){
      parentUl.appendChild(li);
    });
  }catch(e){
    console.warn('sortDbTreeDepth error', e);
  }
}

// ---------------- Tab underline helpers (connection state) ----------------
function resetTabUnderlineForConn(connId){
  try{
    if(typeof state === 'undefined' || !state || !Array.isArray(state.tabs)) return;
    var activeConnIds = Object.keys(state.connStates || {}).filter(function(id){
      return !!state.connStates[id];
    });
    state.tabs.forEach(function(t){
      if(!t) return;
      if(connId){
        // 특정 DB 연결이 끊어진 경우: 그 DB에 매핑된 탭만 기본색으로
        if(t.connId === connId){
          t.color = 'default';
        }
      }else{
        // connId 미지정: 모든 탭의 밑줄을 기본색으로 초기화
        t.color = 'default';
      }
    });
  }catch(e){
    console.warn('resetTabUnderlineForConn error', e);
  }
}


// 환경 값이 비어 있을 때 라벨에서 DEV/QA/PROD를 추론하는 헬퍼
function detectEnvFromLabel(label){
  try{
    if(!label) return '';
    var s = label.toString().toLowerCase();
    // 운영 / PROD / OPS
    if(s.indexOf('운영') >= 0 || s.indexOf('prod') >= 0 || s.indexOf('prd') >= 0 || s.indexOf(' ops') >= 0 || s.indexOf('(ops') >= 0){
      return 'PROD';
    }
    // QA / 검증 / 스테이징
    if(s.indexOf('qa') >= 0 || s.indexOf('검증') >= 0 || s.indexOf('staging') >= 0){
      return 'QA';
    }
    // DEV / 개발 / 테스트
    if(s.indexOf('dev') >= 0 || s.indexOf('develop') >= 0 || s.indexOf('개발') >= 0 || s.indexOf('test') >= 0 || s.indexOf('테스트') >= 0){
      return 'DEV';
    }
  }catch(e){
    console.warn('detectEnvFromLabel error', e);
  }
  return '';
}

function applyTabUnderlineForConn(connId){
  try{
    if(typeof state === 'undefined' || !state || !Array.isArray(state.tabs)) return;
    if(!connId) return;

    // 환경 값 조회: state.connEnvs > availableConns.env > 트리 data-env
    var env = '';
    try{
      if(state.connEnvs && Object.prototype.hasOwnProperty.call(state.connEnvs, connId)){
        env = state.connEnvs[connId] || '';
      }else{
        var conns = state.availableConns || [];
        for(var i=0;i<conns.length;i++){
          var c = conns[i];
          if(c && c.id === connId){
            if(typeof c.env !== 'undefined' && c.env !== null){
              env = c.env;
            }
            break;
          }
        }
        if(!env && typeof tree !== 'undefined' && tree && typeof tree.getConnLi === 'function'){
          var li = tree.getConnLi(connId);
          if(li && li.dataset && li.dataset.env){
            env = li.dataset.env;
          }
        }
      }
      // env가 여전히 비어 있으면 라벨에서 DEV/QA/PROD 추론
      if(!env){
        var labelGuess = '';
        try{
          var ac = state.availableConns || [];
          for(var j=0;j<ac.length;j++){
            var cc = ac[j];
            if(cc && cc.id === connId){
              labelGuess = cc.label || cc.name || cc.title || '';
              break;
            }
          }
          if(!labelGuess && typeof tree !== 'undefined' && tree && typeof tree.getConnLi === 'function'){
            var li2 = tree.getConnLi(connId);
            if(li2){
              labelGuess = (li2.dataset && (li2.dataset.label || li2.dataset.name)) || li2.textContent || '';
            }
          }
        }catch(le){
          console.warn('applyTabUnderlineForConn env label detect error', le);
        }
        if(labelGuess && typeof detectEnvFromLabel === 'function'){
          var inferred = detectEnvFromLabel(labelGuess);
          if(inferred){
            env = inferred;
            if(state.connEnvs){
              state.connEnvs[connId] = inferred;
            }
          }
        }
      }
    }catch(e){
      console.warn('applyTabUnderlineForConn env detect error', e);
    }

    var key = (env || '').toString().trim().toUpperCase();
    var color = 'default';
    if(!key){
      color = 'default';
    }else if(key === 'PROD' || key === 'PRD' || key === 'OPS' || key === 'OP'){
      color = 'red';      // 운영
    }else if(key === 'DEV' || key === 'DEVELOP' || key === 'DEVELOPMENT'){
      color = 'green';    // 개발
    }else if(key === 'QA' || key === 'STG' || key === 'STAGE' || key === 'STAGING' || key === 'TEST' || key === 'UAT'){
      color = 'blue';     // QA/테스트
    }else{
      color = 'yellow';   // 기타
    }

    state.tabs.forEach(function(t){
      if(!t) return;
      if(t.connId === connId){
        t.color = color;
      }
    });
  }catch(e){
    console.warn('applyTabUnderlineForConn error', e);
  }
}


function updateEnvBannerForConn(connId){
  try{
    var banner = document.getElementById('envBanner');
    if(!banner) return;

    // 기본: 배너 숨김 + 클래스 초기화
    banner.classList.add('env-banner--hidden');
    banner.classList.remove('env-banner--prod');
    banner.classList.remove('env-banner--dev');
    banner.classList.remove('env-banner--qa');

    // 에디터 영역 환경 클래스 초기화
    var body = document.body || null;
    if(body){
      body.classList.remove('env-prod');
      body.classList.remove('env-dev');
      body.classList.remove('env-qa');
    }

    var titleEl = document.getElementById('envBannerTitle');
    var metaEl  = document.getElementById('envBannerMeta');
    var descEl  = document.getElementById('envBannerDesc');

    if(!connId){
      return;
    }

    // 환경 값 조회: state.connEnvs > availableConns.env > 트리 data-env
    var env = '';
    try{
      if(typeof state !== 'undefined' && state){
        if(state.connEnvs && Object.prototype.hasOwnProperty.call(state.connEnvs, connId)){
          env = state.connEnvs[connId] || '';
        }else if(Array.isArray(state.availableConns)){
          var conns = state.availableConns || [];
          for(var i=0;i<conns.length;i++){
            var c = conns[i];
            if(c && c.id === connId){
              if(typeof c.env !== 'undefined' && c.env !== null){
                env = c.env;
              }
              break;
            }
          }
        }
        if(!env && typeof tree !== 'undefined' && tree && typeof tree.getConnLi === 'function'){
          var li = tree.getConnLi(connId);
          if(li && li.dataset && li.dataset.env){
            env = li.dataset.env;
          }
        }
        // env가 여전히 비어 있을 경우 라벨에서 DEV/QA/PROD 추론
        if(!env){
          var labelGuess = '';
          try{
            var ac = state.availableConns || [];
            for(var j=0;j<ac.length;j++){
              var cc = ac[j];
              if(cc && cc.id === connId){
                labelGuess = cc.label || cc.name || cc.title || '';
                break;
              }
            }
            if(!labelGuess && typeof tree !== 'undefined' && tree && typeof tree.getConnLi === 'function'){
              var li2 = tree.getConnLi(connId);
              if(li2){
                labelGuess = (li2.dataset && (li2.dataset.label || li2.dataset.name)) || li2.textContent || '';
              }
            }
          }catch(le){
            console.warn('updateEnvBannerForConn env label detect error', le);
          }
          if(labelGuess && typeof detectEnvFromLabel === 'function'){
            var inferred = detectEnvFromLabel(labelGuess);
            if(inferred){
              env = inferred;
              if(state.connEnvs){
                state.connEnvs[connId] = inferred;
              }
            }
          }
        }
      }
    }catch(e){
      console.warn('updateEnvBannerForConn env detect error', e);
    }

    var key = (env || '').toString().trim().toUpperCase();

    // DEV / QA / PROD 모두 배너 표시 (문구·색상만 다름)
    var titleText = '';
    var metaText  = '';
    var descText  = '';
    var cls       = '';

    if(key === 'PROD' || key === 'PRD' || key === 'OPS' || key === 'OP'){
      titleText = '운영 DB에 접속 중입니다.';
      metaText  = 'PROD · 고위험 환경';
      descText  = '운영 DB에서의 쿼리 실행 및 다운로드에는 강화된 통제·승인 정책이 적용됩니다.';
      cls       = 'env-banner--prod';
    }else if(key === 'QA'){
      titleText = 'QA DB에 접속 중입니다.';
      metaText  = 'QA · 검증 환경';
      descText  = 'QA 환경에서의 실행 결과는 검증용이며, 운영 반영 전 테스트에 사용됩니다.';
      cls       = 'env-banner--qa';
    }else if(key === 'DEV'){
      titleText = '개발 DB에 접속 중입니다.';
      metaText  = 'DEV · 개발 환경';
      descText  = '개발/테스트 전용 DB이며, 실제 고객정보가 아닐 수 있습니다.';
      cls       = 'env-banner--dev';
    }

    if(cls){
      if(titleEl){ titleEl.textContent = titleText; }
      if(metaEl){  metaEl.textContent  = metaText; }
      if(descEl){  descEl.textContent  = descText; }
      banner.classList.remove('env-banner--hidden');
      banner.classList.add(cls);

      // 에디터 영역 색상을 위한 body 클래스 적용
      if(body){
        if(key === 'PROD' || key === 'PRD' || key === 'OPS' || key === 'OP'){
          body.classList.add('env-prod');
        }else if(key === 'QA'){
          body.classList.add('env-qa');
        }else if(key === 'DEV'){
          body.classList.add('env-dev');
        }
      }
    }
  }catch(e){
    console.warn('updateEnvBannerForConn error', e);
  }
}

// 탭 제목에 DB 라벨을 붙이는 헬퍼 (＜라벨＞ SQL N 형태)

// 탭 제목에서 접두사(＜...＞)를 제거하고 '코어' 제목만 반환
function getTabCoreTitle(title){
  try{
    if(!title) return '';
    var t = String(title).trim();
    // 앞쪽에 '<...>' 또는 '＜...＞' 형태의 접두사가 있으면 제거하고 나머지를 코어 제목으로 사용
    var m = t.match(/^[<＜]\s*([^>＞]+)\s*[>＞]\s*(.*)$/);
    if(m){
      // m[1] = 라벨, m[2] = 코어
      return (m[2] || '').trim() || (m[1] || '').trim();
    }
    return t;
  }catch(e){
    console.warn('getTabCoreTitle error', e);
    return title || '';
  }
}


// 탭 제목에 DB 라벨을 붙이는 헬퍼: 내부 title은 코어만 유지하고,
// 화면에 보일 때만 '＜라벨＞ 코어제목' 형태로 사용한다.
function applyConnLabelToTabTitle(tab, connId){
  try{
    if(!tab || !connId) return (tab && (tab.title || tab.id || '')) || '';
    var baseTitle = tab.title || tab.id || '';
    baseTitle = getTabCoreTitle(baseTitle);
    var label = '';
    try{
      var conns = state && state.availableConns ? state.availableConns : [];
      for(var i=0;i<conns.length;i++){
        var c = conns[i];
        if(c && c.id === connId){
          label = c.label || c.id || '';
          break;
        }
      }
      if(!label && typeof tree !== 'undefined' && tree && typeof tree.getConnLi === 'function'){
        var li = tree.getConnLi(connId);
        if(li){
          if(li.dataset && li.dataset.label){
            label = li.dataset.label;
          }else if(li.textContent){
            label = li.textContent.trim();
          }
        }
      }
    }catch(e){
      console.warn('applyConnLabelToTabTitle label detect error', e);
    }
    if(!label) return baseTitle;
    return '＜' + label + '＞ ' + (baseTitle || '');
  }catch(e){
    console.warn('applyConnLabelToTabTitle error', e);
    return (tab && (tab.title || tab.id || '')) || '';
  }
}



const DBAM_AUTO_SAVE_KEY = 'dbam_editor_session_v1';

function initAutoSaveTimer(){
  try{
    if (!window.localStorage) return;
    // 기존 타이머 정리
    if (window._dbamAutoSaveTimer) {
      clearInterval(window._dbamAutoSaveTimer);
      window._dbamAutoSaveTimer = null;
    }
    if (!state.autoSaveEditor) return;
    const sec = state.autoSaveIntervalSec || 5;
    const interval = Math.max(3000, sec * 1000);
    window._dbamAutoSaveTimer = setInterval(()=>{
      try{
        if (ui && typeof ui.autoSaveSession === 'function') {
          ui.autoSaveSession();
        }
      }catch(e){
        console.warn('autoSaveSession interval error', e);
      }
    }, interval);
  }catch(e){
    console.warn('initAutoSaveTimer error', e);
  }
}

// 브라우저 종료/새로고침 직전에 한 번 더 시도
window.addEventListener('beforeunload', function(){
  try{
    if (ui && typeof ui.autoSaveSession === 'function') {
      ui.autoSaveSession();
    }
  }catch(e){}
});

const dbamHint = {
  tables: {},
  updateTablesFromTreeData(data){
    const map = {};
    try{
      if (data && Array.isArray(data.connections)) {
        data.connections.forEach(conn => {
          (conn.schemas || []).forEach(sc => {
            (sc.tables || []).forEach(tname => {
              const shortName = tname;
              if (!map[shortName]) {
                map[shortName] = [];
              }
            });
          });
        });
      }
    }catch(e){
      console.warn('dbamHint.updateTablesFromTreeData error', e);
    }
    this.tables = map;
    window.dbamSqlTables = map;
  },
  addColumnsForTable(schema, table, columns){
    try{
      const shortName = table;
      if (!window.dbamSqlTables) {
        window.dbamSqlTables = {};
      }
      if (!window.dbamSqlTables[shortName]) {
        window.dbamSqlTables[shortName] = [];
      }
      (columns || []).forEach(c => {
        if (window.dbamSqlTables[shortName].indexOf(c) === -1) {
          window.dbamSqlTables[shortName].push(c);
        }
      });
    }catch(e){
      console.warn('dbamHint.addColumnsForTable error', e);
    }
  }
};

function dbamSmartSqlHint(cm, options){
  if (!window.CodeMirror) return;

  // 활성 탭에 연결된 데이터베이스가 없으면 자동완성 비활성화
  try{
    if (typeof state !== 'undefined') {
      const activeTab = (state.tabs || []).find(t => t.id === state.activeTabId);
      const connId = activeTab && activeTab.connId;
      const on = connId && state.connStates && state.connStates[connId];
      if (!on) {
        return;
      }
    }
  }catch(e){
    if (window.console && console.warn) {
      console.warn('dbamSmartSqlHint conn guard error', e);
    }
  }

  const cursor = cm.getCursor();
  const docText = cm.getValue();
  const cursorIdx = cm.indexFromPos(cursor);

  // 기본 테이블 및 별칭 맵 추출
  let defaultTable = null;
  const aliasMap = {};
  if (window.dbamSqlTables && Object.keys(window.dbamSqlTables).length) {
    // 1) 커서 이전(before)에서 FROM / JOIN 스캔
    const before = docText.slice(0, cursorIdx);
    const re = /\b(from|join)\s+([a-zA-Z_][\w$]*(?:\.[a-zA-Z_][\w$]*)?)(?:\s+(?:as\s+)?([a-zA-Z_][\w$]*))?/ig;
    let m;
    while ((m = re.exec(before)) !== null) {
      let rawTable = m[2];
      const dotIdx = rawTable.lastIndexOf('.');
      if (dotIdx !== -1) {
        rawTable = rawTable.substring(dotIdx + 1);
      }
      const tableName = rawTable;
      defaultTable = tableName;
      const alias = m[3];
      if (alias) {
        aliasMap[alias.toLowerCase()] = tableName;
      }
      aliasMap[tableName.toLowerCase()] = tableName;
    }

    // 2) 커서 이전에 FROM/JOIN이 없으면, 커서 이후(after)에서 첫 FROM/JOIN만 검색
    if (!defaultTable) {
      const after = docText.slice(cursorIdx);
      const re2 = /\b(from|join)\s+([a-zA-Z_][\w$]*(?:\.[a-zA-Z_][\w$]*)?)/i;
      const m2 = re2.exec(after);
      if (m2 && m2[2]) {
        let rawTable2 = m2[2];
        const dotIdx2 = rawTable2.lastIndexOf('.');
        if (dotIdx2 !== -1) {
          rawTable2 = rawTable2.substring(dotIdx2 + 1);
        }
        const tableName2 = rawTable2;
        defaultTable = tableName2;
        aliasMap[tableName2.toLowerCase()] = tableName2;
      }
    }
  }

  // 현재 라인의 커서 앞 텍스트로 alias / 컬럼 prefix 추출
  const lineText = cm.getLine(cursor.line) || "";
  const beforeCursor = lineText.slice(0, cursor.ch);

  let aliasPart = null;
  let colPrefix = "";
  const aliasMatch = /([a-zA-Z_][\w$]*)\.\s*([a-zA-Z_0-9$]*)$/.exec(beforeCursor);
  if (aliasMatch) {
    aliasPart = aliasMatch[1];
    colPrefix = aliasMatch[2] || "";
  } else {
    const colMatch = /([a-zA-Z_][\w$]*)$/.exec(beforeCursor);
    if (colMatch) {
      colPrefix = colMatch[1];
    }
  }

  // 1) alias.컬럼 패턴인 경우: FROM/JOIN에 정의된 alias만 허용
  if (aliasPart) {
    const key = aliasPart.toLowerCase();
    const tableName = aliasMap[key];

    // FROM/JOIN에 없는 alias면 컬럼 자동완성 차단
    if (!tableName || !window.dbamSqlTables || !window.dbamSqlTables[tableName]) {
      return { list: [], from: cursor, to: cursor };
    }

    const cols = window.dbamSqlTables[tableName] || [];
    const lowerPrefix = (colPrefix || "").toLowerCase();
    const list = cols.filter(c => !colPrefix || c.toLowerCase().startsWith(lowerPrefix));

    if (!list.length) {
      return { list: [], from: cursor, to: cursor };
    }

    const fromCh = cursor.ch - (colPrefix || "").length;
    return {
      list: list,
      from: CodeMirror.Pos(cursor.line, fromCh),
      to: CodeMirror.Pos(cursor.line, cursor.ch)
    };
  }

  // 2) alias가 없고 defaultTable이 있는 경우: 기본 테이블 컬럼 자동완성 (SELECT/WHERE 등)
  if (defaultTable && window.dbamSqlTables && window.dbamSqlTables[defaultTable]) {
    const cols = window.dbamSqlTables[defaultTable] || [];
    const token = cm.getTokenAt(cursor);
    const tokenStr = token && typeof token.string === "string" ? token.string : "";
    const tokenType = token && token.type ? token.type : "";

    // 키워드 토큰에는 개입하지 않고, 식별자일 때만 개입
    if (tokenType !== "keyword" && /[\w$]/.test(tokenStr)) {
      let startCh = token.start;
      let prefix = "";
      const rel = cursor.ch - startCh;
      if (rel >= 0) {
        const sub = tokenStr.slice(0, rel);
        const mWord = /([a-zA-Z_0-9$]+)$/.exec(sub);
        if (mWord) {
          prefix = mWord[1];
          startCh = cursor.ch - prefix.length;
        } else {
          startCh = cursor.ch;
        }
      } else {
        startCh = cursor.ch;
      }

      const lowerPrefix = prefix.toLowerCase();
      const list = cols.filter(c => !prefix || c.toLowerCase().startsWith(lowerPrefix));

      if (list.length) {
        return {
          list: list,
          from: CodeMirror.Pos(cursor.line, startCh),
          to: CodeMirror.Pos(cursor.line, cursor.ch)
        };
      }
    }
  }

  // 3) 나머지는 CodeMirror 기본 SQL 힌트로 위임
  if (!CodeMirror.hint || !CodeMirror.hint.sql) return;

  options = options || {};
  options.completeSingle = false;
  if (window.dbamSqlTables && Object.keys(window.dbamSqlTables).length) {
    options.tables = window.dbamSqlTables;
  }

  const inner = CodeMirror.hint.sql(cm, options) || {};
  if (!inner.list || !Array.isArray(inner.list)) {
    return inner;
  }

  // table.column 형식의 항목은 display에는 컬럼명만 보이게 정리
  inner.list = inner.list.map(item => {
    if (typeof item === "string") {
      const idx = item.lastIndexOf(".");
      return idx >= 0 ? item.substring(idx + 1) : item;
    }
    const copy = Object.assign({}, item);
    if (typeof copy.text === "string") {
      const idx = copy.text.lastIndexOf(".");
      if (idx >= 0) {
        const short = copy.text.substring(idx + 1);
        copy.text = short;
        if (!copy.displayText) {
          copy.displayText = short;
        }
      }
    }
    return copy;
  });

  return inner;
};
/* ---------------- Helper: DB label & history time ---------------- */
function getConnLabel(connId){
  if(!connId) return '';
  const conns = state.availableConns || [];
  for(const c of conns){
    if(c.id === connId){
      return c.label || c.id;
    }
  }
  return connId;
}
function formatHistoryTime(d){
  try{
    const pad = (n)=> String(n).padStart(2,'0');
    const yy = String(d.getFullYear()).slice(2);
    return `${yy}-${pad(d.getMonth()+1)}-${pad(d.getDate())} ${pad(d.getHours())}:${pad(d.getMinutes())}:${pad(d.getSeconds())}`;
  }catch(e){
    return '';
  }
}

/* ---------------- UI: Tabs, Editor, Resizers, Theme/Keymap, Server Panel ---------------- */
const ui = {
  favSaveMode: 'new',
  favSaveEditType: null,
  favSaveEditId: null,

  init(){
    // CodeMirror 활성화 (라이트 테마 기본)
    try{
      cm = CodeMirror.fromTextArea(document.getElementById('sqlEditor'), {
        mode: 'text/x-sql',
        lineNumbers: true,
        matchBrackets: true,
        indentWithTabs: true,
        smartIndent: true,
        theme: 'default',
        extraKeys: {
          'Ctrl-Space': function(cmInstance){
            if (window.CodeMirror && CodeMirror.hint && CodeMirror.hint.sql) {
              const options = { completeSingle: false };
              if (window.dbamSqlTables && Object.keys(window.dbamSqlTables).length) {
                options.tables = window.dbamSqlTables;
              }
              CodeMirror.showHint(cmInstance, dbamSmartSqlHint, options);
            }
          }
        }
      });
            // SQL 기본 함수 및 JOIN 관련 키워드 강조 오버레이
      if (cm && typeof cm.addOverlay === 'function') {
        const sqlHighlightOverlay = {
          token: function(stream, state){
            // JOIN 계열 키워드 (LEFT/RIGHT/INNER/OUTER/FULL/CROSS/NATURAL + JOIN)
            if (stream.match(/(LEFT|RIGHT|INNER|OUTER|FULL|CROSS|NATURAL)\b(?=\s+JOIN\b)/i)) {
              return 'keyword';
            }
            // JOIN 자체
            if (stream.match(/JOIN\b/i)) {
              return 'keyword';
            }
            // 집계 함수 등 기본 함수(MAX, MIN, SUM, AVG, COUNT) 강조
            if (stream.match(/(MAX|MIN|SUM|AVG|COUNT)\b(?!\s*\.)/i)) {
              return 'sql-builtin-func';
            }
            // 위 패턴이 다시 나올 때까지 스킵
            while (stream.next() != null &&
                   !stream.match(/(LEFT|RIGHT|INNER|OUTER|FULL|CROSS|NATURAL)\b(?=\s+JOIN\b)/i, false) &&
                   !stream.match(/JOIN\b/i, false) &&
                   !stream.match(/(MAX|MIN|SUM|AVG|COUNT)\b(?!\s*\.)/i, false)) {}
            return null;
          }
        };
        cm.addOverlay(sqlHighlightOverlay);
      }
      cm.setSize(null, 320);
      cm.on('change', (editor, change)=>{
        if(!state.activeTabId) return;
        const tab = state.tabs.find(t=>t.id===state.activeTabId);
        if(tab){
          tab.sql = editor.getValue();
        }
        // 에디터 변경 시 자동 임시저장 (디바운스)
        if (state.autoSaveEditor && window.localStorage && typeof ui._scheduleAutoSave === 'function') {
          ui._scheduleAutoSave();
        }
      });
      cm.on('keydown', (editor, e)=>{
        if(e.ctrlKey && e.key==='Enter' && !e.shiftKey){
          e.preventDefault();
          e.stopPropagation();
          actions.runCurrent();
        }
        if(e.ctrlKey && e.shiftKey && e.key==='Enter'){
          e.preventDefault();
          e.stopPropagation();
          actions.runScript();
        }
        if(e.ctrlKey && e.shiftKey && e.key && e.key.toLowerCase()==='f'){
          e.preventDefault();
          ui.formatSql();
        }
        if(e.ctrlKey && !e.shiftKey && !e.altKey && (e.key === '.' || e.code === 'Period')){
          try{
            if(typeof codeActions !== 'undefined' && codeActions && typeof codeActions.openMenu === 'function'){
              e.preventDefault();
              e.stopPropagation();
              codeActions.openMenu(editor);
            }else if(typeof codeActions !== 'undefined' && codeActions && typeof codeActions.toInList === 'function'){
              e.preventDefault();
              e.stopPropagation();
              codeActions.toInList();
            }
          }catch(err){
            console.warn('codeActions keydown error', err);
          }
        }

        if(e.ctrlKey && !e.shiftKey && !e.altKey && (e.key === '/' || e.code === 'Slash')){
          try{
            if(typeof codeActions !== 'undefined' && codeActions && typeof codeActions.toggleComment === 'function'){
              e.preventDefault();
              e.stopPropagation();
              codeActions.toggleComment();
            }
          }catch(err){
            console.warn('codeActions toggleComment keydown error', err);
          }
        }
        // 스니펫: sel / sel1 / upd / ins / del + Tab
        if(!e.ctrlKey && !e.altKey && e.key === 'Tab'){
          try{
            const pos = editor.getCursor();
            let handled = false;

            // 4글자 패턴 우선: sel1
            if(pos.ch >= 4){
              const from4 = { line: pos.line, ch: pos.ch - 4 };
              const to4   = { line: pos.line, ch: pos.ch };
              const word4 = editor.getRange(from4, to4);
              const w4 = word4 && word4.toLowerCase();
              if(w4 === 'sel1'){
                e.preventDefault();
                e.stopPropagation();
                const snippet = 'SELECT 1 FROM  WHERE ;';
                editor.replaceRange(snippet, from4, to4);
                const cursorCh = from4.ch + 'SELECT 1 FROM '.length;
                editor.setCursor({ line: pos.line, ch: cursorCh });
                handled = true;
              }
            }

            // 3글자 패턴: sel / upd / ins / del
            if(!handled && pos.ch >= 3){
              const from3 = { line: pos.line, ch: pos.ch - 3 };
              const to3   = { line: pos.line, ch: pos.ch };
              const word3 = editor.getRange(from3, to3);
              const w3 = word3 && word3.toLowerCase();

              let snippet = null;
              let cursorOffset = null;

              if(w3 === 'sel'){
                snippet = 'SELECT * FROM  WHERE ;';
                cursorOffset = 'SELECT * FROM '.length;
              }else if(w3 === 'upd'){
                snippet = 'UPDATE  SET  WHERE ;';
                cursorOffset = 'UPDATE '.length;
              }else if(w3 === 'ins'){
                snippet = 'INSERT INTO  () VALUES ();';
                cursorOffset = 'INSERT INTO '.length;
              }else if(w3 === 'del'){
                snippet = 'DELETE FROM  WHERE ;';
                cursorOffset = 'DELETE FROM '.length;
              }

              if(snippet){
                e.preventDefault();
                e.stopPropagation();
                editor.replaceRange(snippet, from3, to3);
                const cursorCh = from3.ch + cursorOffset;
                editor.setCursor({ line: pos.line, ch: cursorCh });
                handled = true;
              }
            }

            if(handled){
              return;
            }
          }catch(err){
            console.warn('snippet Tab error', err);
          }
        }
      });
      // 자동완성: 입력 시 간단 팝업 (SQL 키워드 + 트리에서 가져온 테이블/컬럼)
      cm.on('inputRead', (editor, change) => {
        if (change.origin !== '+input') return;
        const ch = change.text && change.text[0] ? change.text[0] : '';
        if (!ch || !/[\w.]/.test(ch)) return;

        if (window.CodeMirror && CodeMirror.hint && CodeMirror.hint.sql) {
          const options = { completeSingle: false };
          if (window.dbamSqlTables && Object.keys(window.dbamSqlTables).length) {
            options.tables = window.dbamSqlTables;
          }
          CodeMirror.showHint(editor, dbamSmartSqlHint, options);
        }
      });
    
      // 에디터 우클릭 컨텍스트 메뉴 바인딩
      editorCtx.bind(cm.getWrapperElement());
    }catch(err){
      console.warn('CodeMirror 미적용, 기본 textarea 사용');
      editorCtx.bind(document.getElementById('sqlEditor'));
    }

    this.restoreSizes();
    if (!(typeof this.restoreSessionFromAutoSave === 'function' && this.restoreSessionFromAutoSave())) {
      this.newEditorTab();
    }
    document.addEventListener('keydown', (e)=>{
      if(e.ctrlKey && e.key === 'Enter' && !e.shiftKey){ e.preventDefault(); actions.runCurrent(); }
      if(e.ctrlKey && e.shiftKey && e.key === 'Enter'){ e.preventDefault(); actions.runScript(); }

      // ESC 공통 처리
      if(e.key === 'Escape'){
        ctxMenu.hide();
        editorCtx.hide();

        const sh = document.getElementById('shortcutHelpBackdrop');
        if (sh && sh.classList.contains('show')) {
          this.closeShortcutHelpModal();
        }
        const fb = document.getElementById('favSaveBackdrop');
        if (fb && fb.classList.contains('show')) {
          this.closeFavSaveModal();
        }
      }

      // F2 : 포커싱된 영역에 따라 이름 변경
      const isF2 = (e.key === 'F2' || e.code === 'F2' || e.keyCode === 113 || e.which === 113);
      if(isF2 && !e.ctrlKey && !e.altKey && !e.shiftKey){
        const activeEl = document.activeElement;

        // DB 트리 관련 컨텍스트가 있으면 탭 이름 변경은 절대 수행하지 않는다.
        let hasDbTreeContext = false;

        // 1) 포커스가 DB 트리 안에 있는 경우
        try{
          const dbTree = document.getElementById('dbTree');
          if (dbTree && activeEl && dbTree.contains(activeEl)) {
            hasDbTreeContext = true;
          }
        }catch(err){
          console.warn('global F2 dbTree focus check error', err);
        }

        // 2) dbFolderUi 선택 정보
        if (!hasDbTreeContext) {
          try{
            if (typeof dbFolderUi !== 'undefined' &&
                dbFolderUi &&
                typeof dbFolderUi.getSelectionInfo === 'function') {
              const selInfo = dbFolderUi.getSelectionInfo();
              if (selInfo && selInfo.li) {
                hasDbTreeContext = true;
              }
            }
          }catch(err){
            console.warn('global F2 dbTree selection check error', err);
          }
        }

        // 3) .dbtree-selected 노드가 있는 경우
        if (!hasDbTreeContext && typeof document !== 'undefined') {
          const selNode = document.querySelector('#dbTree .node.dbtree-selected');
          if (selNode) {
            hasDbTreeContext = true;
          }
        }

        // 4) 이름 변경 인풋(.dbtree-folder-edit)이 떠 있는 경우
        if (!hasDbTreeContext && typeof document !== 'undefined') {
          const editInput = document.querySelector('#dbTree .dbtree-folder-edit');
          if (editInput) {
            hasDbTreeContext = true;
          }
        }

        if (hasDbTreeContext) {
          // DB 트리 전용 F2 핸들러에서 이름 변경을 처리하도록 두고,
          // 여기서는 탭 이름 변경을 수행하지 않는다.
          return;
        }

        // 2) 탭 영역 (또는 에디터 등) → 현재 활성 탭 이름 변경
        const tabsEl = document.getElementById('tabs');
        // 탭 컨텍스트 메뉴와 동일하게 ui.startTabInlineRename 경로를 사용한다.
        if (tabsEl && typeof ui !== 'undefined' && typeof ui.startTabInlineRename === 'function') {
          let targetTab = null;

          // 2-1) 현재 포커스가 탭 안에 있는 경우: 그 탭 기준
          if (activeEl && activeEl.closest) {
            const byFocus = activeEl.closest('#tabs .tab');
            if (byFocus) {
              targetTab = byFocus;
            }
          }

          // 2-2) 포커스로 찾은 탭이 없으면 .tab.active 사용
          if (!targetTab) {
            targetTab = tabsEl.querySelector('.tab.active');
          }

          if (targetTab) {
            const tabId = targetTab.dataset && targetTab.dataset.tabId;
            if (tabId) {
              e.preventDefault();
              try{
                ui.startTabInlineRename(tabId);
              }catch(err){
                console.warn('F2 tab rename error', err);
              }
              return;
            }
          }
        }
      }
    }, true);
    this.bindResizers();
    resetTabUnderlineForConn(null);
    this.renderTabs();
    this.refreshConnStatus();
    this.refreshTxnUi();
  },
  setTheme(name){ if(cm){ cm.setOption('theme', name==='default'?'default':name); } },
  setKeymap(k){ if(cm){ cm.setOption('keyMap', 'default'); } },
  refreshTxnUi(){
    const auto = !!state.autoCommit;
    const autoBtn = document.getElementById('btnAutoCommit');
    const icon = document.getElementById('autoCommitIcon');
    const label = document.getElementById('autoCommitLabel');
    const commitBtn = document.getElementById('btnCommit');
    const rollbackBtn = document.getElementById('btnRollback');
    const timeoutLabel = document.getElementById('queryTimeoutLabel');
    if(label){ label.textContent = auto ? 'ON' : 'OFF'; }
    if(icon){
      icon.classList.remove('fa-toggle-on','fa-toggle-off');
      icon.classList.add(auto ? 'fa-toggle-on' : 'fa-toggle-off');
    }
    if(autoBtn){
      autoBtn.title = auto ? '현재 Auto-commit 모드입니다.' : '현재 수동 Commit 모드입니다.';
    }
    if(commitBtn){ commitBtn.disabled = auto; }
    if(rollbackBtn){ rollbackBtn.disabled = auto; }
    if(timeoutLabel){
      const v = state.queryTimeoutMs || 15000;
      try{
        timeoutLabel.textContent = v.toLocaleString();
      }catch(e){
        timeoutLabel.textContent = String(v);
      }
    }
  },
  toggleAutoCommit(){
    state.autoCommit = !state.autoCommit;
    this.refreshTxnUi();
  },
  setQueryTimeoutMs(ms){
    const n = parseInt(ms, 10);
    if(!isFinite(n) || n <= 0){
      alert('타임아웃은 1 이상 숫자(ms)로 입력하세요.');
      return;
    }
    state.queryTimeoutMs = n;
    this.refreshTxnUi();
  },
  toggleServerPanel(){
    if(bottomTabs){
      bottomTabs.toggle('serverPanel');
    }
  },


  openPersonalSqlSave(){
    const el = document.getElementById('personalSqlSaveBackdrop');
    if(!el){ alert('개인 SQL 저장 UI 요소를 찾지 못했습니다.'); return; }
    const tab = state.tabs.find(t=>t.id===state.activeTabId) || null;
    const titleInput = document.getElementById('psSaveTitle');
    const infoSpan = document.getElementById('psSaveInfo');
    const preview = document.getElementById('psSavePreview');
    if(titleInput){
      titleInput.value = tab && tab.title ? tab.title : '';
    }
    if(infoSpan){
      infoSpan.textContent = tab ? (tab.title || tab.id) : '(활성 탭 없음)';
    }
    if(preview){
      try{
        const sql = cm ? cm.getValue() : (document.getElementById('sqlEditor') ? document.getElementById('sqlEditor').value : '');
        preview.textContent = sql ? sql.slice(0, 800) : '';
      }catch(e){
        preview.textContent = '';
      }
    }
    el.classList.remove('hidden');
    el.classList.add('show');
    el.setAttribute('aria-hidden','false');
  },
  closePersonalSqlSave(){
    const el = document.getElementById('personalSqlSaveBackdrop');
    if(!el) return;
    el.classList.remove('show');
    el.classList.add('hidden');
    el.setAttribute('aria-hidden','true');
  },
  confirmPersonalSqlSave(){
    const sql = cm ? cm.getValue() : (document.getElementById('sqlEditor') ? document.getElementById('sqlEditor').value : '');
    if(!sql || !sql.trim()){
      alert('저장할 SQL이 없습니다.');
      return;
    }
    const name = document.getElementById('psSaveTitle') ? document.getElementById('psSaveTitle').value : '';
    const desc = document.getElementById('psSaveDesc') ? document.getElementById('psSaveDesc').value : '';
    // TODO: 서버 API 연동 시 name/desc/sql을 전송하는 로직을 추가
    alert('서버 개인 저장소 연동 전이라 실제 저장은 수행하지 않습니다.\nUI 흐름만 먼저 구현된 상태입니다.');
    this.closePersonalSqlSave();
  },
  openPersonalSqlLoad(){
    const el = document.getElementById('personalSqlLoadBackdrop');
    if(!el){ alert('개인 SQL 불러오기 UI 요소를 찾지 못했습니다.'); return; }
    el.classList.remove('hidden');
    el.classList.add('show');
    el.setAttribute('aria-hidden','false');
  },
  closePersonalSqlLoad(){
    const el = document.getElementById('personalSqlLoadBackdrop');
    if(!el) return;
    el.classList.remove('show');
    el.classList.add('hidden');
    el.setAttribute('aria-hidden','true');
  },
  applyPersonalSqlLoad(){
    // TODO: 서버에서 선택된 SQL 내용을 받아와 에디터에 반영하는 로직을 추가
    alert('서버 개인 저장소 연동 전이라 실제 불러오기는 수행하지 않습니다.\n목록/선택 UI만 먼저 구현된 상태입니다.');
    this.closePersonalSqlLoad();
  },
  openShortcutHelpModal(){
    const el = document.getElementById('shortcutHelpBackdrop');
    if(!el){
      alert('단축키 / 스니펫 안내 UI 요소를 찾지 못했습니다.');
      return;
    }
    el.classList.remove('hidden');
    el.classList.add('show');
    el.setAttribute('aria-hidden','false');

    const first = el.querySelector('button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])');
    if(first){ first.focus(); }
  },
  closeShortcutHelpModal(){
    const el = document.getElementById('shortcutHelpBackdrop');
    if(!el) return;
    el.classList.remove('show');
    el.classList.add('hidden');
    el.setAttribute('aria-hidden','true');
  },

  openFavSaveModal(){
    const el = document.getElementById('favSaveBackdrop');
    if(!el){
      alert('즐겨찾기/템플릿 저장 모달 DOM을 찾지 못했습니다.');
      return;
    }

    // 모드: 신규 저장
    this.favSaveMode = 'new';
    this.favSaveEditType = null;
    this.favSaveEditId = null;

    // 저장 대상 라디오 초기화 (개인/공용 선택 가능)
    const typePersonal = el.querySelector('input[name="favSaveType"][value="PERSONAL"]');
    const typeOrg = el.querySelector('input[name="favSaveType"][value="ORG"]');
    if(typePersonal){
      typePersonal.disabled = false;
      typePersonal.checked = true;
    }
    if(typeOrg){
      typeOrg.disabled = false;
      typeOrg.checked = false;
    }

    // 현재 에디터 SQL (선택 영역 우선)
    let sql = '';
    if(typeof cm !== 'undefined' && cm && typeof cm.getSelection === 'function'){
      sql = cm.getSelection();
      if(!sql || !sql.trim()){
        // 선택이 없으면 전체 에디터 내용 사용
        if(typeof cm.getValue === 'function'){
          sql = cm.getValue();
        }
      }
    }else if(this.getEditor){
      sql = this.getEditor() || '';
    }else if(typeof ui !== 'undefined' && ui && typeof ui.getEditor === 'function'){
      sql = ui.getEditor() || '';
    }
    if(!sql || !sql.trim()){
      alert('저장할 SQL이 없습니다.');
      return;
    }
    const firstLine = (sql.split(/\r?\n/)[0] || '').trim();
    const titleInput = el.querySelector('#favSaveName');
    if(titleInput){
      titleInput.value = firstLine.slice(0, 60);
    }

    const descEl = el.querySelector('#favSaveDesc');
    if(descEl){
      descEl.value = '';
    }

    const catSel = el.querySelector('#favSaveCategory');
    if(catSel){
      catSel.value = 'ETC';
    }
    const bizSel = el.querySelector('#favSaveBiz');
    if(bizSel){
      bizSel.value = 'COMMON';
    }

    const connId = state.connId || '';
    const targetSysSel = el.querySelector('#favSaveTargetSys');
    const targetDbInput = el.querySelector('#favSaveTargetDb');
    if(connId){
      const parts = String(connId).split('_');
      const sysCode = (parts[0] || '').toUpperCase();
      if(targetSysSel){
        const hasOption = Array.prototype.some.call(targetSysSel.options, opt => opt.value === sysCode);
        targetSysSel.value = hasOption ? sysCode : '';
      }
      if(targetDbInput){
        targetDbInput.value = connId;
      }
    }else{
      if(targetSysSel){ targetSysSel.value = ''; }
      if(targetDbInput){ targetDbInput.value = ''; }
    }

    const tagsInput = el.querySelector('#favSaveTags');
    if(tagsInput){
      tagsInput.value = '';
    }

    const sqlPreview = el.querySelector('#favSaveSqlPreview');
    if(sqlPreview){
      sqlPreview.value = sql;
    }

    // 유형에 따라 필드 활성/비활성 동기화
    this._syncFavSaveTypeUI();

    el.classList.remove('hidden');
    el.classList.add('show');
    el.setAttribute('aria-hidden','false');

    const first = el.querySelector('input, select, textarea, button');
    if(first){ first.focus(); }
  },


  openFavEditModal(type, id){
    const el = document.getElementById('favSaveBackdrop');
    if(!el){
      alert('즐겨찾기/템플릿 저장 모달 DOM을 찾지 못했습니다.');
      return;
    }
    const saveType = (type === 'ORG') ? 'ORG' : 'PERSONAL';

    // 편집 모드 설정
    this.favSaveMode = 'edit';
    this.favSaveEditType = saveType;
    this.favSaveEditId = id;

    // 저장 대상 라디오: 타입에 맞춰 체크 + 비활성화 (타입 변경 방지)
    const typePersonal = el.querySelector('input[name="favSaveType"][value="PERSONAL"]');
    const typeOrg = el.querySelector('input[name="favSaveType"][value="ORG"]');
    if(typePersonal){
      typePersonal.checked = (saveType === 'PERSONAL');
      typePersonal.disabled = true;
    }
    if(typeOrg){
      typeOrg.checked = (saveType === 'ORG');
      typeOrg.disabled = true;
    }

    // 대상 아이템 조회
    let item = null;
    try{
      if(saveType === 'PERSONAL' && typeof favorites !== 'undefined' && favorites && Array.isArray(favorites.list)){
        item = favorites.list.find(it => it.id === id);
      }else if(saveType === 'ORG' && typeof favTpl !== 'undefined' && favTpl && Array.isArray(favTpl.orgList)){
        item = favTpl.orgList.find(t => t.id === id);
      }
    }catch(e){
      console.warn('openFavEditModal item lookup error', e);
    }
    if(!item){
      alert('편집할 항목을 찾지 못했습니다.');
      return;
    }

    // 제목 / 설명
    const titleInput = el.querySelector('#favSaveName');
    if(titleInput){
      titleInput.value = item.name || '';
    }
    const descEl = el.querySelector('#favSaveDesc');
    if(descEl){
      descEl.value = item.description || '';
    }

    // 카테고리 / 업무명 / 태그
    const catSel = el.querySelector('#favSaveCategory');
    if(catSel){
      catSel.value = item.category || 'ETC';
    }
    const bizSel = el.querySelector('#favSaveBiz');
    if(bizSel){
      bizSel.value = item.biz || 'COMMON';
    }
    const tagsInput = el.querySelector('#favSaveTags');
    if(tagsInput){
      tagsInput.value = item.tags || '';
    }

    // 대상 시스템 / DB (조직 공용 템플릿일 때만 사용)
    const targetSysSel = el.querySelector('#favSaveTargetSys');
    const targetDbInput = el.querySelector('#favSaveTargetDb');
    if(saveType === 'ORG'){
      if(targetSysSel){
        targetSysSel.value = item.targetSys || '';
      }
      if(targetDbInput){
        targetDbInput.value = item.targetDbId || '';
      }
    }else{
      if(targetSysSel){ targetSysSel.value = ''; }
      if(targetDbInput){ targetDbInput.value = ''; }
    }

    // SQL 미리보기: 에디터에 변경해둔 내용이 있으면 그걸 우선, 없으면 기존 저장된 SQL
    const sqlPreview = el.querySelector('#favSaveSqlPreview');
    const currentSql = (ui.getEditor && ui.getEditor()) || '';
    const originalSql = item.sql || item.sqlText || '';
    const previewSql = (currentSql && currentSql.trim()) ? currentSql : originalSql;
    if(sqlPreview){
      sqlPreview.value = previewSql;
    }

    // 유형에 따라 필드 활성/비활성 동기화
    this._syncFavSaveTypeUI();

    el.classList.remove('hidden');
    el.classList.add('show');
    el.setAttribute('aria-hidden','false');

    const first = el.querySelector('input, select, textarea, button');
    if(first){ first.focus(); }
  },

  _syncFavSaveTypeUI(){
    const el = document.getElementById('favSaveBackdrop');
    if(!el) return;
    const typeOrg = el.querySelector('input[name="favSaveType"][value="ORG"]');
    const isOrg = !!(typeOrg && typeOrg.checked);
    const orgOnlyBlocks = el.querySelectorAll('[data-favsave-orgonly="true"]');
    orgOnlyBlocks.forEach(block=>{
      if(isOrg){
        block.classList.remove('muted');
        const inp = block.querySelector('input, select, textarea');
        if(inp){ inp.disabled = false; }
      }else{
        block.classList.add('muted');
        const inp = block.querySelector('input, select, textarea');
        if(inp){ inp.disabled = true; }
      }
    });
  },

  closeFavSaveModal(){
    const el = document.getElementById('favSaveBackdrop');
    if(!el) return;
    el.classList.remove('show');
    el.classList.add('hidden');
    el.setAttribute('aria-hidden','true');
  },

  applyFavSaveModal(){
    const el = document.getElementById('favSaveBackdrop');
    if(!el) return;
    try{
      const mode = this.favSaveMode || 'new';
      const editType = this.favSaveEditType || null;
      const editId = this.favSaveEditId || null;

      const typeInput = el.querySelector('input[name="favSaveType"]:checked');
      const type = typeInput ? typeInput.value : 'PERSONAL';

      const nameEl = el.querySelector('#favSaveName');
      const name = nameEl ? nameEl.value.trim() : '';
      if(!name){
        alert('제목을 입력하세요.');
        if(nameEl){ nameEl.focus(); }
        return;
      }

      // 미리보기 영역의 SQL을 우선 사용 (선택 영역/편집 반영)
      const previewEl = el.querySelector('#favSaveSqlPreview');
      let sql = previewEl ? (previewEl.value || '') : '';
      if((!sql || !sql.trim()) && typeof ui !== 'undefined' && ui && typeof ui.getEditor === 'function'){
        sql = ui.getEditor() || '';
      }
      if(!sql || !sql.trim()){
        alert('저장할 SQL이 없습니다.');
        return;
      }

      const descEl = el.querySelector('#favSaveDesc');
      const catSel = el.querySelector('#favSaveCategory');
      const bizSel = el.querySelector('#favSaveBiz');
      const tagsInput = el.querySelector('#favSaveTags');

      const description = descEl ? descEl.value.trim() : '';
      const category = catSel ? catSel.value : 'ETC';
      const biz = bizSel ? bizSel.value : '';
      const tags = tagsInput ? tagsInput.value.trim() : '';
      const connId = state.connId || null;

      if(type === 'PERSONAL'){
        // 개인 즐겨찾기 (편집/신규 모두 favorites 객체를 통해 처리)
        if(typeof favorites !== 'undefined' && favorites){
          if(mode === 'edit' && editType === 'PERSONAL' && typeof favorites.updateFromModal === 'function'){
            favorites.updateFromModal({
              id: editId,
              name,
              description,
              sql,
              connId,
              category,
              biz,
              tags
            });
            alert('개인 즐겨찾기를 수정했습니다. (프로토타입)');
          }else if(typeof favorites.addFromModal === 'function'){
            favorites.addFromModal({
              name,
              description,
              sql,
              connId,
              category,
              biz,
              tags
            });
            alert('개인 즐겨찾기로 저장했습니다. (프로토타입)');
          }else{
            alert('favorites 객체를 찾지 못해 개인 즐겨찾기 저장/수정을 수행하지 못했습니다.');
          }
        }else{
          alert('favorites 객체를 찾지 못해 개인 즐겨찾기 저장/수정을 수행하지 못했습니다.');
        }
      }else{
        // 조직 공용 템플릿
        const targetSysSel = el.querySelector('#favSaveTargetSys');
        const targetDbInput = el.querySelector('#favSaveTargetDb');

        if(!description){
          alert('공용 템플릿 설명을 입력하세요.');
          if(descEl){ descEl.focus(); }
          return;
        }
        const targetSys = targetSysSel ? targetSysSel.value : '';
        const targetDbId = targetDbInput ? targetDbInput.value.trim() : '';
        if(!targetSys){
          alert('대상 시스템을 선택하세요.');
          if(targetSysSel){ targetSysSel.focus(); }
          return;
        }
        if(!targetDbId){
          alert('대상 DB를 입력하세요.');
          if(targetDbInput){ targetDbInput.focus(); }
          return;
        }

        if(typeof favTpl !== 'undefined' && favTpl){
          if(mode === 'edit' && editType === 'ORG' && typeof favTpl.updateOrgFromModal === 'function'){
            favTpl.updateOrgFromModal({
              id: editId,
              name,
              description,
              category,
              biz,
              tags,
              targetSys,
              targetDbId,
              sql
            });
            alert('조직 공용 템플릿을 수정했습니다. (서버 연동 전, 프로토타입)');
          }else if(typeof favTpl.addOrgTemplateFromModal === 'function'){
            favTpl.addOrgTemplateFromModal({
              name,
              description,
              category,
              biz,
              tags,
              targetSys,
              targetDbId,
              sql
            });
            alert('조직 공용 템플릿으로 저장했습니다. (서버 연동 전, 프로토타입)');
          }else{
            alert('조직 공용 템플릿 객체(favTpl)를 찾지 못했습니다. 콘솔 로그로만 출력합니다.');
            console.log('ORG TEMPLATE (dummy):', {
              mode,
              editType,
              editId,
              name,
              description,
              category,
              biz,
              tags,
              targetSys,
              targetDbId,
              sql
            });
          }
        }else{
          alert('조직 공용 템플릿 객체(favTpl)를 찾지 못했습니다. 콘솔 로그로만 출력합니다.');
          console.log('ORG TEMPLATE (dummy):', {
            mode,
            editType,
            editId,
            name,
            description,
            category,
            biz,
            tags,
            targetSys,
            targetDbId,
            sql
          });
        }
      }

      this.closeFavSaveModal();
    }catch(e){
      console.warn('applyFavSaveModal error', e);
      alert('즐겨찾기/템플릿 저장 중 오류가 발생했습니다. 콘솔을 확인하세요.');
    }
  },

  newEditorTab(){
    const id = 'T'+(state.nextTab++);

    const baseConnId = state.connId || null;
    let dbLabel = '';
    try{
      if (baseConnId) {
        const conns = state.availableConns || [];
        for (const c of conns) {
          if (c && c.id === baseConnId) {
            dbLabel = c.label || c.id || '';
            break;
          }
        }
        if (!dbLabel && typeof tree !== 'undefined' && tree && typeof tree.getConnLi === 'function') {
          const li = tree.getConnLi(baseConnId);
          if (li) {
            if (li.dataset && li.dataset.label) {
              dbLabel = li.dataset.label;
            } else if (li.textContent) {
              dbLabel = li.textContent.trim();
            }
          }
        }
      }
    }catch(e){
      console.warn('newEditorTab conn label detect error', e);
    }

    const seq = state.nextTab;
    const title = dbLabel ? ('＜'+dbLabel+'＞ SQL ' + seq) : ('SQL ' + seq);
    const initialSql = '-- '+title+'\nSELECT 1;';

    const tab = {
      id,
      title,
      connId: baseConnId,
      lastConnId: baseConnId,
      sql: initialSql,
      isPinned: false,
      color: 'default'
    };
    state.tabs.push(tab);
    state.activeTabId = id;

    // 새 SQL 탭도 현재 활성/연결된 DB의 환경 색상/배너 규칙을 즉시 반영
    try{
      if (baseConnId && state.connStates && state.connStates[baseConnId]) {
        if (typeof applyTabUnderlineForConn === 'function') {
          applyTabUnderlineForConn(baseConnId);
        }
        if (typeof updateEnvBannerForConn === 'function') {
          updateEnvBannerForConn(baseConnId);
        }
      }else if (typeof updateEnvBannerForConn === 'function') {
        // 연결되지 않은 상태에서 열리는 탭은 배너를 숨김
        updateEnvBannerForConn(null);
      }
    }catch(e){
      console.warn('newEditorTab env color/banner apply error', e);
    }

    this.renderTabs();
    this.setEditor(initialSql);
    this.syncConnSelect();
  },

  newEmptyEditorTab(){
    // 최소 1개 탭 유지용: 내용이 비어 있는 새 SQL 탭을 연다.
    const id = 'T'+(state.nextTab++);

    const baseConnId = state.connId || null;
    let dbLabel = '';
    try{
      if (baseConnId) {
        const conns = state.availableConns || [];
        for (const c of conns) {
          if (c && c.id === baseConnId) {
            dbLabel = c.label || c.id || '';
            break;
          }
        }
        if (!dbLabel && typeof tree !== 'undefined' && tree && typeof tree.getConnLi === 'function') {
          const li = tree.getConnLi(baseConnId);
          if (li) {
            if (li.dataset && li.dataset.label) {
              dbLabel = li.dataset.label;
            } else if (li.textContent) {
              dbLabel = li.textContent.trim();
            }
          }
        }
      }
    }catch(e){
      console.warn('newEmptyEditorTab conn label detect error', e);
    }

    const seq = state.nextTab;
    const title = dbLabel ? ('＜'+dbLabel+'＞ SQL ' + seq) : ('SQL ' + seq);
    const initialSql = '';

    const tab = {
      id,
      title,
      connId: baseConnId,
      lastConnId: baseConnId,
      sql: initialSql,
      isPinned: false,
      color: 'default'
    };
    state.tabs.push(tab);
    state.activeTabId = id;

    // 새 SQL 탭도 현재 활성/연결된 DB의 환경 색상/배너 규칙을 즉시 반영
    try{
      if (baseConnId && state.connStates && state.connStates[baseConnId]) {
        if (typeof applyTabUnderlineForConn === 'function') {
          applyTabUnderlineForConn(baseConnId);
        }
        if (typeof updateEnvBannerForConn === 'function') {
          updateEnvBannerForConn(baseConnId);
        }
      }else if (typeof updateEnvBannerForConn === 'function') {
        // 연결되지 않은 상태에서 열리는 탭은 배너를 숨김
        updateEnvBannerForConn(null);
      }
    }catch(e){
      console.warn('newEmptyEditorTab env color/banner apply error', e);
    }

    this.renderTabs();
    this.setEditor(initialSql);
    this.syncConnSelect();
  },
  newEditorTabFromMenu(){
    // 파일 메뉴/단축키(Ctrl+T)에서 호출되는 전용 새 탭 열기 로직
    // 1) 트리에서 선택된 노드 정보 조회 (DB / 스키마 / 테이블 모두 허용)
    let info = null;
    try{
      // 1-1) 폴더/DB 트리 관리 모듈에서 선택 정보 우선 사용
      if (typeof dbFolderUi !== 'undefined' &&
          dbFolderUi &&
          typeof dbFolderUi.getSelectionInfo === 'function') {
        const sel = dbFolderUi.getSelectionInfo();
        if (sel && sel.li) {
          info = sel;
        }
      }
      // 1-2) 폴더 UI에서 선택 정보를 못 가져온 경우, .dbtree-selected 기반으로 조회
      if ((!info || !info.li) && typeof document !== 'undefined') {
        const selNode = document.querySelector('#dbTree .node.dbtree-selected');
        if (selNode) {
          const li = selNode.closest('li');
          if (li) {
            info = { node: selNode, li };
          }
        }
      }
    }catch(e){
      console.warn('newEditorTabFromMenu: selection resolve error', e);
    }

    // 2) 선택된 노드를 기준으로 connId 추출 (없으면 활성 커넥션 사용)
// 2) 선택된 노드를 기준으로 connId 추출 (없으면 활성 커넥션 사용)
    let connId = null;

    if (info && info.li) {
      try{
        if (typeof tree !== 'undefined' && tree && typeof tree.buildNodeInfo === 'function') {
          const nodeInfo = tree.buildNodeInfo(info.li);
          if (nodeInfo && nodeInfo.connId) {
            connId = nodeInfo.connId;
          }
        }
        if (!connId && info.li.closest) {
          const connLi = info.li.closest('li[data-conn-id]');
          if (connLi && connLi.dataset && connLi.dataset.connId) {
            connId = connLi.dataset.connId;
          }
        }
      }catch(e){
        console.warn('newEditorTabFromMenu: connId resolve error', e);
      }
    }

    // 선택 정보에서 connId를 얻지 못했을 경우: 현재 활성 커넥션(state.connId) 사용
    if (!connId && typeof state !== 'undefined' && state && state.connId) {
      connId = state.connId;
    }

    // 그래도 connId를 찾지 못하면 사용자에게 안내
    if (!connId) {
      alert('새 SQL 탭을 열려면 먼저 왼쪽에서 데이터베이스를 선택해 주세요.');
      return;
    }

    // 3) 해당 DB 연결 상태/사유에 따라 동작 결정 (트리 컨텍스트 메뉴의 "SQL 에디터 열기"와 동일한 정책)
    this._pendingConnSelectUsed   = false;
    this._pendingConnAfterConnect = 'newTab';

    const accessInfo = (state.connAccessInfo && state.connAccessInfo[connId]) || null;
    const isActive   = !!(state.connStates && state.connStates[connId]);

    if (accessInfo && accessInfo.reason && isActive) {
      // 이미 활성 + 사유 등록된 커넥션이면 모달 없이 바로 새 탭
      this.setActiveConn(connId);
      this._pendingConnAfterConnect = null;
      this.newEditorTab();
    } else {
      // 그 외에는 접속 사유/계정 입력 모달 먼저 → confirmConnReason()에서 _pendingConnAfterConnect === 'newTab'이면 새 탭 자동 생성
      if (typeof this.openConnReasonModal === 'function') {
        this.openConnReasonModal(connId);
      } else {
        // 안전망: 모달이 없으면 이전 동작과 동일하게 그냥 새 탭만 생성
        this._pendingConnAfterConnect = null;
        this.newEditorTab();
      }
    }
  },
  closeTab(id){
    const idx = state.tabs.findIndex(t=>t.id===id);
    if(idx>=0){ state.tabs.splice(idx,1); }
    if(state.activeTabId===id){ state.activeTabId = state.tabs.length? state.tabs[state.tabs.length-1].id : null; }
    this.renderTabs();
    this.syncConnSelect();

    // 최소 1개 SQL 탭 유지: 핀 탭이 없고 남은 탭이 없으면 빈 탭 하나 생성
    try{
      const tabs = state.tabs || [];
      const hasPinned = tabs.some(t => t && t.isPinned);
      if (!hasPinned && tabs.length === 0) {
        if (typeof this.newEmptyEditorTab === 'function') {
          this.newEmptyEditorTab();
        } else if (typeof this.newEditorTab === 'function') {
          this.newEditorTab();
        }
      }
    }catch(e){
      console.warn('closeTab min tab guard error', e);
    }
  },
  closeOtherTabs(id){
    state.tabs = state.tabs.filter(t=>t.id===id || t.isPinned);
    state.activeTabId = id;
    this.renderTabs();
    this.syncConnSelect();
  },
  closeAllTabs(){
    const pinnedTabs = state.tabs.filter(t=>t.isPinned);
    if(pinnedTabs.length === 0){
      state.tabs = [];
      state.activeTabId = null;
      this.renderTabs();
      this.syncConnSelect();
      this.clearEditor();

      // 최소 1개 SQL 탭 유지: 핀 탭이 없고 모두 닫힌 경우 빈 탭 하나 생성
      try{
        if (typeof this.newEmptyEditorTab === 'function') {
          this.newEmptyEditorTab();
        } else if (typeof this.newEditorTab === 'function') {
          this.newEditorTab();
        }
      }catch(e){
        console.warn('closeAllTabs min tab guard error', e);
      }
      return;
    }
    state.tabs = pinnedTabs;
    // 첫 번째 핀 탭을 활성 탭으로 전환
    this.switchTab(pinnedTabs[0].id);
  },
  togglePinTab(id){
    const tab = state.tabs.find(t => t.id === id);
    if (!tab) return;
    tab.isPinned = !tab.isPinned;
    this.renderTabs();
    if (typeof this.autoSaveSession === 'function') {
      this.autoSaveSession();
    }
  },
  setTabColor(id, color){
    const tab = state.tabs.find(t => t.id === id);
    if (!tab) return;
    tab.color = color || 'default';
    this.renderTabs();
    if (typeof this.autoSaveSession === 'function') {
      this.autoSaveSession();
    }
  },
  switchTab(id){
    state.activeTabId = id;
    const tab = state.tabs.find(t=>t.id===id);
    if(tab){
      // 탭에 저장된 마지막 연결 DB를 기준으로, 해당 DB가 현재 연결 상태라면 자동으로 활성 커넥션 전환
      try{
        const lastConnId = (tab.lastConnId || tab.connId || null);
        if(lastConnId && state.connStates && state.connStates[lastConnId]){
          const prevPendingAfter  = this._pendingConnAfterConnect;
          const prevPendingSelect = this._pendingConnSelectUsed;
          this._pendingConnAfterConnect = null;
          this._pendingConnSelectUsed   = true;
          this.setActiveConn(lastConnId);
          this._pendingConnAfterConnect = prevPendingAfter;
          this._pendingConnSelectUsed   = prevPendingSelect;
        }
      }catch(e){
        console.warn('switchTab auto-connect error', e);
      }

      this.setEditor(tab.sql || '');
      if(tab.result && tab.result.lastResult){
        state.lastResult = Object.assign({}, tab.result.lastResult);
        grid.render(state.lastResult.columns||[], state.lastResult.rows||[]);
        document.getElementById('execMeta').innerHTML = tab.result.execMeta || '';
        document.getElementById('messages').textContent = tab.result.messages || '';
        this.showResult();
      }else{
        this.clearResult();
      }
    }
    this.renderTabs();
    this.syncConnSelect();

    // 탭 전환 시 히스토리/최근 쿼리 패널도 현재 탭의 DB 기준으로 다시 렌더링
    try{
      if(typeof historyPanel !== 'undefined' && historyPanel && typeof historyPanel.render === 'function'){
        historyPanel.render();
      }
      if(typeof queryHistorySidebar !== 'undefined' && queryHistorySidebar && typeof queryHistorySidebar.render === 'function'){
        queryHistorySidebar.render();
      }
    }catch(e){
      console.warn('switchTab history/querySidebar render error', e);
    }
  },
  reorderTabs(fromId, toId, placeAfter){
    if(!fromId || !toId || fromId===toId) return;
    const fromIdx = state.tabs.findIndex(t=>t.id===fromId);
    let toIdx = state.tabs.findIndex(t=>t.id===toId);
    if(fromIdx<0 || toIdx<0) return;
    // 배열에서 먼저 제거
    const moved = state.tabs.splice(fromIdx, 1)[0];
    // 왼쪽에서 오른쪽으로 이동하는 경우 인덱스 보정
    if(fromIdx < toIdx){ toIdx -= 1; }
    // 기준 탭의 앞/뒤로 넣을지 결정
    if(placeAfter){ toIdx += 1; }
    if(toIdx < 0){ toIdx = 0; }
    if(toIdx > state.tabs.length){ toIdx = state.tabs.length; }
    state.tabs.splice(toIdx, 0, moved);
    // 드래그로 이동한 탭을 활성 탭으로 전환
    state.activeTabId = fromId;
    this.switchTab(fromId);
  },

  showTabRenameToast(msg){
    try{
      var el = document.getElementById('tabRenameToast');
      if(!el) return;
      el.textContent = msg || '';
      el.classList.add('show');
      clearTimeout(el._hideTimer);
      el._hideTimer = setTimeout(function(){
        el.classList.remove('show');
      }, 2200);
    }catch(e){
      if(window.console && console.warn){
        console.warn('tabRenameToast error', e);
      }
    }
  },

  startTabInlineRename(tabId){
    try{
      const tabEl = document.querySelector('.tab[data-tab-id="'+tabId+'"]');
      if(!tabEl) return;
      const titleSpan = tabEl.querySelector('.tab-title');
      if(!titleSpan) return;

      // 오류 메시지용 툴팁 요소 (탭 이름 중복 등)
      let err = tabEl.querySelector(':scope > .tab-title-edit-error');
      if(!err){
        err = document.createElement('div');
        err.className = 'tab-title-edit-error';
        tabEl.appendChild(err);
      }
      err.textContent = '';
      err.style.display = 'none';

      let input = tabEl.querySelector('.tab-title-edit');
      const fullText = (titleSpan.textContent || '').trim();

      function showTabError(msg){
        if(!err) return;
        err.textContent = msg || '';
        err.style.display = msg ? 'block' : 'none';
      }

      function getCoreFromStateOrText(){
        let core = '';
        try{
          if(typeof state !== 'undefined' && state && Array.isArray(state.tabs)){
            const tab = state.tabs.find(t => String(t.id) === String(tabId));
            if(tab && typeof tab.title !== 'undefined'){
              if (typeof getTabCoreTitle === 'function') {
                core = getTabCoreTitle(tab.title);
              } else {
                core = String(tab.title);
              }
            }
          }
        }catch(e){
          console.warn('startTabInlineRename: read core from state error', e);
        }
        if(!core){
          try{
            if(typeof getTabCoreTitle === 'function'){
              core = getTabCoreTitle(fullText);
            }else{
              core = fullText;
            }
          }catch(e){
            console.warn('startTabInlineRename: fallback core build error', e);
            core = fullText;
          }
        }
        return core;
      }

      function hasDuplicateTabTitle(coreVal){
        try{
          if(typeof state === 'undefined' || !state || !Array.isArray(state.tabs)) return false;
          const name = (coreVal || '').trim();
          if(!name) return false;
          for(const t of state.tabs){
            if(!t) continue;
            if(t.id === tabId) continue;
            let tCore = '';
            try{
              if(typeof getTabCoreTitle === 'function'){
                tCore = getTabCoreTitle(t.title || t.id || '');
              }else{
                tCore = (t.title || '').trim();
              }
            }catch(e){
              tCore = (t.title || '').trim();
            }
            if(tCore && tCore === name){
              return true;
            }
          }
          return false;
        }catch(e){
          console.warn('hasDuplicateTabTitle error', e);
          return false;
        }
      }

      const coreOriginal = getCoreFromStateOrText();

      if(!input){
        input = document.createElement('input');
        input.type = 'text';
        // 입력창에는 항상 코어 제목만
        input.value = coreOriginal;
        input.className = 'tab-title-edit';

        titleSpan.style.display = 'none';
        if(titleSpan.parentElement){
          titleSpan.parentElement.insertBefore(input, titleSpan);
        }else{
          tabEl.appendChild(input);
        }

        let finished = false;
        let removed = false;
        function cleanup(){
          if(finished) return;
          finished = true;
          input.removeEventListener('keydown', onKey);
          input.removeEventListener('blur', onBlur);
        }

        function apply(val){
          const v = (val || '').trim();
          const targetCore = v || coreOriginal || fullText;

          // 코어 제목 기준으로 중복 체크
          if(v && v !== coreOriginal && hasDuplicateTabTitle(targetCore)){
            try{
              if(typeof ui !== 'undefined' && ui && typeof ui.showTabRenameToast === 'function'){
                ui.showTabRenameToast('같은 이름의 탭이 이미 열려 있습니다.');
              }
            }catch(e){
              if(window.console && console.warn){
                console.warn('tab rename toast error', e);
              }
            }
            setTimeout(()=>{
              input.focus();
              input.select();
            }, 0);
            return false; // 중복 등 오류 시 편집 유지
          }

          // 오류 메시지 제거
          showTabError('');

          try{
            if(typeof state !== 'undefined' && state && Array.isArray(state.tabs)){
              const tab = state.tabs.find(t => String(t.id) === String(tabId));
              if(tab){
                // 내부 상태에는 코어 제목만 저장
                tab.title = targetCore;
              }
            }
            // 탭 전체를 다시 렌더링해서, 화면에는 ＜DB라벨＞ + 코어 제목으로 표시
            if(typeof ui !== 'undefined' && ui){
              if(typeof ui.renderTabs === 'function'){
                ui.renderTabs();
              }
              if(typeof ui._scheduleAutoSave === 'function'){
                ui._scheduleAutoSave();
              }
            }
          }catch(e){
            if(window.console && console.warn){
              console.warn('startTabInlineRename: update title error', e);
            }
          }
          return true;
        }

        function finish(applyChange){
          if(finished) return;
          if(applyChange){
            const ok = apply(input.value);
            if(!ok) return; // 중복 등 오류 시 편집 유지
          }else{
            showTabError('');
            titleSpan.style.display = '';
          }

          if(!removed){
            removed = true;
            try{
              if(input.parentElement){
                input.parentElement.removeChild(input);
              }
            }catch(e){
              if(window.console && console.warn){
                console.warn('tab title input remove error', e);
              }
            }
          }

          cleanup();
        }

        function onKey(e){
          if(e.key === 'Enter'){
            e.preventDefault();
            finish(true);
          }else if(e.key === 'Escape'){
            e.preventDefault();
            finish(false);
          }
        }
        function onBlur(){
          finish(true);
        }

        input.addEventListener('keydown', onKey);
        input.addEventListener('blur', onBlur);
        input.addEventListener('mousedown', function(e){
          e.stopPropagation();
        });
        input.addEventListener('click', function(e){
          e.stopPropagation();
        });
        input.addEventListener('dblclick', function(e){
          e.stopPropagation();
        });
        input.addEventListener('contextmenu', function(e){
          e.stopPropagation();
        });
      }

      input.focus();
      input.select();
    }catch(e){
      console.warn('startTabInlineRename error', e);
    }
  },
  renderTabs(){
    const tabsEl = document.getElementById('tabs');
    if(!tabsEl) return;
    tabsEl.querySelectorAll('.tab').forEach(e=>e.remove());
    state.tabs.forEach(t=>{
      // 렌더링 시점: state.tabs 안의 title 은 '코어' 제목만 가지고 있고,
      // 실제 표시용 라벨은 연결 정보에 따라 동적으로(prefix) 구성한다.
      let baseTitle = (t && (t.title || t.id)) || '';
      let displayTitle = baseTitle;
      try{
        if (typeof getTabCoreTitle === 'function') {
          baseTitle = getTabCoreTitle(baseTitle);
        }
        if (t && typeof applyConnLabelToTabTitle === 'function') {
          var cid = t.connId || t.lastConnId;
          if (cid) {
            const v = applyConnLabelToTabTitle(t, cid);
            if (v) {
              displayTitle = v;
            } else {
              displayTitle = baseTitle;
            }
          } else {
            displayTitle = baseTitle;
          }
        } else {
          displayTitle = baseTitle;
        }
      }catch(e){
        console.warn('renderTabs title build error', e);
        displayTitle = baseTitle;
      }
      const el = document.createElement('div');
      let tabClass = 'tab';
      if (t.id === state.activeTabId) {
        tabClass += ' active';
      }
      if (t.isPinned) {
        tabClass += ' pinned';
      }
      if (t.color && t.color !== 'default') {
        tabClass += ' color-' + t.color;
      }
      el.className = tabClass;
      const on = (t.connId && state.connStates[t.connId]);
      const dotCls = on ? 'conn-on' : 'conn-off';

      const title = displayTitle;
      let html = `<i class="fa-solid fa-circle ${dotCls} conn-dot"></i>`;
      html += `<span class="conn-badge"><span class="tab-title">${title}</span></span>`;
      html += ` <span class="close" title="닫기">✕</span>`;
      el.innerHTML = html;

      el.dataset.tabId = t.id;
      el.draggable = true;
      el.addEventListener('click', (ev)=>{
        if(ev.target.classList && ev.target.classList.contains('close')){
          ui.closeTab(t.id);
        }else{
          ui.switchTab(t.id);
        }
      });
      el.addEventListener('contextmenu', (ev)=>{
        ev.preventDefault();
        tabCtx.open(ev.clientX, ev.clientY, t.id);
      });
      el.addEventListener('dragstart', (ev)=>{
        if(ev.dataTransfer){
          ev.dataTransfer.effectAllowed = 'move';
          ev.dataTransfer.setData('text/plain', t.id);
        }
        el.classList.add('dragging');
      });
      el.addEventListener('dragend', ()=>{
        el.classList.remove('dragging');
      });
      el.addEventListener('dragover', (ev)=>{
        ev.preventDefault();
        if(ev.dataTransfer){
          ev.dataTransfer.dropEffect = 'move';
        }
        const rect = el.getBoundingClientRect();
        const midX = rect.left + rect.width / 2;
        const isAfter = ev.clientX > midX;
        el.classList.toggle('drop-after', isAfter);
        el.classList.toggle('drop-before', !isAfter);
      });
      el.addEventListener('dragleave', ()=>{
        el.classList.remove('drop-before','drop-after');
      });

      el.addEventListener('drop', (ev)=>{
        ev.preventDefault();
        if(!ev.dataTransfer) return;
        const fromId = ev.dataTransfer.getData('text/plain');
        const rect = el.getBoundingClientRect();
        const midX = rect.left + rect.width / 2;
        const placeAfter = ev.clientX > midX;
        el.classList.remove('drop-before','drop-after');
        ui.reorderTabs(fromId, t.id, placeAfter);
      });
      tabsEl.appendChild(el);
    });
    // 활성 탭 라벨 업데이트 (탭 이름 기준)
    const activeSpan = document.getElementById('activeTabLabel');
    if(activeSpan){
      const tab = state.tabs.find(t=>t.id===state.activeTabId);
      if(tab){
        let label = '';
        try{
          let baseTitle = (tab.title || tab.id || '');
          if (typeof getTabCoreTitle === 'function') {
            baseTitle = getTabCoreTitle(baseTitle);
          }
          label = baseTitle;
          const cid = tab.connId || tab.lastConnId;
          if (cid && typeof applyConnLabelToTabTitle === 'function') {
            const v = applyConnLabelToTabTitle(tab, cid);
            if (v) {
              label = v;
            }
          }
        }catch(e){
          console.warn('activeTabLabel build error', e);
          label = tab.title || (state.activeTabId || '-');
        }
        activeSpan.textContent = label || (state.activeTabId || '-');
      }else{
        activeSpan.textContent = state.activeTabId || '-';
      }
    }
    // 탭 오버플로우(>> 버튼) 상태 갱신
    if (typeof this.updateTabOverflow === 'function') {
      this.updateTabOverflow();
    }
  },
  
  

updateTabOverflow(){
    try{
      const tabsEl  = document.getElementById('tabs');
      const btn     = document.getElementById('tabOverflowBtn');
      const menu    = document.getElementById('tabOverflowMenu');
      if(!tabsEl || !btn || !menu) return;

      const tabEls = Array.from(tabsEl.querySelectorAll('.tab'));
      if(!tabEls.length){
        btn.classList.add('hidden');
        menu.classList.add('hidden');
        menu.innerHTML = '';
        return;
      }

      
      const MAX_VISIBLE = 4;
      const activeId = (typeof state !== 'undefined' && state) ? state.activeTabId : null;

      // 먼저 모두 보이게 해서 폭 측정
      tabEls.forEach(el => {
        el.style.display = '';
      });

      let containerWidth = tabsEl.clientWidth || 0;
      if (!containerWidth){
        const rect = tabsEl.getBoundingClientRect();
        containerWidth = rect.width || 0;
      }

      // 활성 탭을 우선 포함한 순서 배열 (선호 순서)
      const prefer = [];
      if (activeId){
        const activeEl = tabEls.find(el => el.dataset.tabId === String(activeId));
        if (activeEl){
          prefer.push(activeEl);
        }
      }
      tabEls.forEach(el => {
        if (prefer.indexOf(el) === -1){
          prefer.push(el);
        }
      });

      const visible = [];
      const marginRatio = 0.94;
      let usedWidth = 0;

      if (!containerWidth){
        // 폭 계산이 불가능한 경우: 단순 개수 기준
        for (const el of prefer){
          if (visible.length >= MAX_VISIBLE) break;
          visible.push(el);
        }
      }else{
        for (const el of prefer){
          const rect = el.getBoundingClientRect();
          const w = rect.width || el.offsetWidth || 0;

          if (!visible.length){
            // 첫 번째(보통 활성 탭)는 무조건 표시
            visible.push(el);
            usedWidth = w;
            continue;
          }
          if (visible.length >= MAX_VISIBLE) break;

          if (usedWidth + w <= containerWidth * marginRatio){
            visible.push(el);
            usedWidth += w;
          }
          // 그 외의 탭은 overflow 대상이 됨 (hidden)
        }
      }

      const hidden = tabEls.filter(el => visible.indexOf(el) === -1);

      // 표시/숨김 반영
      tabEls.forEach(el => {
        if (visible.indexOf(el) !== -1){
          el.style.display = '';
        }else{
          el.style.display = 'none';
        }
      });

      if (!hidden.length){
        btn.classList.add('hidden');
        menu.classList.add('hidden');
        menu.innerHTML = '';
        return;
      }

      // 4) 숨겨진 탭들로 overflow 메뉴 구성
      btn.classList.remove('hidden');
      menu.classList.add('hidden');
      menu.innerHTML = '';

      hidden.forEach(el => {
        const id   = el.dataset.tabId;
        let label = '';
        try{
          if (typeof state !== 'undefined' && state && Array.isArray(state.tabs)) {
            const t = state.tabs.find(t => String(t.id) === String(id));
            if (t) {
              let baseTitle = t.title || t.id || '';
              if (typeof getTabCoreTitle === 'function') {
                baseTitle = getTabCoreTitle(baseTitle);
              }
              label = baseTitle;
              const cid = t.connId || t.lastConnId || (state && state.connId);
              if (cid && typeof applyConnLabelToTabTitle === 'function') {
                const vv = applyConnLabelToTabTitle(t, cid);
                if (vv) label = vv;
              }
            }
          }
        }catch(e){
          console.warn('tab overflow label build error', e);
        }
        if (!label) {
          const span = el.querySelector('.tab-title');
          label = span ? span.textContent.trim() : (id || '');
        }
        if (label) {
          // 공백 정규화: < 와 > 주변과 연속 공백을 정리해서 정렬 맞춤
          label = label.replace(/<\s+/g, '<')
                       .replace(/\s+>/g, '>')
                       .replace(/\s+/g, ' ')
                       .trim();
        }
        const item = document.createElement('div');
        item.className = 'tab-overflow-item';
        item.textContent = label || '(제목 없음)';
        item.dataset.tabId = id || '';
        item.addEventListener('click', function(e){
          e.stopPropagation();
          if (id){
            ui.switchTab(id);
          }
          if (typeof ui.closeTabOverflowMenu === 'function') {
            ui.closeTabOverflowMenu();
          }
        });
        menu.appendChild(item);
      });

    }catch(e){
      console.warn('updateTabOverflow error', e);
    }
  },
  toggleTabOverflowMenu(){
    const menu = document.getElementById('tabOverflowMenu');
    const btn  = document.getElementById('tabOverflowBtn');
    if(!menu || !btn) return;
    if(menu.classList.contains('hidden')){
      menu.classList.remove('hidden');
      try{
        // 일단 보이게 한 뒤 위치 계산 (폭은 auto)
        menu.style.visibility = 'hidden';
        menu.style.display    = 'block';
        menu.style.width      = 'auto';

        const rect = btn.getBoundingClientRect();
        const menuRect = menu.getBoundingClientRect();

        let top  = rect.bottom + 4;
        let left = rect.left; // 버튼의 왼쪽 기준

        const vw = window.innerWidth || document.documentElement.clientWidth || 0;
        // 화면 오른쪽을 넘기면 왼쪽으로 당김
        if (vw && left + menuRect.width > vw - 4){
          left = Math.max(4, vw - menuRect.width - 4);
        }
        // 화면 왼쪽을 넘기면 최소 여백
        if (left < 4) left = 4;

        menu.style.top  = top + 'px';
        menu.style.left = left + 'px';
        menu.style.visibility = '';
        menu.style.display    = '';
      }catch(e){
        console.warn('tabOverflowMenu position error', e);
      }
    }else{
      menu.classList.add('hidden');
    }
  },
  closeTabOverflowMenu(){
    const menu = document.getElementById('tabOverflowMenu');
    if(!menu) return;
    if(!menu.classList.contains('hidden')){
      menu.classList.add('hidden');
    }
  },
  _scheduleAutoSave(){
    if (!state.autoSaveEditor || !window.localStorage) return;
    if (this._autoSaveTimer) {
      clearTimeout(this._autoSaveTimer);
    }
    const sec = state.autoSaveIntervalSec || 5;
    const delay = Math.max(1000, sec * 1000);
    this._autoSaveTimer = setTimeout(()=>{
      try{
        this.autoSaveSession && this.autoSaveSession();
      }catch(e){
        console.warn('autoSaveSession error', e);
      }
    }, delay);
  },
  autoSaveSession(){
    if (!state.autoSaveEditor || !window.localStorage) return;
    try{
      const tabs = (state.tabs || []).map(t => ({
        id: t.id,
        title: t.title,
        connId: t.connId || null,
        lastConnId: t.lastConnId || t.connId || null,
        sql: t.sql || '',
        isPinned: !!t.isPinned,
        color: t.color || 'default'
      }));
      const hasContent = tabs.some(t => (t.sql || '').trim().length > 0);
      if (!hasContent) {
        localStorage.removeItem(DBAM_AUTO_SAVE_KEY);
        return;
      }
      const payload = {
        version: 1,
        savedAt: Date.now(),
        connId: state.connId || null,
        activeTabId: state.activeTabId || (tabs[0] && tabs[0].id) || null,
        tabs
      };
      localStorage.setItem(DBAM_AUTO_SAVE_KEY, JSON.stringify(payload));
    }catch(e){
      console.warn('autoSaveSession error', e);
    }
  },
  restoreSessionFromAutoSave(){
    if (!window.localStorage) return false;
    try{
      const raw = localStorage.getItem(DBAM_AUTO_SAVE_KEY);
      if (!raw) return false;
      const payload = JSON.parse(raw);
      if (!payload || !Array.isArray(payload.tabs) || !payload.tabs.length) return false;
      // 이미 탭이 있는 경우에는 복원하지 않음
      if (state.tabs && state.tabs.length) {
        return false;
      }
      state.tabs = payload.tabs.map(t => ({
        id: t.id,
        title: t.title,
        connId: t.connId || null,
        lastConnId: t.lastConnId || t.connId || null,
        sql: t.sql || '',
        isPinned: !!t.isPinned,
        color: t.color || 'default'
      }));
      // nextTab 계산 (T숫자 기준)
      let next = 1;
      state.tabs.forEach(t => {
        const m = (t.id || '').match(/^T(\d+)$/);
        if (m) {
          const n = parseInt(m[1], 10);
          if (!isNaN(n) && n >= next) {
            next = n + 1;
          }
        }
      });
      state.nextTab = next;
      // activeTabId 결정
      if (payload.activeTabId && state.tabs.find(t => t.id === payload.activeTabId)) {
        state.activeTabId = payload.activeTabId;
      } else if (state.tabs[0]) {
        state.activeTabId = state.tabs[0].id;
      }
      this.renderTabs();
      const active = state.tabs.find(t => t.id === state.activeTabId);
      if (active) {
        this.setEditor(active.sql || '');
      }
      this.syncConnSelect();
      if (typeof this.showToast === 'function') {
        this.showToast('임시저장된 탭/쿼리를 복원했습니다.');
      }
      return true;
    }catch(e){
      console.warn('restoreSessionFromAutoSave error', e);
      return false;
    }
  },


  beginQueryProgress(label){
    try{
      const ov = document.getElementById('queryProgressOverlay');
      if(!ov) return;
      const now = Date.now();
      if (!this._queryBusy) {
        this._progressStartTs = now;
      }
      if (this._progressHideTimer) {
        clearTimeout(this._progressHideTimer);
        this._progressHideTimer = null;
      }
      this._queryBusy = (this._queryBusy || 0) + 1;
      ov.classList.add('is-active');
      const txtEl = ov.querySelector('.qp-text');
      if(txtEl){
        txtEl.textContent = label || '쿼리 실행 중입니다…';
      }
    }catch(e){
      console.warn('beginQueryProgress error', e);
    }
  },
  endQueryProgress(){
    try{
      const ov = document.getElementById('queryProgressOverlay');
      if(!ov) return;
      this._queryBusy = Math.max(0, (this._queryBusy || 0) - 1);
      if(this._queryBusy === 0){
        const now = Date.now();
        const minMs = 500; // 최소 표시 시간
        const started = this._progressStartTs || now;
        const elapsed = now - started;
        const remain = minMs - elapsed;
        const hide = ()=>{
          const el = document.getElementById('queryProgressOverlay');
          if(el){
            el.classList.remove('is-active');
          }
          this._progressHideTimer = null;
        };
        if (remain > 0){
          if (this._progressHideTimer) {
            clearTimeout(this._progressHideTimer);
          }
          this._progressHideTimer = setTimeout(hide, remain);
        } else {
          hide();
        }
      }
    }catch(e){
      console.warn('endQueryProgress error', e);
    }
  },

  setEditor(sql){
    if(cm){
      cm.setValue(sql);
    }else{
      const ta = document.getElementById('sqlEditor');
      if(ta){ ta.value = sql; }
    }
  },
  getEditor(){
    if(cm){
      return cm.getValue();
    }
    const ta = document.getElementById('sqlEditor');
    return ta ? ta.value : '';
  },
  // 에디터 내용 뒤에 SQL을 이어 붙이는 유틸 (히스토리/최근 쿼리/템플릿 공통 사용 가능)
  appendSql(sql){
    if(!sql){ return; }
    try{
      if(typeof ui !== 'undefined' && ui && typeof ui.getEditor === 'function' && typeof ui.setEditor === 'function'){
        const current = ui.getEditor() || '';
        let next = '';
        if(!current || !current.trim()){
          next = sql;
        }else{
          const trimmed = current.replace(/\s*$/, '');
          next = trimmed + '\n\n' + sql;
        }
        ui.setEditor(next);
      }
    }catch(e){
      console.warn('ui.appendSql error', e);
    }
  },
  saveCurrentTabAsSql(){
    if(!state.activeTabId){
      alert('저장할 탭이 없습니다.');
      return;
    }
    const sql = this.getEditor();
    const tab = state.tabs.find(t=>t.id===state.activeTabId) || null;
    const title = tab && tab.title ? tab.title : state.activeTabId;
    // 파일명용: 공백은 '_'로, Windows에서 금지된 문자만 제거하고 한글 등은 그대로 유지
    const rawTitle = title || 'sql_tab';
    let safeTitle = rawTitle.trim().replace(/\s+/g, '_').replace(/[\\/:*?"<>|]/g, '');
    if(!safeTitle){ safeTitle = 'sql_tab'; }
    const defaultName = safeTitle + '.sql';
    const userName = window.prompt('저장할 파일명을 입력하세요 (예: my_query.sql)', defaultName);
    if(!userName){ return; }
    const fileName = userName.trim();
    if(!fileName){
      alert('파일명이 올바르지 않습니다.');
      return;
    }
    const blob = new Blob([sql], {type:'text/sql;charset=utf-8;'});
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = fileName;
    document.body.appendChild(a);
    a.click();
    setTimeout(()=>{ URL.revokeObjectURL(a.href); a.remove(); }, 0);
  },
  openSqlFile(){
    let input = document.getElementById('sqlFileInput');
    if(!input){
      input = document.createElement('input');
      input.type = 'file';
      input.id = 'sqlFileInput';
      input.accept = '.sql,.txt,text/*';
      input.style.display = 'none';
      document.body.appendChild(input);
    }
    input.value = '';
    input.onchange = (e)=>{
      const fi = e.target.files && e.target.files[0];
      if(!fi) return;
      const reader = new FileReader();
      reader.onload = (ev)=>{
        const text = (ev.target && ev.target.result) ? ev.target.result : '';
        // 항상 새 탭에 로드
        this.newEditorTab();
        const tab = state.tabs.find(t=>t.id===state.activeTabId);
        if(tab){
          tab.title = fi.name;
          tab.sql = text;
        }
        this.setEditor(text);
        this.renderTabs();
      };
      reader.readAsText(fi, 'utf-8');
    };
    input.click();
  },

  clearEditor(){ this.setEditor(''); },
  formatSql(){
    let sql = this.getEditor() || '';
    if (!sql.trim()) {
      return;
    }

    // 0) 기본 정규화 (CRLF → LF)
    sql = sql.replace(/\r\n/g, '\n');

    // 1) 예약어 대문자화
    const keywords = [
      'select','from','where','group by','order by',
      'join','left join','right join','inner join','outer join','on',
      'insert','into','values','update','set','delete','create',
      'table','view','function','procedure','package','trigger',
      'grant','revoke','alter','drop','with','union','union all'
    ];
    keywords.forEach(k => {
      const re = new RegExp('\\b' + k.replace(/\s+/g,'\\s+') + '\\b','gi');
      sql = sql.replace(re, k.toUpperCase());
    });

    // 1-1) 예약어 외 식별자(컬럼/조건 등)도 대문자화 (옵션)
    const upperAll = (typeof state !== 'undefined' && !!state.formatUpperAll);
    if (upperAll && typeof this._uppercaseNonKeywords === 'function') {
      sql = this._uppercaseNonKeywords(sql);
    }

    // 2) 내 설정: 줄바꿈 옵션 여부
    const breakLines = (typeof state !== 'undefined' && !!state.formatBreakLines);
    if (!breakLines) {
      // 줄바꿈 옵션이 꺼져 있으면 대문자 변환까지만 적용
      this.setEditor(sql.trim());
      return;
    }

    // 3) 주요 절(예약어) 앞뒤로 줄바꿈 (idempotent)
    const clauseKeywords = [
      'SELECT',
      'FROM',
      'WHERE',
      'GROUP BY',
      'HAVING',
      'ORDER BY',
      'INSERT INTO',
      'VALUES',
      'UPDATE',
      'SET',
      'DELETE FROM',
      'WITH',
      'UNION ALL',
      'UNION'
    ];
    // 3-1) 키워드 주변 공백/줄바꿈을 ' KW ' 형태로 정규화
    clauseKeywords.forEach(kw => {
      const reNorm = new RegExp('\\s*' + kw.replace(/\s+/g,'\\s+') + '\\s*','gi');
      sql = sql.replace(reNorm, ' ' + kw + ' ');
    });
    // 3-2) 우리가 원하는 패턴으로 줄바꿈 적용 (키워드별로 제어)
    // SELECT / FROM 등: 키워드를 단독 행에 두고, 본문은 다음 줄 3칸 들여쓰기
    sql = sql.replace(/\s*SELECT\s+/gi, '\nSELECT\n   ');
    sql = sql.replace(/\s*FROM\s+/gi, '\nFROM\n   ');
    sql = sql.replace(/\s*GROUP\s+BY\s+/gi, '\nGROUP BY\n   ');
    sql = sql.replace(/\s*HAVING\s+/gi, '\nHAVING\n   ');
    sql = sql.replace(/\s*ORDER\s+BY\s+/gi, '\nORDER BY\n   ');
    sql = sql.replace(/\s*INSERT\s+INTO\s+/gi, '\nINSERT INTO\n   ');
    sql = sql.replace(/\s*VALUES\s+/gi, '\nVALUES\n   ');
    sql = sql.replace(/\s*UPDATE\s+/gi, '\nUPDATE\n   ');
    sql = sql.replace(/\s*SET\s+/gi, '\nSET\n   ');
    sql = sql.replace(/\s*DELETE\s+FROM\s+/gi, '\nDELETE FROM\n   ');
    sql = sql.replace(/\s*WITH\s+/gi, '\nWITH\n   ');
    sql = sql.replace(/\s*UNION\s+ALL\s+/gi, '\nUNION ALL\n   ');
    sql = sql.replace(/\s*UNION\s+/gi, '\nUNION\n   ');

    // WHERE: 첫 번째 조건은 같은 줄에 배치
    sql = sql.replace(/\s*WHERE\s+/gi, '\nWHERE ');

    // 4) 콤마 기준 줄바꿈 (idempotent)
    sql = sql
      .replace(/,\s*/g, ', ')     // 먼저 ', ' 형태로 정규화
      .replace(/,\s*/g, ',\n   '); // 이후 우리가 쓰는 패턴으로 통일

    // 4-1) WHERE / ON / HAVING 절 안에서 AND / OR 줄바꿈 정리
    {
      const lines = sql.split('\n');
      let inCond = false;
      for (let i = 0; i < lines.length; i++) {
        const trimmed = lines[i].trim();
        if (/^(WHERE|ON|HAVING)\b/.test(trimmed)) {
          inCond = true;
        } else if (/^(SELECT|FROM|GROUP BY|ORDER BY|HAVING|JOIN|UNION|INSERT|UPDATE|DELETE|WITH)\b/.test(trimmed)) {
          inCond = false;
          continue;
        }
        if (!inCond) continue;
        if (!/(AND|OR)\b/i.test(trimmed)) continue;

        // 이미 AND/OR로 시작하는 줄은 들여쓰기만 정규화
        if (/^(AND|OR)\b/i.test(trimmed)) {
          lines[i] = '   ' + trimmed.replace(/^(AND|OR)\b/i, function(m){ return m.toUpperCase(); });
          continue;
        }

        // 한 줄에 조건과 AND/OR가 함께 있을 때 AND/OR를 다음 줄로 내림
        lines[i] = lines[i].replace(/\s+(AND|OR)\s+/gi, function(_m, op){
          return '\n   ' + op.toUpperCase() + ' ';
        });
      }
      sql = lines.join('\n');
    }


    // 5) 공백 정리
    sql = sql
      .replace(/[ \t]+\n/g, '\n')  // 줄 끝 공백 제거
      .replace(/\n{3,}/g, '\n\n')  // 3줄 이상 개행 → 2줄
      .trim();

    this.setEditor(sql);
  },
  _uppercaseNonKeywords(sql){
    // 예약어 대문자화 이후, 문자열/주석을 제외한 영역의 식별자(컬럼/조건 등)를 대문자로 변환
    let out = '';
    let inS = false, inD = false, inLC = false, inBC = false;
    let inDollar = null;
    for (let i = 0; i < sql.length; ) {
      const c = sql[i];
      const c2 = (i + 1 < sql.length) ? sql[i + 1] : '';

      // --- 라인 주석 ---
      if (inLC) {
        out += c;
        if (c === '\n') {
          inLC = false;
        }
        i++;
        continue;
      }
      // --- 블록 주석 ---
      if (inBC) {
        out += c;
        if (c === '*' && c2 === '/') {
          out += c2;
          i += 2;
          inBC = false;
        } else {
          i++;
        }
        continue;
      }
      // --- dollar-quoting ---
      if (inDollar) {
        out += c;
        if (c === '$') {
          const tag = inDollar;
          if (sql.substr(i, tag.length) === tag) {
            out += sql.substr(i + 1, tag.length - 1);
            i += tag.length;
            inDollar = null;
          } else {
            i++;
          }
        } else {
          i++;
        }
        continue;
      }
      // --- 작은따옴표 문자열 ---
      if (inS) {
        out += c;
        if (c === '\'' && (i === 0 || sql[i - 1] != '\\')) {
          inS = false;
        }
        i++;
        continue;
      }
      // --- 큰따옴표 문자열 ---
      if (inD) {
        out += c;
        if (c === '\"' && (i === 0 || sql[i - 1] != '\\')) {
          inD = false;
        }
        i++;
        continue;
      }

      // 모드 진입 판별
      if (c === '-' && c2 === '-') {
        inLC = true;
        out += c + c2;
        i += 2;
        continue;
      }
      if (c === '/' && c2 === '*') {
        inBC = true;
        out += c + c2;
        i += 2;
        continue;
      }
      if (c === '\'') {
        inS = true;
        out += c;
        i++;
        continue;
      }
      if (c === '\"') {
        inD = true;
        out += c;
        i++;
        continue;
      }
      if (c === '$') {
        const m = sql.slice(i).match(/^\$[A-Za-z_]*\$/);
        if (m) {
          inDollar = m[0];
          out += m[0];
          i += m[0].length;
          continue;
        }
      }

      // 코드 영역: 식별자 토큰을 찾아 대문자화
      if (/[A-Za-z_]/.test(c)) {
        let j = i + 1;
        while (j < sql.length && /[A-Za-z0-9_$]/.test(sql[j])) {
          j++;
        }
        const token = sql.slice(i, j);
        out += token.toUpperCase();
        i = j;
        continue;
      }

      // 기타 문자 그대로
      out += c;
      i++;
    }
    return out;
  },

  toggleResult(){
    if(bottomTabs){
      bottomTabs.toggle('result');
    }
  },
  clearResult(){ grid.render([], []); ui.setExecMeta(''); document.getElementById('messages').textContent=''; },
  toggleMaxRows(){ const vals = [200,500,1000,2000]; const i = vals.indexOf(state.maxRows); state.maxRows = vals[(i+1)%vals.length]; document.getElementById('maxRowsLabel').textContent = state.maxRows; },
  refreshConnStatus(){
    const chip = document.getElementById('connStatus');
    const connectedCount = Object.values(state.connStates).filter(Boolean).length;
    state.connected = connectedCount > 0;
    if(state.connected){
      const active = state.connId || '-';
      chip.textContent = `연결됨: ${connectedCount}/${state.availableConns.length} (활성: ${active})`;
      chip.classList.add('ok'); chip.classList.remove('warn');
    } else {
      chip.textContent = '연결되지 않음';
      chip.classList.remove('ok'); chip.classList.add('warn');
    }
  },
  renderConnSelect(){ const sel = document.getElementById('connSelect'); if(!sel) return; sel.innerHTML = '<option value="">선택</option>' + state.availableConns.map(c=>`<option value="${c.id}">${c.label}</option>`).join(''); this.syncConnSelect(); },
  onConnSelectChange(connId){
    const cid = connId || null;

    if (cid) {
      // 셀렉트에서 연결 선택 시:
      // - 이미 활성 + 사유가 등록된 커넥션이면 모달 없이 바로 전환
      // - 그 외에는 사유/ITSM 입력 모달 먼저
      this._pendingConnSelectPrev   = state.connId || '';
      this._pendingConnSelectUsed   = true;
      this._pendingConnAfterConnect = null;

      const info     = (state.connAccessInfo && state.connAccessInfo[cid]) || null;
      const isActive = !!(state.connStates && state.connStates[cid]);

      if (info && info.reason && isActive) {
        // 이미 연결/사유가 있는 경우: 모달 없이 즉시 활성화
        this.setActiveConn(cid);
      } else {
        // 처음 연결하거나, 이전 사유가 없는 경우: 모달 오픈
        this.openConnReasonModal(cid);
      }
    } else {
      // "선택" 등 빈 값 선택 시 활성 커넥션만 해제
      state.connId = null;

      const tab = state.tabs.find(t => t.id === state.activeTabId);
      if (tab) {
        tab.connId = null;
      }

      this.renderTabs();
      this.refreshConnStatus();
      tree.updateConnBadges();
    }
  },
  setActiveConn(connId){
    // 이전에 활성화된 연결 수 (첫 접속 판단용)
    var prevActiveCount = 0;
    try{
      prevActiveCount = Object.keys(state.connStates || {}).filter(function(id){ return !!state.connStates[id]; }).length;
    }catch(e){
      prevActiveCount = 0;
    }

    state.connId = connId;
    if (connId) {
      state.connStates[connId] = true;
      if (typeof applyTabUnderlineForConn === 'function') {
        applyTabUnderlineForConn(connId);
      }
      // env 배너는 활성 탭에 이 연결이 실제로 매핑된 경우에만 아래에서 갱신한다.
      if(typeof sessionMonitor!=='undefined' && sessionMonitor.onConnect){
        sessionMonitor.onConnect(connId);
      }
    }

    var isFirstConnect = (!!connId && prevActiveCount === 0);

    // 활성 탭에 연결을 매핑하는 규칙:
    // - "연결 + 새 탭"(_pendingConnAfterConnect === 'newTab')인 경우: 기존 탭은 그대로 두고 새 탭에서만 사용
    // - 셀렉트 박스에서 변경한 경우(_pendingConnSelectUsed === true): 활성 탭의 연결을 강제로 이 DB로 변경
    // - 그 외(트리에서 일반 "연결" 선택 등): 이 탭에 아직 연결이 없을 때만 매핑
    const tab = state.tabs.find(t => t.id === state.activeTabId);
    if (tab) {
      let mapped = false;
      if (this._pendingConnAfterConnect === 'newTab') {
        // do nothing; newEditorTab()에서 state.connId를 사용
      } else if (this._pendingConnSelectUsed) {
        tab.connId = connId || null;
        mapped = !!connId;
      } else {
        if (!tab.connId) {
          tab.connId = connId || null;
          mapped = !!connId;
        }
      }
      if (mapped && connId) {
        tab.lastConnId = connId;
        // 활성 탭 제목에 DB 라벨 반영 (＜DB＞ SQL N)
      }
    }

    // 첫 접속인 경우: 아직 연결되지 않은 SQL 탭들도 모두 이 DB로 매핑 & 제목 정리
    if (isFirstConnect && connId && Array.isArray(state.tabs)) {
      try{
        state.tabs.forEach(function(t){
          if(!t) return;
          if(!t.connId){
            t.connId = connId;
            t.lastConnId = connId;
          }
        });
      }catch(e){
        console.warn('setActiveConn first-connect tab mapping error', e);
      }
    }

    // 활성 탭 기준으로 환경 배너 갱신
    if (typeof updateEnvBannerForConn === 'function') {
      try{
        var activeTab = null;
        if (Array.isArray(state.tabs) && state.activeTabId) {
          activeTab = state.tabs.find(function(t){ return t && t.id === state.activeTabId; });
        }
        var envConnId = null;
        if (activeTab) {
          envConnId = activeTab.lastConnId || activeTab.connId || null;
        }
        if (!envConnId && connId) {
          envConnId = connId;
        }
        if (envConnId) {
          updateEnvBannerForConn(envConnId);
        } else {
          updateEnvBannerForConn(null);
        }
      }catch(e){
        console.warn('setActiveConn env-banner update error', e);
      }
    }

    const sel = document.getElementById('connSelect');
    if (sel) {
      // 현재 활성 탭 기준으로 셀렉트 값 동기화
      const active = state.tabs.find(t => t.id === state.activeTabId);
      sel.value = (active && active.connId) ? active.connId : '';
    }

    this.renderTabs();
    this.refreshConnStatus();
    tree.updateConnBadges();
  },
  syncConnSelect(){ const sel = document.getElementById('connSelect'); if(!sel) return; const tab = state.tabs.find(t=>t.id===state.activeTabId); sel.value = (tab && tab.connId) ? tab.connId : ''; },
  showResult(){
    if(state.connected && bottomTabs){
      bottomTabs.activate('result');
    }
  },
  bindResizers(){
    // Vertical (sidebar)
    const v = document.getElementById('vResizer');
    const sidebar = document.getElementById('sidebar');
    v.addEventListener('mousedown', startDrag);
    function startDrag(e){ e.preventDefault(); document.body.style.userSelect='none'; document.addEventListener('mousemove', onDrag); document.addEventListener('mouseup', stopDrag); }
    function onDrag(e){ const w = Math.min(Math.max(e.clientX, parseInt(getComputedStyle(document.documentElement).getPropertyValue('--min-sidebar-w'))), parseInt(getComputedStyle(document.documentElement).getPropertyValue('--max-sidebar-w'))); sidebar.style.width = w+'px'; localStorage.setItem('sidebarW', w); }
    function stopDrag(){ document.body.style.userSelect=''; document.removeEventListener('mousemove', onDrag); document.removeEventListener('mouseup', stopDrag); }
    // Horizontal (editor/result)
    const h = document.getElementById('hResizer');
    const editorBox = ()=> cm ? cm.getWrapperElement() : document.querySelector('.editor textarea');
    h.addEventListener('mousedown', startDragH);
    function startDragH(e){ e.preventDefault(); const eb = editorBox(); const startY = e.clientY; const startH = eb.offsetHeight; document.body.style.userSelect='none';
      function onDragH(ev){ const dh = ev.clientY - startY; const nh = Math.max(startH + dh, 140); if(cm){ cm.setSize(null, nh); } else { eb.style.height = nh+'px'; } localStorage.setItem('editorH', nh); }
      function stopDragH(){ document.body.style.userSelect=''; document.removeEventListener('mousemove', onDragH); document.removeEventListener('mouseup', stopDragH); }
      document.addEventListener('mousemove', onDragH); document.addEventListener('mouseup', stopDragH);
    }
  },
  restoreSizes(){ const sw = localStorage.getItem('sidebarW'); if(sw){ document.getElementById('sidebar').style.width = sw+'px'; } const eh = localStorage.getItem('editorH'); if(eh){ if(cm){ cm.setSize(null, parseInt(eh,10)); } else { document.querySelector('.editor textarea').style.height = eh+'px'; } } },
  disconnect(){
    // 모든 연결 해제 + 트리 강제 접기
    Object.keys(state.connStates).forEach(id=>{
      state.connStates[id]=false;
      if(typeof sessionMonitor!=='undefined' && sessionMonitor.onDisconnect){
        sessionMonitor.onDisconnect(id);
      }
    });
    state.connId=null; state.connected=false;
    resetTabUnderlineForConn(null);
    this.renderTabs();
    tree.updateConnBadges();
    tree.collapseAllConns();
    ui.refreshConnStatus();
    this.renderConnSelect();
    if(bottomTabs){
      bottomTabs.hideArea();
    }
  },

  // --- 접속 사유 / ITSM 연계 모달 ---
  openConnReasonModal(connId){
    const backdrop = document.getElementById('connReasonBackdrop');
    const metaEl   = document.getElementById('connReasonMeta');
    const reasonEl = document.getElementById('connReasonInput');
    const ticketEl = document.getElementById('connTicketInput');
    const userEl   = document.getElementById('connUserInput');
    const passEl   = document.getElementById('connPasswordInput');
    const mfaEl    = document.getElementById('connMfaInput');
    const mfaBtn   = document.getElementById('connMfaSendBtn');

    if(!backdrop || !metaEl || !reasonEl || !ticketEl){
      // DOM이 없으면 그냥 바로 활성화 (백업)
      this.setActiveConn(connId);
      return;
    }

    this._pendingConnId = connId;

    const label = getConnLabel(connId);
    metaEl.textContent = `연결: ${label || connId}`;

    // 접속 사유 / ITSM 번호는 매번 새로 입력받는다 (이전 값은 프리필하지 않음)
    const info = (state.connAccessInfo && state.connAccessInfo[connId]) || {};
    reasonEl.value = '';
    ticketEl.value = '';

    // 계정 입력값은 매번 초기화
    if(userEl) userEl.value = '';
    if(passEl) passEl.value = '';
    if(mfaEl){
      mfaEl.value = '';
      mfaEl.classList.add('hidden');
    }
    if(mfaBtn){
      mfaBtn.classList.remove('hidden');
    }

    backdrop.classList.add('show');
    backdrop.setAttribute('aria-hidden','false');

    setTimeout(()=>{ userEl ? userEl.focus() : reasonEl.focus(); }, 10);
  },
  closeConnReasonModal(){
    const backdrop = document.getElementById('connReasonBackdrop');
    if(backdrop){
      backdrop.classList.remove('show');
      backdrop.setAttribute('aria-hidden','true');
    }
  },
  cancelConnReason(){
    // 셀렉트에서 온 경우, 이전 값으로 롤백
    if(this._pendingConnSelectUsed){
      const sel = document.getElementById('connSelect');
      if(sel){
        sel.value = this._pendingConnSelectPrev || '';
      }
    }
    this._pendingConnId           = null;
    this._pendingConnSelectUsed   = false;
    this._pendingConnSelectPrev   = null;
    this._pendingConnAfterConnect = null;
    this.closeConnReasonModal();
  },
  confirmConnReason(){
    const connId   = this._pendingConnId;
    const userEl   = document.getElementById('connUserInput');
    const passEl   = document.getElementById('connPasswordInput');
    const mfaEl    = document.getElementById('connMfaInput');
    const reasonEl = document.getElementById('connReasonInput');
    const ticketEl = document.getElementById('connTicketInput');

    if(!connId || !reasonEl || !ticketEl || !userEl || !passEl){
      this.closeConnReasonModal();
      return;
    }

    const user   = userEl.value.trim();
    const pass   = passEl.value;
    const mfa    = mfaEl ? mfaEl.value.trim() : '';
    const reason = reasonEl.value.trim();
    const ticket = ticketEl.value.trim();

    if(!user){
      alert('DB 사용자 ID를 입력해 주세요.');
      userEl.focus();
      return;
    }
    if(!pass){
      alert('비밀번호를 입력해 주세요.');
      passEl.focus();
      return;
    }

    if(!reason){
      alert('접속 사유를 입력해 주세요.');
      reasonEl.focus();
      return;
    }

    if(ticket){
      // 공백, 과도한 길이 정도만 1차 체크 (세부 검증은 서버에서)
      if(/\s/.test(ticket)){
        alert('ITSM/작업요청 번호에는 공백을 포함할 수 없습니다.');
        ticketEl.focus();
        return;
      }
      if(ticket.length > 50){
        alert('ITSM/작업요청 번호는 50자 이내로 입력해 주세요.');
        ticketEl.focus();
        return;
      }
    }

    if(!state.connAccessInfo){
      state.connAccessInfo = {};
    }
    state.connAccessInfo[connId] = {
      reason,
      ticketId: ticket,
      activatedAt: new Date().toISOString()
    };

    // TODO: 여기에서 user/pass/mfa를 서버로 보내 실제 DB 연결을 수행하되,
    //       서버나 프론트 state에는 저장하지 않는 구조로 구현해야 함.

    // 실제 활성화
    this.setActiveConn(connId);

    // sql-editor 컨텍스트 메뉴에서 "연결 + 새 탭" 요청한 경우
    if(this._pendingConnAfterConnect === 'newTab'){
      this._pendingConnAfterConnect = null;
      this.newEditorTab();
      // 즐겨찾기(Shift+클릭 등)에서 대기 중인 SQL이 있다면 새 탭에 적용
      if (typeof favorites !== 'undefined' && typeof favorites._applyPendingFavoriteToNewTab === 'function') {
        try{
          favorites._applyPendingFavoriteToNewTab();
        }catch(e){
          console.warn('favorites._applyPendingFavoriteToNewTab error', e);
        }
      }
    }

    this._pendingConnId           = null;
    this._pendingConnSelectUsed   = false;
    this._pendingConnSelectPrev   = null;

    this.closeConnReasonModal();
  },

  
  testConnReason(){
    const userEl   = document.getElementById('connUserInput');
    const passEl   = document.getElementById('connPasswordInput');
    const mfaEl    = document.getElementById('connMfaInput');
    const reasonEl = document.getElementById('connReasonInput');

    if(!userEl || !passEl || !reasonEl){
      alert('연결 테스트에 필요한 입력 항목을 찾지 못했습니다.');
      return;
    }

    const user   = userEl.value.trim();
    const pass   = passEl.value;
    const mfa    = mfaEl ? mfaEl.value.trim() : '';
    const reason = reasonEl.value.trim();

    if(!user){
      alert('DB 사용자 ID를 입력해 주세요.');
      userEl.focus();
      return;
    }
    if(!pass){
      alert('비밀번호를 입력해 주세요.');
      passEl.focus();
      return;
    }
    if(!reason){
      alert('접속 사유를 입력해 주세요.');
      reasonEl.focus();
      return;
    }

    alert('연결 테스트는 추후 백엔드 연동 시 구현할 예정입니다.\n\n입력한 ID/PW/MFA는 서버로 전달만 하고 저장하지 않는 구조로 구현해 주세요.');
  },

  sendConnMfaCode(){
    const userEl = document.getElementById('connUserInput');
    const mfaEl  = document.getElementById('connMfaInput');
    const btn    = document.getElementById('connMfaSendBtn');

    if(!userEl || !userEl.value.trim()){
      alert('먼저 DB 사용자 ID를 입력해 주세요.');
      if(userEl) userEl.focus();
      return;
    }

    // 실제로는 여기서 서버를 통해 MFA 코드를 발송해야 함.
    if(btn){
      btn.classList.add('hidden');
    }
    if(mfaEl){
      mfaEl.classList.remove('hidden');
      mfaEl.focus();
    }

    alert('인증코드를 발송했습니다. 도착한 코드를 입력해 주세요.');
  },

openExportAuditModal(meta){
    const backdrop = document.getElementById('exportAuditBackdrop');
    const metaEl = document.getElementById('exportAuditMeta');
    const warnEl = document.getElementById('exportAuditWarning');
    const apprField = document.getElementById('exportApprovalField');
    const reasonEl = document.getElementById('exportReason');
    const apprEl = document.getElementById('exportApprovalId');

    window.__DBAM_EXPORT_META__ = meta || {};
    const rowCount = meta && typeof meta.rowCount === 'number' ? meta.rowCount : 0;
    const colCount = meta && meta.columns ? meta.columns.length : 0;
    const connLabel = meta && meta.connLabel ? meta.connLabel : (meta && meta.connId ? meta.connId : '(미지정)');
    const ts = new Date().toLocaleString();

    metaEl.textContent =
      `접속: ${connLabel}  |  행 수: ${rowCount.toLocaleString()}  |  컬럼 수: ${colCount}  |  시각: ${ts}`;

    reasonEl.value = '';
    apprEl.value = '';

    const EXPORT_LIMIT_ROWS = 50000;
    if (rowCount >= EXPORT_LIMIT_ROWS) {
      warnEl.style.display = 'block';
      warnEl.textContent =
        `주의: ${EXPORT_LIMIT_ROWS.toLocaleString()}행 이상 대용량 반출입니다. 관리자 승인 후 진행해 주세요.`;
      apprField.style.display = 'block';
    } else {
      warnEl.style.display = 'none';
      warnEl.textContent = '';
      apprField.style.display = 'none';
    }

    backdrop.classList.add('show');
    backdrop.setAttribute('aria-hidden','false');
    setTimeout(()=>{ reasonEl.focus(); }, 10);
  },
  closeExportAuditModal(){
    const backdrop = document.getElementById('exportAuditBackdrop');
    if(backdrop){
      backdrop.classList.remove('show');
      backdrop.setAttribute('aria-hidden','true');
    }
    window.__DBAM_EXPORT_META__ = null;
  },
  confirmExportAudit(){
    const meta = window.__DBAM_EXPORT_META__ || {};
    const reasonEl = document.getElementById('exportReason');
    const apprEl = document.getElementById('exportApprovalId');
    if(!reasonEl) return;
    const reason = reasonEl.value.trim();
    const apprId = apprEl ? apprEl.value.trim() : '';

    if(!reason){
      alert('반출 사유를 입력해 주세요.');
      reasonEl.focus();
      return;
    }

    const rowCount = typeof meta.rowCount === 'number' ? meta.rowCount : 0;
    const EXPORT_LIMIT_ROWS = 50000;

    if(rowCount >= EXPORT_LIMIT_ROWS){
      if(!apprId){
        alert('대용량 반출입니다. 관리자 승인 ID를 입력해 주세요.');
        apprEl && apprEl.focus();
        return;
      }
      const again = confirm(`${EXPORT_LIMIT_ROWS.toLocaleString()}행 이상 결과를 내보내려 합니다. 계속하시겠습니까?`);
      if(!again){
        return;
      }
    }

    this.closeExportAuditModal();

    try{
      actions._sendExportAuditLog({
        reason,
        approvalId: apprId,
        rowCount,
        columns: meta.columns || [],
        sql: meta.sql || '',
        connId: meta.connId || null,
        connLabel: meta.connLabel || null
      });
    }catch(e){
      console.warn('export audit log error', e);
    }

    try{
      actions._doExportExcel();
    }catch(e){
      console.error('export error', e);
      alert('Excel 내보내기 중 오류가 발생했습니다.');
    }
  },
  openMyInfoModal(){
    try{
      var backdrop = document.getElementById('myInfoBackdrop');
      if(!backdrop) return;
      backdrop.classList.add('show');
      backdrop.setAttribute('aria-hidden','false');
    }catch(e){}
  },
  closeMyInfoModal(){
    try{
      var backdrop = document.getElementById('myInfoBackdrop');
      if(!backdrop) return;
      backdrop.classList.remove('show');
      backdrop.setAttribute('aria-hidden','true');
    }catch(e){}
  }
};


function openFavSaveModalFromSql(sql){
  try{
    const el = document.getElementById('favSaveBackdrop');
    if(!el){
      alert('즐겨찾기/템플릿 저장 모달 DOM을 찾지 못했습니다.');
      return;
    }
    if(!sql || !String(sql).trim()){
      alert('저장할 SQL이 없습니다.');
      return;
    }

    // 모드: 신규 저장
    if(typeof ui !== 'undefined' && ui){
      ui.favSaveMode = 'new';
      ui.favSaveEditType = null;
      ui.favSaveEditId = null;
    }

    // 저장 대상 라디오 초기화 (개인/공용 선택 가능)
    const typePersonal = el.querySelector('input[name="favSaveType"][value="PERSONAL"]');
    const typeOrg = el.querySelector('input[name="favSaveType"][value="ORG"]');
    if(typePersonal){
      typePersonal.disabled = false;
      typePersonal.checked = true;
    }
    if(typeOrg){
      typeOrg.disabled = false;
      typeOrg.checked = false;
    }

    const firstLine = (String(sql).split(/\r?\n/)[0] || '').trim();
    const titleInput = el.querySelector('#favSaveName');
    if(titleInput){
      titleInput.value = firstLine.slice(0, 60);
    }

    const descEl = el.querySelector('#favSaveDesc');
    if(descEl){
      descEl.value = '';
    }

    const catSel = el.querySelector('#favSaveCategory');
    if(catSel){
      catSel.value = 'ETC';
    }
    const bizSel = el.querySelector('#favSaveBiz');
    if(bizSel){
      bizSel.value = 'COMMON';
    }

    const connId = (typeof state !== 'undefined' && state && state.connId) ? state.connId : '';
    const targetSysSel = el.querySelector('#favSaveTargetSys');
    const targetDbInput = el.querySelector('#favSaveTargetDb');
    if(connId){
      const parts = String(connId).split('_');
      const sysCode = (parts[0] || '').toUpperCase();
      if(targetSysSel){
        const hasOption = Array.prototype.some.call(targetSysSel.options, function(opt){ return opt.value === sysCode; });
        targetSysSel.value = hasOption ? sysCode : '';
      }
      if(targetDbInput){
        targetDbInput.value = connId;
      }
    }else{
      if(targetSysSel){ targetSysSel.value = ''; }
      if(targetDbInput){ targetDbInput.value = ''; }
    }

    const tagsInput = el.querySelector('#favSaveTags');
    if(tagsInput){
      tagsInput.value = '';
    }

    const sqlPreview = el.querySelector('#favSaveSqlPreview');
    if(sqlPreview){
      sqlPreview.value = String(sql);
    }

    if(typeof ui !== 'undefined' && ui && typeof ui._syncFavSaveTypeUI === 'function'){
      ui._syncFavSaveTypeUI();
    }

    el.classList.remove('hidden');
    el.classList.add('show');
    el.setAttribute('aria-hidden','false');

    const first = el.querySelector('input, select, textarea, button');
    if(first){ first.focus(); }
  }catch(e){
    console.warn('openFavSaveModalFromSql error', e);
  }
}




/* ---------------- Context Menu ---------------- */
function hideAllCtxMenus(){
  try{ if(typeof ctxMenu !== 'undefined' && ctxMenu.hide) ctxMenu.hide(); }catch(e){}
  try{ if(typeof treeCtx !== 'undefined' && treeCtx.hide) treeCtx.hide(); }catch(e){}
  try{ if(typeof editorCtx !== 'undefined' && editorCtx.hide) editorCtx.hide(); }catch(e){}
  try{ if(typeof tabCtx !== 'undefined' && tabCtx.hide) tabCtx.hide(); }catch(e){}
  try{ if(typeof resultCtx !== 'undefined' && resultCtx.hide) resultCtx.hide(); }catch(e){}
  try{ if(typeof historyCtx !== 'undefined' && historyCtx.hide) historyCtx.hide(); }catch(e){}
  try{ if(typeof favCtx !== 'undefined' && favCtx.hide) favCtx.hide(); }catch(e){}
}

const ctxMenu = {
  el: document.getElementById('ctxMenu'),
  targetConn: null,
  open(x, y, connId){
    try{
      hideAllCtxMenus();
    }catch(e){}
    this.targetConn = connId || null;
    if (!this.el) return;

    // 연결 중인 DB는 이름 변경 비활성화
    try{
      const renameItem = this.el.querySelector('li[data-act="rename-conn"]');
      const isOn = !!(connId && typeof state !== 'undefined' && state && state.connStates && state.connStates[connId]);
      if (renameItem){
        if (isOn){
          renameItem.classList.add('disabled');
          renameItem.setAttribute('aria-disabled','true');
        } else {
          renameItem.classList.remove('disabled');
          renameItem.removeAttribute('aria-disabled');
        }
      }
    }catch(e){
      console.warn('ctxMenu.open: rename-conn disable check error', e);
    }

    try{
      this.el.style.left = (x || 0) + 'px';
      this.el.style.top = (y || 0) + 'px';
    }catch(e){}

    this.el.classList.remove('hidden');
    this.el.setAttribute('aria-hidden','false');
  },
  hide(){
    if (!this.el) return;
    this.el.classList.add('hidden');
    this.el.setAttribute('aria-hidden','true');
    this.targetConn = null;
  }
};

// ---------------- DB Tree Filter helpers ----------------
function showDbFilterTag(connId){
  try{
    const li = document.querySelector(`#dbTree li[data-conn-id="${connId}"]`);
    if(!li) return;
    const nodeEl = li.querySelector(':scope > .node');
    if(!nodeEl) return;

    let tag = nodeEl.querySelector('.dbfilter-tag');
    if(!tag){
      tag = document.createElement('span');
      tag.className = 'dbfilter-tag';
      tag.textContent = '(필터링됨)';
      nodeEl.appendChild(tag);
    }
  }catch(e){
    console.warn('showDbFilterTag error', e);
  }
}

function hideDbFilterTag(connId){
  try{
    const li = document.querySelector(`#dbTree li[data-conn-id="${connId}"]`);
    if(!li) return;
    const nodeEl = li.querySelector(':scope > .node');
    if(!nodeEl) return;
    const tag = nodeEl.querySelector('.dbfilter-tag');
    if(tag){
      tag.remove();
    }
  }catch(e){
    console.warn('hideDbFilterTag error', e);
  }
}

function applyDbFilter(connId, keyword){
  try{
    const rootLi = document.querySelector(`#dbTree li[data-conn-id="${connId}"]`);
    if(!rootLi) return;
    const kw = (keyword || '').toLowerCase();

    // 루트 제외 모든 자식 숨김
    const allLis = rootLi.querySelectorAll('li');
    allLis.forEach(li=>{
      if(li !== rootLi){
        li.classList.add('dbfilter-hidden');
      }
    });

    // label에 kw 포함되는 노드 표시 + 조상도 표시
    allLis.forEach(li=>{
      const label = (li.dataset && li.dataset.label ? li.dataset.label : '').toLowerCase();
      if(label && kw && label.indexOf(kw) !== -1){
        li.classList.remove('dbfilter-hidden');
        let p = li.parentElement;
        while(p && p !== rootLi.parentElement){
          if(p.tagName === 'LI'){
            p.classList.remove('dbfilter-hidden');
          }
          p = p.parentElement;
        }
      }
    });

    // 루트는 항상 보이게
    rootLi.classList.remove('dbfilter-hidden');

    // 필터 태그 표시
    showDbFilterTag(connId);
  }catch(e){
    console.warn('applyDbFilter error', e);
  }
}

function clearDbFilter(connId){
  try{
    if(state.connFilters && state.connFilters[connId]){
      delete state.connFilters[connId];
    }
    const rootLi = document.querySelector(`#dbTree li[data-conn-id="${connId}"]`);
    if(!rootLi) return;
    const allLis = rootLi.querySelectorAll('li');
    allLis.forEach(li=>{
      li.classList.remove('dbfilter-hidden');
    });
    hideDbFilterTag(connId);
  }catch(e){
    console.warn('clearDbFilter error', e);
  }
}

// ---------------- DB Filter Modal Controller ----------------
const dbFilterModal = {
  targetConnId: null,
  open(connId){
    this.targetConnId = connId;
    const backdrop = document.getElementById('dbFilterBackdrop');
    const labelEl  = document.getElementById('dbFilterTargetLabel');
    const inputEl  = document.getElementById('dbFilterInput');
    if(!backdrop || !inputEl) return;

    let label = connId || '';
    try{
      const conns = state.availableConns || [];
      const found = conns.find(c => c.id === connId);
      if(found){
        label = found.label || found.id || label;
      }
    }catch(e){}

    if(labelEl){
      labelEl.textContent = label;
    }

    // 기존 필터 값 로딩
    const prev = state.connFilters && state.connFilters[connId];
    inputEl.value = (prev && prev.keyword) ? prev.keyword : '';

    backdrop.classList.remove('hidden');
    backdrop.classList.add('show');
    backdrop.setAttribute('aria-hidden','false');

    setTimeout(()=>{
      try{
        inputEl.focus();
        inputEl.select();
      }catch(e){}
    }, 10);
  },
  close(){
    const backdrop = document.getElementById('dbFilterBackdrop');
    if(!backdrop) return;
    backdrop.classList.remove('show');
    backdrop.classList.add('hidden');
    backdrop.setAttribute('aria-hidden','true');
    this.targetConnId = null;
  },
  apply(){
    const connId = this.targetConnId;
    const inputEl = document.getElementById('dbFilterInput');
    if(!connId || !inputEl){
      this.close();
      return;
    }
    const keyword = inputEl.value.trim();
    if(!keyword){
      clearDbFilter(connId);
      this.close();
      return;
    }
    if(!state.connFilters){ state.connFilters = {}; }
    state.connFilters[connId] = { keyword };
    applyDbFilter(connId, keyword);
    this.close();
  },
  clear(){
    const connId = this.targetConnId;
    if(connId){
      clearDbFilter(connId);
    }
    this.close();
  }
};

(function initDbFilterModal(){
  const backdrop = document.getElementById('dbFilterBackdrop');
  if(!backdrop) return;

  const cancelBtn = document.getElementById('dbFilterCancelBtn');
  const applyBtn  = document.getElementById('dbFilterApplyBtn');
  const closeBtn  = document.getElementById('dbFilterCloseBtn');

  cancelBtn && cancelBtn.addEventListener('click', ()=> dbFilterModal.close());
  applyBtn  && applyBtn.addEventListener('click', ()=> dbFilterModal.apply());
  closeBtn  && closeBtn.addEventListener('click', ()=> dbFilterModal.close());

  backdrop.addEventListener('click', (e)=>{
    if(e.target === backdrop){
      dbFilterModal.close();
    }
  });

  // ESC 로 닫기
  window.addEventListener('keydown', (e)=>{
    if(e.key === 'Escape'){
      const back = document.getElementById('dbFilterBackdrop');
      if(back && back.classList.contains('show')){
        // DB 필터 모달이 열려 있을 때는 이 핸들러에서만 처리하고,
        // 다른 ESC 핸들러로 이벤트가 전달되지 않도록 막는다.
        e.preventDefault();
        e.stopPropagation();
        dbFilterModal.close();
      }
    }
  }, true);
})();

// override ctxMenu.open to handle connected/disconnected state (disable connect when already connected)
ctxMenu.open = function(x, y, connId){
  hideAllCtxMenus();
  this.targetConn = connId;
  const el = this.el;
  if(!el) return;

  const isOn = !!(state.connStates && state.connStates[connId]);

  // enable/disable 메뉴 항목
  const connectLi    = el.querySelector('li[data-act="connect"]');
  const reconnectLi  = el.querySelector('li[data-act="reconnect"]');
  const disconnectLi = el.querySelector('li[data-act="disconnect"]');

  if(connectLi){
    connectLi.classList.toggle('disabled', isOn);
    if(isOn){
      connectLi.setAttribute('aria-disabled','true');
    }else{
      connectLi.removeAttribute('aria-disabled');
    }
  }

  // 재접속: 연결된 상태에서만 활성
  if(reconnectLi){
    const off = !isOn;
    reconnectLi.classList.toggle('disabled', off);
    if(off){
      reconnectLi.setAttribute('aria-disabled','true');
    }else{
      reconnectLi.removeAttribute('aria-disabled');
    }
  }

  if(disconnectLi){
    const off = !isOn;
    disconnectLi.classList.toggle('disabled', off);
    if(off){
      disconnectLi.setAttribute('aria-disabled','true');
    }else{
      disconnectLi.removeAttribute('aria-disabled');
    }
  }

  // 이름 변경: 연결된 DB에서는 비활성
  const renameLi = el.querySelector('li[data-act="rename-conn"]');
  if (renameLi) {
    if (isOn) {
      renameLi.classList.add('disabled');
      renameLi.setAttribute('aria-disabled','true');
    } else {
      renameLi.classList.remove('disabled');
      renameLi.removeAttribute('aria-disabled');
    }
  }

  
  // 삭제: 연결된 DB에서는 비활성
  const deleteLi = el.querySelector('li[data-act="delete-conn"]');
  if (deleteLi) {
    if (isOn) {
      deleteLi.classList.add('disabled');
      deleteLi.setAttribute('aria-disabled','true');
    } else {
      deleteLi.classList.remove('disabled');
      deleteLi.removeAttribute('aria-disabled');
    }
  }

// DB 필터 메뉴 활성/비활성
  const filterLi      = el.querySelector('li[data-act="db-filter"]');
  const filterClearLi = el.querySelector('li[data-act="db-filter-clear"]');
  const hasFilter = !!(state.connFilters && state.connFilters[connId]);

  // 필터 적용: 연결된 상태에서만 활성
  if (filterLi) {
    const off = !isOn;
    filterLi.classList.toggle('disabled', off);
    if (off) {
      filterLi.setAttribute('aria-disabled','true');
    } else {
      filterLi.removeAttribute('aria-disabled');
    }
  }

  if(filterClearLi){
    // 필터가 적용된 경우에만 메뉴를 노출
    if(hasFilter){
      filterClearLi.style.display = '';
    }else{
      filterClearLi.style.display = 'none';
    }
  }





  // 하위 모두 펼치기 / 하위 모두 접기: 연결된 DB에서만 노출
  const expandAllLi   = el.querySelector('li[data-act="conn-expand-all"]');
  const collapseAllLi = el.querySelector('li[data-act="conn-collapse-all"]');
  if (expandAllLi && collapseAllLi) {
    if (isOn && connId) {
      // 연결된 DB이면 메뉴 노출
      expandAllLi.style.display   = '';
      collapseAllLi.style.display = '';
    } else {
      // 연결 안 된 상태이거나 connId 없으면 메뉴 숨김
      expandAllLi.style.display   = 'none';
      collapseAllLi.style.display = 'none';
    }
  }

  el.style.left = x + 'px';
  el.style.top  = y + 'px';
  el.classList.remove('hidden');
  el.setAttribute('aria-hidden', 'false');
};
ctxMenu.el.addEventListener('click', (e)=>{
  const li = e.target.closest('li');
  if(!li) return;
  // aria-disabled 또는 disabled class가 있으면 동작하지 않음
  if (li.classList.contains('disabled') || li.getAttribute('aria-disabled') === 'true') return;
  const act = li.getAttribute('data-act');
  if(!act) return;
  const id = ctxMenu.targetConn; if(!id) return;

  switch(act){
    case 'connect':
      ui._pendingConnSelectUsed   = false;
      ui._pendingConnAfterConnect = null;
      ui.openConnReasonModal(id);
      break;
    case 'reconnect':
      ui._pendingConnSelectUsed   = false;
      ui._pendingConnAfterConnect = null;
      // 재접속: 기존에 가지고 있던 정보로 즉시 연결 (접속 사유/계정 입력 모달은 띄우지 않음)
      if (typeof ui.setActiveConn === 'function') {
        ui.setActiveConn(id);
      } else {
        console.warn('reconnect: ui.setActiveConn is not available');
      }
      break;
    case 'disconnect':
      state.connStates[id] = false;
      if(state.connId===id){ state.connId=null; }
      resetTabUnderlineForConn(id);
      ui.renderTabs(); ui.refreshConnStatus(); tree.updateConnBadges(); tree.collapseConn(id);
      break;
    case 'sql-editor':
      ui._pendingConnSelectUsed   = false;
      ui._pendingConnAfterConnect = 'newTab';
      // 이미 사유가 등록된 활성 연결이면 모달을 다시 띄우지 않고 바로 새 탭을 연다.
      const info = (state.connAccessInfo && state.connAccessInfo[id]) || null;
      const isActive = !!(state.connStates && state.connStates[id]);
      if (info && info.reason && isActive) {
        ui.setActiveConn(id);
        ui._pendingConnAfterConnect = null;
        ui.newEditorTab();
      } else {
        ui.openConnReasonModal(id);
      }
      break;
    case 'settings':
      if (typeof connSettings !== 'undefined' && connSettings.open) {
        connSettings.open(id);
      }
      break;
    case 'conn-expand-all':
      (function(){
        const liConn = document.querySelector('#dbTree li[data-conn-id="' + id + '"]');
        if (liConn && typeof tree !== 'undefined' && tree && typeof tree.toggleRecursive === 'function') {
          tree.toggleRecursive(liConn, true);
        }
      })();
      break;
    case 'conn-collapse-all':
      (function(){
        const liConn = document.querySelector('#dbTree li[data-conn-id="' + id + '"]');
        if (liConn && typeof tree !== 'undefined' && tree && typeof tree.toggleRecursive === 'function') {
          tree.toggleRecursive(liConn, false);
        }
      })();
      break;
    case 'db-filter':
      if (id && typeof dbFilterModal !== 'undefined') {
        dbFilterModal.open(id);
      }
      break;
    case 'db-filter-clear':
      if (id) {
        clearDbFilter(id);
      }
      break;
case 'copy-conn': {
      try{
        let label = id;
        if (typeof state !== 'undefined' && state && Array.isArray(state.availableConns)) {
          const found = state.availableConns.find(c => c.id === id);
          if (found && found.label) {
            label = found.label;
          }
        }
        if (typeof dbTreeClipboard !== 'undefined') {
          dbTreeClipboard.type  = 'db';
          dbTreeClipboard.connId = id;
          dbTreeClipboard.label = label;
          dbTreeClipboard.folderLi = null;
        }
      }catch(e){
        console.warn('copy-conn clipboard error', e);
      }
      break;
    }
    case 'paste-conn':
      alert('연결 붙여넣기 기능은 추후 구현 예정입니다.');
      break;
        case 'delete-conn': {
      try{
        const connId = id;

        // 1) 현재 선택된 DB 노드를 우선적으로 삭제 대상으로 사용
        let liConn = null;
        const selNode = document.querySelector('#dbTree .node.dbtree-selected');
        if (selNode) {
          const selLi = selNode.closest('li[data-conn-id]');
          if (selLi && selLi.dataset.connId === connId) {
            liConn = selLi;
          }
        }

        // 2) 선택 정보가 없으면 기존 방식대로 첫 번째 노드 사용 (호환용)
        if (!liConn && typeof tree !== 'undefined' && tree && typeof tree.getConnLi === 'function') {
          liConn = tree.getConnLi(connId);
        }

        let label = connId;
        if(liConn){
          const node = liConn.querySelector(':scope > .node');
          const labelSpan =
            (node && node.querySelector('span:nth-of-type(3)')) ||
            (node && node.querySelector('span:nth-of-type(2)'));
          if(labelSpan && labelSpan.textContent){
            label = labelSpan.textContent.trim();
          }
        }

        const msg = `'${label}' 연결을 목록에서 삭제하시겠습니까?`;
        if(!window.confirm(msg)) break;

        // 3) 트리에서 현재 선택(또는 첫 번째) 노드 제거
        if(liConn && liConn.parentElement){
          liConn.parentElement.removeChild(liConn);
        }

        // 4) 같은 connId를 가진 DB 노드가 아직 남아 있는지 확인
        const hasSameConnNode = Array.from(
          document.querySelectorAll('#dbTree li[data-conn-id]')
        ).some(li => li.dataset.connId === connId);

        // 5) 더 이상 이 connId를 가진 노드가 없을 때만 state에서 제거
        if(typeof state !== 'undefined' && state && !hasSameConnNode){
          if(Array.isArray(state.availableConns)){
            state.availableConns = state.availableConns.filter(c => c.id !== connId);
          }
          if(Array.isArray(state.pinnedConnIds)){
            state.pinnedConnIds = state.pinnedConnIds.filter(c => c !== connId);
          }
          if(state.connStates && Object.prototype.hasOwnProperty.call(state.connStates, connId)){
            delete state.connStates[connId];
          }
          if(state.connProfiles && Object.prototype.hasOwnProperty.call(state.connProfiles, connId)){
            delete state.connProfiles[connId];
          }
          if(state.connId === connId){
            state.connId = null;
          }
        }

        if(typeof ui !== 'undefined' && ui){
          if(typeof ui.renderTabs === 'function') ui.renderTabs();
          if(typeof ui.refreshConnStatus === 'function') ui.refreshConnStatus();
        }
        if(typeof tree !== 'undefined' && tree && typeof tree.updateConnBadges === 'function'){
          tree.updateConnBadges();
        }
      }catch(e){
        console.warn('delete-conn error', e);
      }
      break;
    }
    case 'rename-conn': {
      try{
        const connId = id;
        let liConn = null;

        // 1) 현재 선택된 DB 노드가 있으면 우선 사용
        const selNode = document.querySelector('#dbTree .node.dbtree-selected');
        if (selNode) {
          const selLi = selNode.closest('li[data-conn-id]');
          if (selLi && selLi.dataset.connId === connId) {
            liConn = selLi;
          }
        }

        // 2) 선택 정보가 없거나 connId가 다르면 기존 방식대로 첫 번째 노드 사용
        if (!liConn && typeof tree !== 'undefined' && tree && typeof tree.getConnLi === 'function') {
          liConn = tree.getConnLi(connId);
        }

        if(!liConn) break;
        if (typeof dbFolderUi !== 'undefined' && dbFolderUi && typeof dbFolderUi.startDbLabelEdit === 'function') {
          dbFolderUi.startDbLabelEdit(liConn);
        } else if (typeof startDbLabelEdit === 'function') {
          startDbLabelEdit(liConn);
        }
      }catch(e){
        console.warn('rename-conn error', e);
      }
      break;
    }
    case 'refresh':
      tree.updateConnBadges();
      alert('연결 새로고침(예시: 상태 배지 갱신) 완료.');
      break;
    default:
      break;
  }

  ctxMenu.hide();
});
window.addEventListener('click', (e)=>{ if(!ctxMenu.el.contains(e.target)) ctxMenu.hide(); });
window.addEventListener('scroll', ()=> ctxMenu.hide(), true);

// ---------------- Tree Object Context Menu ----------------
let dbTreeClipboard = {
  type: null,
  label: '',
  connId: null,
  folderLi: null
};


const dbamStub = (label)=>{
  alert('[미구현] ' + label + ' 기능은 이후 구현 예정입니다.');
};

const treeCtxConfig = {
  _default: [
    { act: 'refresh-node', label: '새로고침', icon: 'fa-solid fa-rotate' }
  ],
  'dbtree-empty': [
    { act: 'dbtree-create-db',     label: 'Database 생성', icon: 'fa-solid fa-database' },
    { act: 'dbtree-create-folder', label: '폴더 생성',     icon: 'fa-regular fa-folder' },
    { act: 'dbtree-paste',         label: '붙여넣기 (Ctrl + V)',     icon: 'fa-solid fa-clipboard' }
  ],
  'folder': [
    { act: 'folder-add',    label: '폴더 추가',                 icon: 'fa-regular fa-folder-open' },
    { act: 'folder-rename', label: '폴더 이름변경 (F2)',        icon: 'fa-solid fa-pen-to-square' },
    { act: 'folder-copy',   label: '폴더 복사 (Ctrl + C)',      icon: 'fa-regular fa-copy' },
    { act: 'folder-paste',  label: '붙여넣기 (Ctrl + V)',       icon: 'fa-solid fa-clipboard' },
    { act: 'folder-delete', label: '폴더 삭제 (Delete)',        icon: 'fa-solid fa-trash' },
    { act: 'refresh-node',  label: '새로고침 (Alt + R)',        icon: 'fa-solid fa-rotate' }
  ],
  'tables-folder': [
    { act: 'tables-new',       label: '새 테이블 생성…',        icon: 'fa-solid fa-table' },
    { act: 'tables-erd',       label: 'ERD 보기(스키마)',       icon: 'fa-solid fa-project-diagram' },
    { act: 'refresh-node',     label: '새로고침',              icon: 'fa-solid fa-rotate' }
  ],
  'table': [
    { act: 'table-edit',       label: '테이블 편집',            icon: 'fa-solid fa-gears' },
    { act: 'table-view-data',  label: '데이터 조회',            icon: 'fa-solid fa-table-cells' },
    { act: 'table-edit-data',  label: '데이터 편집(미구현)',    icon: 'fa-solid fa-pen-to-square' },
    { act: 'table-export',     label: 'Export Data…',          icon: 'fa-solid fa-file-export' },
    { act: 'table-import',     label: 'Import Data…',          icon: 'fa-solid fa-file-import' },
    { act: 'table-truncate',   label: 'Truncate Table',        icon: 'fa-solid fa-broom' },
    { act: 'table-ddl',        label: 'DDL 보기',              icon: 'fa-solid fa-scroll' },
    { act: 'table-grants',     label: '권한 보기/변경',        icon: 'fa-solid fa-user-shield' },
    { act: 'table-stats',      label: '통계/분석 정보',        icon: 'fa-solid fa-chart-column' },
    { act: 'table-gen-select', label: 'Generate SQL → SELECT', icon: 'fa-solid fa-code' },
    { act: 'table-gen-insert', label: 'Generate SQL → INSERT', icon: 'fa-solid fa-code' },
    { act: 'table-gen-update', label: 'Generate SQL → UPDATE', icon: 'fa-solid fa-code' },
    { act: 'table-gen-delete', label: 'Generate SQL → DELETE', icon: 'fa-solid fa-code' },
    { act: 'table-copy-name',  label: '테이블 이름 복사',        icon: 'fa-solid fa-copy' }
  ],
  'views-folder': [
    { act: 'view-new',      label: '새 뷰 생성…',       icon: 'fa-regular fa-eye' },
    { act: 'refresh-node',  label: '새로고침',          icon: 'fa-solid fa-rotate' }
  ],
  'view': [
    { act: 'view-open',     label: '뷰 열기',                    icon: 'fa-regular fa-eye' },
    { act: 'view-compile',  label: '뷰 컴파일',                  icon: 'fa-solid fa-hammer' },
    { act: 'view-ddl',      label: 'DDL 보기',                   icon: 'fa-solid fa-scroll' },
    { act: 'view-drop',     label: '뷰 삭제(DROP VIEW)',         icon: 'fa-solid fa-trash' },
    { act: 'view-gen-sql',  label: 'Generate SQL',               icon: 'fa-solid fa-code' }
  ],
  'functions-folder': [
    { act: 'func-new',      label: '새 함수 생성…',              icon: 'fa-solid fa-code' },
    { act: 'refresh-node',  label: '새로고침',                   icon: 'fa-solid fa-rotate' }
  ],
  'func': [
    { act: 'func-open',     label: '함수 열기',                  icon: 'fa-solid fa-code' },
    { act: 'func-compile',  label: '컴파일',                    icon: 'fa-solid fa-hammer' },
    { act: 'func-exec',     label: 'Execute…',                  icon: 'fa-solid fa-play' },
    { act: 'func-ddl',      label: 'DDL 보기',                  icon: 'fa-solid fa-scroll' },
    { act: 'func-drop',     label: '함수 삭제(DROP FUNCTION)',  icon: 'fa-solid fa-trash' }
  ],
  'procs-folder': [
    { act: 'proc-new',      label: '새 프로시저 생성…', icon: 'fa-solid fa-code' },
    { act: 'refresh-node',  label: '새로고침',          icon: 'fa-solid fa-rotate' }
  ],
  'proc': [
    { act: 'proc-open',     label: '프로시저 열기',                      icon: 'fa-solid fa-code' },
    { act: 'proc-compile',  label: '컴파일',                            icon: 'fa-solid fa-hammer' },
    { act: 'proc-exec',     label: '실행(Execute…)',                    icon: 'fa-solid fa-play' },
    { act: 'proc-ddl',      label: 'DDL 보기',                          icon: 'fa-solid fa-scroll' },
    { act: 'proc-drop',     label: '프로시저 삭제(DROP PROCEDURE)',     icon: 'fa-solid fa-trash' }
  ],
  'sequences-folder': [
    { act: 'refresh-node', label: '새로고침', icon: 'fa-solid fa-rotate' }
  ],
  'seq': [
    { act: 'seq-preview', label: '값 미리 보기',                icon: 'fa-solid fa-hashtag' },
    { act: 'seq-config',  label: '시퀀스 설정 보기/수정',       icon: 'fa-solid fa-sliders' },
    { act: 'seq-ddl',     label: 'DDL 보기',                    icon: 'fa-solid fa-scroll' }
  ],
  'table-cols': [
    { act: 'cols-add',    label: '새 컬럼 추가…', icon: 'fa-solid fa-plus' },
    { act: 'refresh-node', label: '새로고침',   icon: 'fa-solid fa-rotate' }
  ],
  'column': [
    { act: 'col-edit',    label: '컬럼 편집',     icon: 'fa-solid fa-pen-to-square' },
    { act: 'col-gen-alter', label: 'Generate SQL → ALTER', icon: 'fa-solid fa-code' },
    { act: 'col-drop',    label: '컬럼 삭제',     icon: 'fa-solid fa-trash' }
  ],
  'table-fks': [
    { act: 'fk-add',      label: '새 외래키 생성…', icon: 'fa-solid fa-link' },
    { act: 'refresh-node', label: '새로고침',     icon: 'fa-solid fa-rotate' }
  ],

  'fk': [
    { act: 'fk-edit',     label: 'FK 편집',                 icon: 'fa-solid fa-pen-to-square' },
    { act: 'fk-goto',     label: '참조 테이블로 이동',      icon: 'fa-solid fa-up-right-from-square' },
    { act: 'fk-ddl',      label: 'Generate SQL → ADD/DROP', icon: 'fa-solid fa-code' }
  ],
  'synonyms-folder': [
    { act: 'synonym-new',   label: '새 Synonym 생성…',                icon: 'fa-solid fa-link' },
    { act: 'refresh-node',  label: '새로고침',                        icon: 'fa-solid fa-rotate' }
  ],
  'synonym': [
    { act: 'synonym-ddl',   label: 'DDL 보기',                        icon: 'fa-solid fa-scroll' },
    { act: 'synonym-drop',  label: 'Synonym 삭제(DROP SYNONYM)',     icon: 'fa-solid fa-trash' }
  ],
  'packages-folder': [
    { act: 'package-new',    label: '새 패키지 생성…',                icon: 'fa-solid fa-box-archive' },
    { act: 'refresh-node',   label: '새로고침',                       icon: 'fa-solid fa-rotate' }
  ],
  'package': [
    { act: 'package-open',    label: '패키지 열기',                   icon: 'fa-solid fa-box-archive' },
    { act: 'package-compile', label: '컴파일',                        icon: 'fa-solid fa-hammer' },
    { act: 'package-ddl',     label: 'DDL 보기',                      icon: 'fa-solid fa-scroll' },
    { act: 'package-drop',    label: '패키지 삭제(DROP PACKAGE)',    icon: 'fa-solid fa-trash' }
  ],
  'triggers-folder': [
    { act: 'trigger-new',   label: '새 트리거 생성…',                icon: 'fa-solid fa-bolt' },
    { act: 'refresh-node',  label: '새로고침',                        icon: 'fa-solid fa-rotate' }
  ],
  'table-triggers': [
    { act: 'trigger-new',   label: '새 트리거 생성…',                icon: 'fa-solid fa-bolt' },
    { act: 'refresh-node',  label: '새로고침',                        icon: 'fa-solid fa-rotate' }
  ],
  'trigger': [
    { act: 'trigger-ddl',   label: 'DDL 보기',                        icon: 'fa-solid fa-scroll' },
    { act: 'trigger-drop',  label: '트리거 삭제(DROP TRIGGER)',      icon: 'fa-solid fa-trash' }
  ],
  'db-links-folder': [
    { act: 'dblink-new',    label: '새 DB Link 생성…',               icon: 'fa-solid fa-link' },
    { act: 'refresh-node',  label: '새로고침',                        icon: 'fa-solid fa-rotate' }
  ],
  'dblink': [
    { act: 'dblink-test',   label: '연결 테스트',                     icon: 'fa-solid fa-plug-circle-check' },
    { act: 'dblink-ddl',    label: 'DDL 보기',                        icon: 'fa-solid fa-scroll' },
    { act: 'dblink-drop',   label: 'DB Link 삭제(DROP DATABASE LINK)', icon: 'fa-solid fa-trash' }
  ],
  'jobs-folder': [
    { act: 'job-new',       label: '새 Job 생성…',                    icon: 'fa-solid fa-clock-rotate-left' },
    { act: 'refresh-node',  label: '새로고침',                        icon: 'fa-solid fa-rotate' }
  ],
  'job': [
    { act: 'job-open',      label: 'Job 조회/수정',                    icon: 'fa-solid fa-pen-to-square' },
    { act: 'job-run',       label: 'Job 실행',                        icon: 'fa-solid fa-play' },
    { act: 'job-stop',      label: 'Job 중지',                        icon: 'fa-solid fa-stop' },
    { act: 'job-ddl',       label: 'DDL 보기',                        icon: 'fa-solid fa-scroll' },
    { act: 'job-drop',      label: 'Job 삭제',                        icon: 'fa-solid fa-trash' }
  ],
  'java-folder': [
    { act: 'refresh-node',  label: '새로고침',                        icon: 'fa-solid fa-rotate' }
  ],
  'java': [
    { act: 'java-open',     label: 'Java 클래스 정보 조회',           icon: 'fa-solid fa-circle-info' },
    { act: 'java-source',   label: '소스 보기',                       icon: 'fa-solid fa-file-code' },
    { act: 'java-drop',     label: 'Java 클래스 삭제',                 icon: 'fa-solid fa-trash' }
  ]
};
const treeCtx = {
  el: document.getElementById('treeCtx'),
  model: null,
  items: [],
  open(x, y, info, items){ hideAllCtxMenus(); 
    this.model = info;
    this.items = items || [];
    const ul = this.el.querySelector('ul');
    ul.innerHTML = '';
    (this.items||[]).forEach(it=>{
      const li = document.createElement('li');
      li.setAttribute('data-act', it.act);
      if(it.icon){
        const i = document.createElement('i');
        i.className = it.icon;
        li.appendChild(i);
        li.appendChild(document.createTextNode(' ' + it.label));
      } else {
        li.textContent = it.label;
      }
      ul.appendChild(li);
    });
    this.el.style.left = x + 'px';
    this.el.style.top = y + 'px';
    this.el.classList.remove('hidden');
    this.el.setAttribute('aria-hidden', 'false');
  },
  hide(){
    this.el.classList.add('hidden');
    this.el.setAttribute('aria-hidden', 'true');
    this.model = null;
    this.items = [];
  }
};

treeCtx.el.addEventListener('click', (e)=>{
  const li = e.target.closest('li');
  if(!li) return;
  const act = li.getAttribute('data-act');
  if(!act) return;
  const info = treeCtx.model;
  const item = (treeCtx.items||[]).find(x=>x.act===act) || null;
  handleTreeCtxAction(act, info, item);
  treeCtx.hide();
});
window.addEventListener('click', (e)=>{
  if(!treeCtx.el.contains(e.target)) treeCtx.hide();
});
window.addEventListener('scroll', ()=> treeCtx.hide(), true);


const ddlPanel = {
  el: document.getElementById('ddlPanel'),
  titleEl: document.getElementById('ddlTitle'),
  textEl: document.getElementById('ddlText'),
  show(title, text){
    if(this.titleEl) this.titleEl.textContent = title || '';
    if(this.textEl) this.textEl.textContent = text || '';
    if(bottomTabs){
      bottomTabs.activate('ddlPanel');
    }else if(this.el){
      this.el.classList.remove('hidden');
      this.el.style.display = 'block';
    }
  },
  setText(text){
    if(this.textEl) this.textEl.textContent = text || '';
  },
  clear(){
    if(this.textEl) this.textEl.textContent = '';
    if(this.titleEl) this.titleEl.textContent = '';
  },
  hide(){
    if(this.el){
      this.el.style.display = 'none';
    }
  },
  toggle(){
    if(bottomTabs){
      bottomTabs.toggle('ddlPanel');
      return;
    }
    if(!this.el) return;
    const disp = getComputedStyle(this.el).display;
    if(disp === 'none'){
      this.el.classList.remove('hidden');
      this.el.style.display = 'block';
    }else{
      this.el.style.display = 'none';
    }
  }
};


function handleTreeCtxAction(act, info, item){
  // info가 없는 경우(트리 빈 영역 컨텍스트 메뉴 등)의 전역 액션 처리
  if(!info){
    switch(act){
      case 'dbtree-create-db': {
        if (typeof dbFolderUi !== 'undefined' && dbFolderUi && typeof dbFolderUi.setSelectedNode === 'function') {
          dbFolderUi.setSelectedNode(null);
        }
        if (typeof connSettings !== 'undefined' && connSettings && typeof connSettings.openNew === 'function') {
          connSettings.openNew();
        }
        return;
      }
      case 'dbtree-create-folder': {
        if (typeof dbFolderUi !== 'undefined' && dbFolderUi) {
          if (typeof dbFolderUi.setSelectedNode === 'function') {
            dbFolderUi.setSelectedNode(null);
          }
          if (typeof dbFolderUi.addFolder === 'function') {
            dbFolderUi.addFolder();
          }
        }
        return;
      }
      case 'dbtree-paste': {
        if (typeof dbFolderUi !== 'undefined' && dbFolderUi && typeof dbFolderUi.pasteFolder === 'function') {
          dbFolderUi.pasteFolder(null);
        } else {
          alert('붙여넣기할 폴더 정보가 없습니다.');
        }
        return;
      }
      default:
        return;
    }
  }
  const schema = info.schema || 'public';
  const table = info.table || info.label || '';
  switch(act){
    case 'folder-add': {
      if (typeof dbFolderUi !== 'undefined' && typeof dbFolderUi.addFolder === 'function') {
        dbFolderUi.addFolder();
      }
      break;
    }
    case 'folder-rename': {
      if (typeof dbFolderUi !== 'undefined' && typeof dbFolderUi.renameFolder === 'function') {
        dbFolderUi.renameFolder();
      }
      break;
    }
    case 'folder-delete': {
      if (typeof dbFolderUi !== 'undefined' && typeof dbFolderUi.deleteFolder === 'function') {
        dbFolderUi.deleteFolder();
      }
      break;
    }
    case 'folder-copy': {
      if (typeof dbFolderUi !== 'undefined' && typeof dbFolderUi.copyFolder === 'function') {
        dbFolderUi.copyFolder(info && info.li);
      }
      break;
    }
    case 'folder-paste': {
      if (typeof dbFolderUi !== 'undefined' && typeof dbFolderUi.pasteFolder === 'function') {
        dbFolderUi.pasteFolder(info && info.li);
      }
      break;
    }

    case 'table-edit': {
      if(!table) return;
      tableEditor.open(info);
      break;
    }
    case 'table-view-data': {
      if(!table) return;
      const connId = info.connId || state.connId;
      actions.openSampleSelect(schema, table, connId);
      break;
    }
    case 'table-gen-select': {
      if(!table) return;
      const fullName = schema ? `${schema}.${table}` : table;
      const sql = `-- ${fullName}\nSELECT *\nFROM ${fullName}\nLIMIT 200;`;
      ui.newEditorTab();
      ui.setEditor(sql);
      break;
    }
    case 'table-gen-insert':
    case 'table-gen-update':
    case 'table-gen-delete': {
      if(!table) return;
      const fullName = schema ? `${schema}.${table}` : table;
      let sql;
      if(act === 'table-gen-insert'){
        sql = `-- ${fullName}\nINSERT INTO ${fullName} (\n  /* columns */\n) VALUES (\n  /* values */\n);`;
      } else if(act === 'table-gen-update'){
        sql = `-- ${fullName}\nUPDATE ${fullName}\n   SET /* column = value */\n WHERE /* condition */;`;
      } else {
        sql = `-- ${fullName}\nDELETE FROM ${fullName}\n WHERE /* condition */;`;
      }
      ui.newEditorTab();
      ui.setEditor(sql);
      break;
    }
    case 'table-copy-name': {
      if(!table) return;
      const fullName = schema ? `${schema}.${table}` : table;
      window.prompt('테이블 이름 복사', fullName);
      break;
    }
    case 'table-ddl': {
      if(!table) return;
      const connId = info.connId || state.connId;
      const fullName = schema ? `${schema}.${table}` : table;
      const title = `테이블 DDL: ${fullName}`;
      const body = `-- TODO: 서버에서 실제 테이블 DDL을 받아와서 이 영역에 표시하세요.\n-- 대상 테이블: ${fullName}\n-- 연결: ${connId || '(미지정)'}`;
      ddlPanel.show(title, body);
      break;
    }
    case 'view-ddl': {
      const name = table || info.label || '';
      if(!name) return;
      const connId = info.connId || state.connId;
      const fullName = schema ? `${schema}.${name}` : name;
      const title = `뷰 DDL: ${fullName}`;
      const body = `-- TODO: 서버에서 실제 뷰 DDL을 받아와서 이 영역에 표시하세요.\n-- 대상 뷰: ${fullName}\n-- 연결: ${connId || '(미지정)'}`;
      ddlPanel.show(title, body);
      break;
    }
    case 'func-ddl':
    case 'proc-ddl': {
      const name = table || info.label || '';
      if(!name) return;
      const connId = info.connId || state.connId;
      const fullName = schema ? `${schema}.${name}` : name;
      const title = `함수/프로시저 DDL: ${fullName}`;
      const body = `-- TODO: 서버에서 실제 함수/프로시저 DDL을 받아와서 이 영역에 표시하세요.\n-- 대상: ${fullName}\n-- 연결: ${connId || '(미지정)'}`;
      ddlPanel.show(title, body);
      break;
    }

    case 'view-new': {
      const baseSchema = info.schema || schema || 'public';
      const sql = `-- 새 뷰 생성 템플릿
CREATE OR REPLACE VIEW ${baseSchema}.new_view_name AS
SELECT /* columns */
FROM /* table */
WHERE /* condition */;`;
      ui.newEditorTab();
      ui.setEditor(sql);
      break;
    }
    case 'view-compile': {
      const name = table || info.label || '';
      if(!name) return;
      const fullName = schema ? `${schema}.${name}` : name;
      const sql = `-- 뷰 컴파일 템플릿
-- DB 종류에 맞게 명령을 수정하세요.
ALTER VIEW ${fullName} /* COMPILE 또는 REFRESH */;`;
      ui.newEditorTab();
      ui.setEditor(sql);
      break;
    }
    case 'view-drop': {
      const name = table || info.label || '';
      if(!name) return;
      const fullName = schema ? `${schema}.${name}` : name;
      const sql = `-- 뷰 삭제 템플릿
DROP VIEW ${fullName};`;
      ui.newEditorTab();
      ui.setEditor(sql);
      break;
    }
    case 'synonym-new': {
      const baseSchema = info.schema || schema || 'public';
      const sql = `-- Synonym 생성 템플릿
CREATE OR REPLACE SYNONYM ${baseSchema}.synonym_name
  FOR target_schema.target_object;`;
      ui.newEditorTab();
      ui.setEditor(sql);
      break;
    }
    case 'synonym-ddl': {
      const name = table || info.label || '';
      if(!name) return;
      const connId = info.connId || state.connId;
      const fullName = schema ? `${schema}.${name}` : name;
      const title = `Synonym DDL: ${fullName}`;
      const body = `-- TODO: 서버에서 실제 Synonym DDL을 받아와서 이 영역에 표시하세요.
-- 대상 Synonym: ${fullName}
-- 연결: ${connId || '(미지정)'}`;
      ddlPanel.show(title, body);
      break;
    }
    case 'synonym-drop': {
      const name = table || info.label || '';
      if(!name) return;
      const fullName = schema ? `${schema}.${name}` : name;
      const sql = `-- Synonym 삭제 템플릿
DROP SYNONYM ${fullName};`;
      ui.newEditorTab();
      ui.setEditor(sql);
      break;
    }
    case 'seq-config': {
      const name = table || info.label || '';
      if(!name) return;
      const fullName = schema ? `${schema}.${name}` : name;
      const sql = `-- 시퀀스 설정 보기/수정 템플릿
-- 현재 설정은 DB 카탈로그 조회 결과로 채워 넣으세요.
ALTER SEQUENCE ${fullName}
  /* INCREMENT BY 1
     MINVALUE 1
     MAXVALUE 999999999999
     CYCLE
     CACHE 20 */;`;
      ui.newEditorTab();
      ui.setEditor(sql);
      break;
    }
    case 'seq-ddl': {
      const name = table || info.label || '';
      if(!name) return;
      const connId = info.connId || state.connId;
      const fullName = schema ? `${schema}.${name}` : name;
      const title = `시퀀스 DDL: ${fullName}`;
      const body = `-- TODO: 서버에서 실제 시퀀스 DDL을 받아와서 이 영역에 표시하세요.
-- 대상 시퀀스: ${fullName}
-- 연결: ${connId || '(미지정)'}`;
      ddlPanel.show(title, body);
      break;
    }
    case 'proc-new': {
      const baseSchema = info.schema || schema || 'public';
      const sql = `-- 프로시저 생성 템플릿
CREATE OR REPLACE PROCEDURE ${baseSchema}.new_procedure(
  /* parameters */
) AS
BEGIN
  NULL;
END;
/
`;
      ui.newEditorTab();
      ui.setEditor(sql);
      break;
    }
    case 'proc-compile': {
      const name = table || info.label || '';
      if(!name) return;
      const fullName = schema ? `${schema}.${name}` : name;
      const sql = `-- 프로시저 컴파일 템플릿
-- DB 종류에 맞게 명령을 수정하세요.
ALTER PROCEDURE ${fullName} COMPILE;`;
      ui.newEditorTab();
      ui.setEditor(sql);
      break;
    }
    case 'proc-exec': {
      const name = table || info.label || '';
      if(!name) return;
      const fullName = schema ? `${schema}.${name}` : name;
      const sql = `-- 프로시저 실행 템플릿
CALL ${fullName}(/* 파라미터 */);`;
      ui.newEditorTab();
      ui.setEditor(sql);
      break;
    }
    case 'proc-drop': {
      const name = table || info.label || '';
      if(!name) return;
      const fullName = schema ? `${schema}.${name}` : name;
      const sql = `-- 프로시저 삭제 템플릿
DROP PROCEDURE ${fullName};`;
      ui.newEditorTab();
      ui.setEditor(sql);
      break;
    }
    case 'func-new': {
      const baseSchema = info.schema || schema || 'public';
      const sql = `-- 함수 생성 템플릿
CREATE OR REPLACE FUNCTION ${baseSchema}.new_function(
  /* parameters */
) RETURN /* datatype */ AS
BEGIN
  RETURN NULL;
END;
/
`;
      ui.newEditorTab();
      ui.setEditor(sql);
      break;
    }
    case 'func-compile': {
      const name = table || info.label || '';
      if(!name) return;
      const fullName = schema ? `${schema}.${name}` : name;
      const sql = `-- 함수 컴파일 템플릿
-- DB 종류에 맞게 명령을 수정하세요.
ALTER FUNCTION ${fullName} COMPILE;`;
      ui.newEditorTab();
      ui.setEditor(sql);
      break;
    }
    case 'func-exec': {
      const name = table || info.label || '';
      if(!name) return;
      const fullName = schema ? `${schema}.${name}` : name;
      const sql = `-- 함수 실행 템플릿
SELECT ${fullName}(/* 파라미터 */);`;
      ui.newEditorTab();
      ui.setEditor(sql);
      break;
    }
    case 'func-drop': {
      const name = table || info.label || '';
      if(!name) return;
      const fullName = schema ? `${schema}.${name}` : name;
      const sql = `-- 함수 삭제 템플릿
DROP FUNCTION ${fullName};`;
      ui.newEditorTab();
      ui.setEditor(sql);
      break;
    }
    case 'package-new': {
      const baseSchema = info.schema || schema || 'public';
      const sql = `-- 패키지 생성 템플릿
CREATE OR REPLACE PACKAGE ${baseSchema}.new_package IS
  -- 선언부
END new_package;
/
CREATE OR REPLACE PACKAGE BODY ${baseSchema}.new_package IS
  -- 본문
END new_package;
/
`;
      ui.newEditorTab();
      ui.setEditor(sql);
      break;
    }
    case 'package-compile': {
      const name = table || info.label || '';
      if(!name) return;
      const fullName = schema ? `${schema}.${name}` : name;
      const sql = `-- 패키지 컴파일 템플릿
ALTER PACKAGE ${fullName} COMPILE;`;
      ui.newEditorTab();
      ui.setEditor(sql);
      break;
    }
    case 'package-ddl': {
      const name = table || info.label || '';
      if(!name) return;
      const connId = info.connId || state.connId;
      const fullName = schema ? `${schema}.${name}` : name;
      const title = `패키지 DDL: ${fullName}`;
      const body = `-- TODO: 서버에서 실제 패키지 DDL을 받아와서 이 영역에 표시하세요.
-- 대상 패키지: ${fullName}
-- 연결: ${connId || '(미지정)'}`;
      ddlPanel.show(title, body);
      break;
    }
    case 'package-drop': {
      const name = table || info.label || '';
      if(!name) return;
      const fullName = schema ? `${schema}.${name}` : name;
      const sql = `-- 패키지 삭제 템플릿
DROP PACKAGE ${fullName};`;
      ui.newEditorTab();
      ui.setEditor(sql);
      break;
    }
    case 'trigger-new': {
      const baseSchema = info.schema || schema || 'public';
      const targetTable = info.table || 'target_table';
      const sql = `-- 트리거 생성 템플릿
CREATE OR REPLACE TRIGGER ${baseSchema}.trg_name
BEFORE INSERT OR UPDATE OR DELETE ON ${baseSchema}.${targetTable}
FOR EACH ROW
BEGIN
  NULL;
END;
/
`;
      ui.newEditorTab();
      ui.setEditor(sql);
      break;
    }
    case 'trigger-ddl': {
      const name = table || info.label || '';
      if(!name) return;
      const connId = info.connId || state.connId;
      const fullName = schema ? `${schema}.${name}` : name;
      const title = `트리거 DDL: ${fullName}`;
      const body = `-- TODO: 서버에서 실제 트리거 DDL을 받아와서 이 영역에 표시하세요.
-- 대상 트리거: ${fullName}
-- 연결: ${connId || '(미지정)'}`;
      ddlPanel.show(title, body);
      break;
    }
    case 'trigger-drop': {
      const name = table || info.label || '';
      if(!name) return;
      const fullName = schema ? `${schema}.${name}` : name;
      const sql = `-- 트리거 삭제 템플릿
DROP TRIGGER ${fullName};`;
      ui.newEditorTab();
      ui.setEditor(sql);
      break;
    }

    case 'dblink-new': {
      const baseSchema = info.schema || schema || 'public';
      const sql = `-- DB Link 생성 템플릿
-- DBMS 종류에 따라 문법을 조정하세요.
CREATE DATABASE LINK dblink_name
  CONNECT TO user IDENTIFIED BY password
  USING 'tns_or_connection_string';
`;
      ui.newEditorTab();
      ui.setEditor(sql);
      break;
    }
    case 'dblink-test': {
      const name = table || info.label || '';
      if(!name) return;
      const sql = `-- DB Link 연결 테스트 템플릿
-- 실제 환경에 맞는 테스트 쿼리로 교체하세요.
SELECT 1 FROM dual@${name};
`;
      ui.newEditorTab();
      ui.setEditor(sql);
      break;
    }
    case 'dblink-ddl': {
      const name = table || info.label || '';
      if(!name) return;
      const connId = info.connId || state.connId;
      const title = `DB Link DDL: ${name}`;
      const body = `-- TODO: 서버에서 실제 DB Link 정의를 조회해 이 영역에 표시하세요.
-- 대상 DB Link: ${name}
-- 연결: ${connId || '(미지정)'}`;
      ddlPanel.show(title, body);
      break;
    }
    case 'dblink-drop': {
      const name = table || info.label || '';
      if(!name) return;
      const sql = `-- DB Link 삭제 템플릿
DROP DATABASE LINK ${name};`;
      ui.newEditorTab();
      ui.setEditor(sql);
      break;
    }
    case 'job-new': {
      const baseSchema = info.schema || schema || 'public';
      const sql = `-- Job 생성 템플릿
-- DBMS 스케줄러 문법(예: DBMS_SCHEDULER, DBMS_JOB, pg_cron 등)에 맞게 수정하세요.
BEGIN
  NULL;
END;
/
`;
      ui.newEditorTab();
      ui.setEditor(sql);
      break;
    }
    case 'job-open': {
      const name = table || info.label || '';
      if(!name) return;
      const sql = `-- Job 조회/수정 템플릿
-- ${name} 의 설정을 조회/수정하는 SQL을 작성하세요.`;
      ui.newEditorTab();
      ui.setEditor(sql);
      break;
    }
    case 'job-run': {
      const name = table || info.label || '';
      if(!name) return;
      const sql = `-- Job 실행 템플릿
-- DBMS 스케줄러에 맞는 즉시 실행 명령으로 바꿔 사용하세요.
-- 예) DBMS_SCHEDULER.RUN_JOB('${name}');
`;
      ui.newEditorTab();
      ui.setEditor(sql);
      break;
    }
    case 'job-stop': {
      const name = table || info.label || '';
      if(!name) return;
      const sql = `-- Job 중지 템플릿
-- DBMS 스케줄러에 맞는 중지 명령으로 바꿔 사용하세요.
-- 예) DBMS_SCHEDULER.STOP_JOB('${name}');
`;
      ui.newEditorTab();
      ui.setEditor(sql);
      break;
    }
    case 'job-ddl': {
      const name = table || info.label || '';
      if(!name) return;
      const connId = info.connId || state.connId;
      const title = `Job 정의: ${name}`;
      const body = `-- TODO: 서버에서 Job 정의를 조회해 이 영역에 표시하세요.
-- 대상 Job: ${name}
-- 연결: ${connId || '(미지정)'}`;
      ddlPanel.show(title, body);
      break;
    }
    case 'job-drop': {
      const name = table || info.label || '';
      if(!name) return;
      const sql = `-- Job 삭제 템플릿
-- 스케줄러 종류에 따라 실제 삭제 명령을 작성하세요.`;
      ui.newEditorTab();
      ui.setEditor(sql);
      break;
    }
    case 'java-open': {
      const name = table || info.label || '';
      if(!name) return;
      const sql = `-- Java 클래스 메타정보 조회 템플릿
-- ${name} 에 대한 메타데이터를 조회하는 SQL 또는 DBMS 전용 뷰를 사용하세요.`;
      ui.newEditorTab();
      ui.setEditor(sql);
      break;
    }
    case 'java-source': {
      const name = table || info.label || '';
      if(!name) return;
      const title = `Java 소스: ${name}`;
      const body = `-- TODO: 서버에서 Java 소스를 조회해 이 영역에 그대로 표시하세요.
-- 대상 Java 클래스: ${name}`;
      ddlPanel.show(title, body);
      break;
    }
    case 'java-drop': {
      const name = table || info.label || '';
      if(!name) return;
      const sql = `-- Java 클래스 삭제 템플릿
-- DBMS 종류에 따라 실제 삭제 명령을 작성하세요.`;
      ui.newEditorTab();
      ui.setEditor(sql);
      break;
    }
    default: {
      const label = item && item.label ? item.label : act;
      dbamStub(label);
    }
  }
}
/* ---------------- Editor Context Menu ---------------- */
const editorCtx = {
  el: document.getElementById('editorCtx'),
  bind(target){
    if (!target) return;
    // 에디터 래퍼 안에서 발생한 우클릭만 처리
    document.addEventListener('contextmenu', (e)=>{
      if (!target.contains(e.target)) return;

      // 쿼리 진행 오버레이나 모달이 떠 있을 때는 에디터 메뉴 비활성
      const overlay = document.querySelector('.query-progress-overlay.is-active, #shortcutHelpBackdrop.show, .export-modal-backdrop.show');
      if (overlay) return;

      e.preventDefault();
      this.open(e.clientX, e.clientY);
    });
  },
  open(x,y){
    hideAllCtxMenus();
    this.el.style.left = x + 'px';
    this.el.style.top = y + 'px';
    this.el.classList.remove('hidden');
    this.el.setAttribute('aria-hidden','false');
  },
  hide(){
    this.el.classList.add('hidden');
    this.el.setAttribute('aria-hidden','true');
  }
};

window.addEventListener('resize', function(){
  try{
    if (window.ui && typeof ui.updateTabOverflow === 'function') {
      ui.updateTabOverflow();
    }
  }catch(e){
    console.warn('tab overflow resize error', e);
  }
});

editorCtx.el.addEventListener('click', (e)=>{
  const li = e.target.closest('li'); if(!li) return;
  const act = li.getAttribute('data-act');
  if(act==='run' || act==='runSql') actions.runSql();         // 호환용
  if(act==='runCurrent') actions.runCurrent();
  if(act==='runScript') actions.runScript();
  if(act==='format') ui.formatSql();
  if(act==='explain') actions.explain();
  if(act==='favSelection'){
    if(typeof ui!=='undefined' && ui && typeof ui.openFavSaveModal==='function'){
      ui.openFavSaveModal();
    }else if(typeof favorites!=='undefined' && favorites.addFromSelection){
      favorites.addFromSelection();
    }
  }
  if(act==='code-in-list' && typeof codeActions !== 'undefined' && codeActions && typeof codeActions.toInList === 'function'){
    codeActions.toInList();
  }
  if(act==='code-toggle-comment' && typeof codeActions !== 'undefined' && codeActions && typeof codeActions.toggleComment === 'function'){
    codeActions.toggleComment();
  }
  if(act==='code-run-selection'){
    if(typeof codeActions !== 'undefined' && codeActions && typeof codeActions.runSelection === 'function'){
      codeActions.runSelection();
    }else{
      actions.runCurrent();
    }
  }
  if(typeof cm !== 'undefined' && cm && typeof cm.focus === 'function'){
    cm.focus();
  }
  editorCtx.hide();
});
window.addEventListener('click', (e)=>{ if(!editorCtx.el.contains(e.target)) editorCtx.hide(); });
window.addEventListener('scroll', ()=> editorCtx.hide(), true);

// ---------------- Tab Context Menu ----------------
const tabCtx = {
  el: document.getElementById('tabCtx'),
  targetTabId: null,
  open(x, y, tabId){ hideAllCtxMenus(); 
    this.targetTabId = tabId;
    // 핀 상태에 따라 메뉴 텍스트 동적 변경
    try{
      const tab = (state.tabs || []).find(t => t.id === tabId);
      const pinLi = this.el.querySelector('li[data-act="tab-pin-toggle"]');
      if (pinLi && tab) {
        const isPinned = !!tab.isPinned;
        pinLi.innerHTML = '<i class="fa-solid fa-thumbtack"></i> ' + (isPinned ? '핀 해제' : '핀 고정');
      }
    }catch(e){}
    this.el.style.left = x + 'px';
    this.el.style.top = y + 'px';
    this.el.classList.remove('hidden');
    this.el.setAttribute('aria-hidden', 'false');
  },
  hide(){
    this.el.classList.add('hidden');
    this.el.setAttribute('aria-hidden', 'true');
    this.targetTabId = null;
  }
};

tabCtx.el.addEventListener('click', (e)=>{
  const li = e.target.closest('li');
  if(!li) return;
  const act = li.getAttribute('data-act');
  const id = tabCtx.targetTabId;
  if(!act || !id){ tabCtx.hide(); return; }

  switch(act){
    case 'tab-close':
      ui.closeTab(id);
      break;
    case 'tab-close-others':
      ui.closeOtherTabs(id);
      break;
    case 'tab-close-all':
      ui.closeAllTabs();
      break;
    case 'tab-pin-toggle':
      ui.togglePinTab(id);
      break;
    case 'tab-rename':
      try{
        ui.startTabInlineRename(id);
      }catch(e){
        console.warn('tab-rename error', e);
      }
      break;
    case 'tab-color-default':
      ui.setTabColor(id, 'default');
      break;
    case 'tab-color-blue':
      ui.setTabColor(id, 'blue');
      break;
    case 'tab-color-green':
      ui.setTabColor(id, 'green');
      break;
    case 'tab-color-yellow':
      ui.setTabColor(id, 'yellow');
      break;
    case 'tab-color-red':
      ui.setTabColor(id, 'red');
      break;
    case 'tab-save':
      ui.openSqlSaveModal();
      break;
    default:
      break;
  }

  tabCtx.hide();
});
window.addEventListener('click', (e)=>{
  if(!tabCtx.el.contains(e.target)) tabCtx.hide();
});
window.addEventListener('scroll', ()=> tabCtx.hide(), true);

// ---------------- Result Context Menu ----------------
const resultCtx = {
  el: document.getElementById('resultCtx'),
  open(x, y){ hideAllCtxMenus(); 
    this.el.style.left = x + 'px';
    this.el.style.top  = y + 'px';
    this.el.classList.remove('hidden');
    this.el.setAttribute('aria-hidden','false');
  },
  hide(){
    this.el.classList.add('hidden');
    this.el.setAttribute('aria-hidden','true');
  }
};

resultCtx.el.addEventListener('click', (e)=>{
  const li = e.target.closest('li');
  if(!li) return;
  const act = li.getAttribute('data-act');
  if(!act) return;

  switch(act){
    case 'export':
      actions.exportCsv();
      break;
    case 'export-insert':
      actions.exportInsert();
      break;
    case 'copy-sql':
      actions.copySql();
      break;
    default:
      break;
  }

  resultCtx.hide();
});
window.addEventListener('click', (e)=>{ if(!resultCtx.el.contains(e.target)) resultCtx.hide(); });
window.addEventListener('scroll', ()=> resultCtx.hide(), true);


// ---------------- History / Recent Query Context Menu ----------------
const historyCtx = {
  el: document.getElementById('historyCtx'),
  target: null,
  open(x, y, target){
    hideAllCtxMenus();
    this.target = target || null;
    const el = this.el;
    if(!el) return;
    el.style.left = x + 'px';
    el.style.top  = y + 'px';
    el.classList.remove('hidden');
    el.setAttribute('aria-hidden','false');
  },
  hide(){
    const el = this.el;
    if(!el) return;
    el.classList.add('hidden');
    el.setAttribute('aria-hidden','true');
    this.target = null;
  }
};

if(historyCtx.el){
  historyCtx.el.addEventListener('click', (e)=>{
    const li = e.target.closest('li');
    if(!li) return;
    const act = li.getAttribute('data-act');
    const target = historyCtx.target;
    if(!act || !target){
      historyCtx.hide();
      return;
    }

    if(act === 'add-favorite'){
      try{
        const sql = target.sql || '';
        if(!sql || !sql.trim()){
          alert('즐겨찾기로 저장할 SQL이 없습니다.');
        }else if(typeof openFavSaveModalFromSql === 'function'){
          openFavSaveModalFromSql(sql);
        }else if(typeof ui !== 'undefined' && ui && typeof ui.openFavSaveModal === 'function'){
          // fallback: 에디터를 잠시 교체 후 모달 호출
          const prev = (typeof ui.getEditor === 'function') ? ui.getEditor() : '';
          if(typeof ui.setEditor === 'function'){
            ui.setEditor(sql);
            ui.openFavSaveModal();
            ui.setEditor(prev);
          }else{
            ui.openFavSaveModal();
          }
        }
      }catch(err){
        console.warn('historyCtx add-favorite error', err);
      }
    }

    historyCtx.hide();
  });

  window.addEventListener('click', (e)=>{
    if(!historyCtx.el.contains(e.target)) historyCtx.hide();
  });
  window.addEventListener('scroll', ()=> historyCtx.hide(), true);
}

// Favorite / Template Context Menu
const favCtx = {
  el: document.getElementById('favCtxMenu'),
  target: null,
  open(x, y, target){
    hideAllCtxMenus();
    this.target = target || null;
    const el = this.el;
    if(!el) return;
    el.style.left = x + 'px';
    el.style.top  = y + 'px';
    el.classList.remove('hidden');
    el.setAttribute('aria-hidden','false');
  },
  hide(){
    const el = this.el;
    if(!el) return;
    el.classList.add('hidden');
    el.setAttribute('aria-hidden','true');
    this.target = null;
  }
};

if(favCtx.el){
  favCtx.el.addEventListener('click', (e)=>{
    const li = e.target.closest('li');
    if(!li) return;
    const act = li.getAttribute('data-act');
    const target = favCtx.target;
    if(!target || !act){
      favCtx.hide();
      return;
    }

    if(act === 'edit'){
      // 유형별로 편집 모달 오픈
      if(typeof ui !== 'undefined' && ui && typeof ui.openFavEditModal === 'function'){
        ui.openFavEditModal(target.type === 'org' ? 'ORG' : 'PERSONAL', target.id);
      }
    }else if(act === 'delete'){
      if(target.type === 'personal'){
        if(window.confirm(`'${target.name || ''}' 개인 즐겨찾기를 삭제할까요?`)){
          if(typeof favorites !== 'undefined' && favorites && typeof favorites.remove === 'function'){
            favorites.remove(target.id);
          }
        }
      }else if(target.type === 'org'){
        if(window.confirm(`'${target.name || ''}' 공용 템플릿을 삭제할까요?`)){
          if(typeof favTpl !== 'undefined' && favTpl && typeof favTpl.removeOrg === 'function'){
            favTpl.removeOrg(target.id);
          }
        }
      }
    }

    favCtx.hide();
  });

  window.addEventListener('click', (e)=>{
    if(!favCtx.el.contains(e.target)) favCtx.hide();
  });
  window.addEventListener('scroll', ()=> favCtx.hide(), true);
}



/* ---------------- Tree (DB objects) ---------------- */
const tree = {

  toggleOne(li, 


expand){
    const sub = li.querySelector(':scope > ul');
    if(!sub) return;
    const tw = li.querySelector(':scope > .node .tw');
    const show = (expand===undefined) ? (getComputedStyle(sub).display==='none') : !!expand;
    sub.style.display = show ? 'block' : 'none';
    if(tw){ tw.textContent = show ? '▼' : '▶'; }
  },
  toggleRecursive(li, expand){
    const hasChild = !!li.querySelector(':scope > ul');
    if(!hasChild) return;
    // expand/collapse the top level first
    this.toggleOne(li, expand);
    // then apply to all descendants
    li.querySelectorAll(':scope ul').forEach(u=>{
      u.style.display = expand ? 'block' : 'none';
      const tw = u.parentElement.querySelector(':scope > .node .tw');
      if(tw){ tw.textContent = expand ? '▼' : '▶'; }
    });
  },
  focusFirstChild(li){
    const first = li.querySelector(':scope > ul > li > .node');
    if(first){ first.focus(); }
  },
  focusParent(li){
    const parentNode = li.parentElement.closest('li > .node');
    if(parentNode){ parentNode.focus(); }
  },

  renderDisconnected(){ document.getElementById('dbTree').innerHTML = '<div class="muted" style="padding:8px 6px">연결 후 목록이 표시됩니다.</div>'; },
  
  icon(kind){
    const green = 'var(--hana-primary,#008485)';
    const folder = '#f7d154';
    switch(kind){
      case 'conn':
        return '<i class="fa-solid fa-database" style="color:'+green+';"></i>';
      case 'schema':
        return '<i class="fa-solid fa-sitemap" style="color:'+green+';"></i>';

      case 'folder':
      case 'tables-folder':
      case 'views-folder':
      case 'indexes-folder':
      case 'functions-folder':
      case 'procs-folder':
      case 'sequences-folder':
      case 'types-folder':
      case 'table-cols':
      case 'table-fks':
      case 'table-deps':
      case 'table-refs':
      case 'table-parts':
      case 'table-triggers':
      case 'table-rules':
      case 'synonyms-folder':
      case 'triggers-folder':
      case 'packages-folder':
      case 'db-links-folder':
        return '<i class="fa-regular fa-folder" style="color:'+folder+';"></i>';

      case 'table':
        return '<i class="fa-solid fa-table" style="color:'+green+';"></i>';
      case 'view':
        return '<i class="fa-regular fa-eye" style="color:'+green+';"></i>';
      case 'func':
        return '<i class="fa-solid fa-code" style="color:'+green+';"></i>';
      case 'proc':
        return '<i class="fa-solid fa-gears" style="color:'+green+';"></i>';
      case 'seq':
        return '<i class="fa-solid fa-hashtag" style="color:'+green+';"></i>';
      case 'index':
        return '<i class="fa-solid fa-arrow-down-a-z" style="color:'+green+';"></i>';
      case 'type':
        return '<i class="fa-regular fa-square" style="color:'+green+';"></i>';
      case 'column':
        return '<i class="fa-solid fa-bars-staggered" style="color:'+green+';"></i>'; /* generic column (fallback) */
      case 'column-text':
        return '<span class="col-icon col-text">ABC</span>';
      case 'column-number':
        return '<span class="col-icon col-number">123</span>';
      case 'column-date':
        return '<span class="col-icon col-date"><i class="fa-regular fa-clock"></i></span>';
      case 'fk':
        return '<i class="fa-solid fa-key" style="color:'+green+';"></i>';
      case 'dependency':
        return '<i class="fa-solid fa-diagram-project" style="color:'+green+';"></i>';
      case 'reference':
        return '<i class="fa-solid fa-diagram-next" style="color:'+green+';"></i>';
      case 'partition':
        return '<i class="fa-solid fa-border-all" style="color:'+green+';"></i>';
      case 'rule':
        return '<i class="fa-solid fa-scale-balanced" style="color:'+green+';"></i>';
      case 'package':
        return '<i class="fa-solid fa-box-archive" style="color:'+green+';"></i>';
      case 'trigger':
        return '<i class="fa-solid fa-bolt" style="color:'+green+';"></i>';
      case 'dblink':
        return '<i class="fa-solid fa-link" style="color:'+green+';"></i>';
      case 'job':
        return '<i class="fa-solid fa-clock-rotate-left" style="color:'+green+';"></i>';
      case 'java':
        return '<i class="fa-brands fa-java" style="color:'+green+';"></i>';

      default:
        return '<i class="fa-regular fa-circle" style="color:'+green+';"></i>';
    }
  },
  render(data){
    try{
      dbamHint.updateTablesFromTreeData(data);
    }catch(e){
      console.warn('dbamHint: tree.render update error', e);
    }
    const el = document.getElementById('dbTree');
    el.innerHTML = '';
    const rootUl = document.createElement('ul');
    data.connections.forEach(conn=>{
      const li = this.node(`${conn.label}`, '▶', 'conn');
      li.dataset.connId = conn.id;
      const connId = conn.id;
      attachConnPinControl(li, connId);
      // 상태 점 + 프로필 배지
      const nodeEl = li.querySelector('.node');
      const dot = document.createElement('i'); dot.className='fa-solid fa-circle conn-off conn-dot'; nodeEl.insertBefore(dot, nodeEl.children[1]);
      state.connProfiles[connId] = (conn.profile || null);
      // 더블클릭 = 연결(미연결 시), 우클릭 = 컨텍스트
      nodeEl.addEventListener('dblclick', ()=>{
        const isOn = !!(state.connStates && state.connStates[connId]);
        if (isOn) {
          // 이미 연결된 경우에는 트리만 펼치기
          const liNode = nodeEl.closest('li');
          if (liNode) {
            tree.toggleOne(liNode);
          }
          return;
        }
        ui._pendingConnSelectUsed   = false;
        ui._pendingConnAfterConnect = null;
        ui.openConnReasonModal(connId);
      });
      nodeEl.addEventListener('contextmenu', (e)=>{
        e.preventDefault();
        try{
          if (typeof dbFolderUi !== 'undefined' && dbFolderUi && typeof dbFolderUi.setSelectedNode === 'function') {
            dbFolderUi.setSelectedNode(nodeEl);
          } else {
            document.querySelectorAll('#dbTree .node.dbtree-selected')
              .forEach(n=>n.classList.remove('dbtree-selected'));
            nodeEl.classList.add('dbtree-selected');
          }
        }catch(err){
          console.warn('tree.render conn node contextmenu error', err);
        }
        ctxMenu.open(e.clientX, e.clientY, connId);
      });

      const schemasUl = document.createElement('ul');
      (conn.schemas||[]).forEach(sc=>{
        const sli = this.node(`schema: ${sc.name}`, '▶', 'schema');
        sli.dataset.schema = sc.name;
        const sUl = document.createElement('ul');
        // tables
        const tli = this.node('Tables', '▶', 'tables-folder');
        const tUl = document.createElement('ul');
        (sc.tables||[]).forEach(t=>{
          const nti = this.node(t, '▶', 'table');
          nti.dataset.table = t;
          nti.dataset.schema = sc.name;
          const nodeDiv = nti.querySelector('.node');
          nodeDiv.addEventListener('dblclick', ()=> actions.openSampleSelect(sc.name, t, connId));

          const childUl = document.createElement('ul');

          // columns (샘플)
          const colsNode = this.node('Columns', '▶', 'table-cols');
          colsNode.dataset.table = t;
          colsNode.dataset.schema = sc.name;
          const colsUl = document.createElement('ul');
          const colTypes = { id: 'bigint', col1: 'varchar(100)', col2: 'timestamp(6)' };
          try{
            dbamHint.addColumnsForTable(sc.name, t, ['id','col1','col2']);
          }catch(e){
            console.warn('dbamHint.addColumnsForTable demo error', e);
          }
          ['id','col1','col2'].forEach(c=>{

            const type = (colTypes[c] || '').toLowerCase();
            const label = type ? `${c} (${colTypes[c]})` : c;
            let colKind = 'column';
            if(type.includes('char') || type.includes('text')){
              colKind = 'column-text';
            }else if(type.includes('date') || type.includes('time')){
              colKind = 'column-date';
            }else if(type.includes('int') || type.includes('numeric') || type.includes('decimal') || type.includes('number') || type.includes('bigint') || type.includes('smallint')){
              colKind = 'column-number';
            }
            const colLi = this.node(label, '•', colKind);
            colLi.dataset.table = t;
            colLi.dataset.schema = sc.name;
            colLi.dataset.column = c;
            colsUl.appendChild(colLi);
          });
          colsNode.appendChild(colsUl);
          childUl.appendChild(colsNode);

          // foreign keys
          const fkNode = this.node('Foreign Keys', '▶', 'table-fks');
          fkNode.dataset.table = t;
          fkNode.dataset.schema = sc.name;
          childUl.appendChild(fkNode);

          // dependencies
          const depNode = this.node('Dependencies', '▶', 'table-deps');
          depNode.dataset.table = t;
          depNode.dataset.schema = sc.name;
          childUl.appendChild(depNode);

          // references
          const refNode = this.node('References', '▶', 'table-refs');
          refNode.dataset.table = t;
          refNode.dataset.schema = sc.name;
          childUl.appendChild(refNode);

          // partitions
          const partNode = this.node('Partitions', '▶', 'table-parts');
          partNode.dataset.table = t;
          partNode.dataset.schema = sc.name;
          childUl.appendChild(partNode);

          // triggers
          const trgNode = this.node('Triggers', '▶', 'table-triggers');
          trgNode.dataset.table = t;
          trgNode.dataset.schema = sc.name;
          childUl.appendChild(trgNode);

          // rules
          const ruleNode = this.node('Rules', '▶', 'table-rules');
          ruleNode.dataset.table = t;
          ruleNode.dataset.schema = sc.name;
          childUl.appendChild(ruleNode);

          nti.appendChild(childUl);
          tUl.appendChild(nti);
        });
        tli.appendChild(tUl); sUl.appendChild(tli);
        // views
        const vli = this.node('Views', '▶', 'views-folder');
        const vUl = document.createElement('ul');
        (sc.views||[]).forEach(v=>{ vUl.appendChild(this.node(v, '•', 'view')); });
        vli.appendChild(vUl); sUl.appendChild(vli);
        // functions
        const fli = this.node('Functions', '▶', 'functions-folder');
        const fUl = document.createElement('ul');
        (sc.functions||[]).forEach(f=>{ fUl.appendChild(this.node(f, 'ƒ', 'func')); });
        fli.appendChild(fUl); sUl.appendChild(fli);
        // sequences
        const qli = this.node('Sequences', '▶', 'sequences-folder');
        const qUl = document.createElement('ul');
        (sc.sequences||[]).forEach(s=>{ qUl.appendChild(this.node(s, '#', 'seq')); });
        qli.appendChild(qUl); sUl.appendChild(qli);
        // synonyms
        const synFolder = this.node('Synonyms', '▶', 'synonyms-folder');
        const synUl = document.createElement('ul');
        (sc.synonyms || ['synonym_sample']).forEach(syn=>{
          synUl.appendChild(this.node(syn, 'S', 'synonym'));
        });
        synFolder.appendChild(synUl); sUl.appendChild(synFolder);
        // triggers (schema-level)
        const trigFolder = this.node('Triggers', '▶', 'triggers-folder');
        const trigUl = document.createElement('ul');
        (sc.triggers || ['trg_sample']).forEach(tr=>{
          trigUl.appendChild(this.node(tr, 'T', 'trigger'));
        });
        trigFolder.appendChild(trigUl); sUl.appendChild(trigFolder);
        // packages
        const pkgFolder = this.node('Packages', '▶', 'packages-folder');
        const pkgUl = document.createElement('ul');
        (sc.packages || ['pkg_sample']).forEach(p=>{
          pkgUl.appendChild(this.node(p, 'P', 'package'));
        });
        pkgFolder.appendChild(pkgUl); sUl.appendChild(pkgFolder);
        // DB Links
        const dbLinkFolder = this.node('DB Links', '▶', 'db-links-folder');
        const dbLinkUl = document.createElement('ul');
        (sc.dbLinks || ['dblink_sample']).forEach(d=>{
          dbLinkUl.appendChild(this.node(d, 'L', 'dblink'));
        });
        dbLinkFolder.appendChild(dbLinkUl); sUl.appendChild(dbLinkFolder);
        // Jobs
        const jobsFolder = this.node('Jobs', '▶', 'jobs-folder');
        const jobsUl = document.createElement('ul');
        (sc.jobs || ['job_sample']).forEach(j=>{
          jobsUl.appendChild(this.node(j, 'J', 'job'));
        });
        jobsFolder.appendChild(jobsUl); sUl.appendChild(jobsFolder);
        // Java
        const javaFolder = this.node('Java', '▶', 'java-folder');
        const javaUl = document.createElement('ul');
        (sc.javaObjects || ['JavaClassSample']).forEach(jv=>{
          javaUl.appendChild(this.node(jv, 'J', 'java'));
        });
        javaFolder.appendChild(javaUl); sUl.appendChild(javaFolder);

        sli.appendChild(sUl); schemasUl.appendChild(sli);
      });
      // 기본 닫힘
      schemasUl.style.display = 'none';
      li.appendChild(schemasUl);
      rootUl.appendChild(li);
    });
    if (typeof sortDbTreeDepth === 'function') {
      sortDbTreeDepth(rootUl);
    }
    el.appendChild(rootUl);
    this.updateConnBadges();
    this.bindTreeContextMenu(el);

    if (typeof dbFolderUi !== 'undefined' && typeof dbFolderUi.initAfterRender === 'function') {
      dbFolderUi.initAfterRender();
    }

    // Keyboard left/right navigation
    el.querySelectorAll('.node').forEach(node=>{
      node.addEventListener('keydown', (e)=>{
        const li = node.parentElement;
        if(e.key === 'ArrowRight'){
          e.preventDefault();
          // if has children and (for conn: must be connected), expand immediate; otherwise, move to first child
          const ch = li.querySelector(':scope > ul');
          if(ch){
            if(li.dataset.connId && !state.connStates[li.dataset.connId]){
              return; // block when disconnected
            }
            if(getComputedStyle(ch).display==='none'){
              tree.toggleOne(li, true);
            } else {
              tree.focusFirstChild(li);
            }
          }
        } else if(e.key === 'ArrowLeft'){
          e.preventDefault();
          const ch = li.querySelector(':scope > ul');
          if(ch && getComputedStyle(ch).display!=='none'){
            // collapse immediate
            tree.toggleOne(li, false);
          } else {
            // move to parent
            tree.focusParent(li);
          }
        }
      });
    });

    el.querySelectorAll('.node .tw').forEach(tw=>{
      tw.addEventListener('click', (ev)=>{
        ev.stopPropagation();
        const n = tw.closest('.node');
        if (!n) return;
        try{
          if (typeof dbFolderUi !== 'undefined' && dbFolderUi && typeof dbFolderUi.setSelectedNode === 'function') {
            dbFolderUi.setSelectedNode(n);
          } else {
            document.querySelectorAll('#dbTree .node.dbtree-selected')
              .forEach(x=>x.classList.remove('dbtree-selected'));
            n.classList.add('dbtree-selected');
          }
        }catch(err){
          console.warn('tree.tw click select error', err);
        }
        const li = n.parentElement;
        const ch = li.querySelector(':scope > ul');
        if(!ch) return; // leaf
        // block when disconnected connection root
        if(li.dataset.connId){
          const id = li.dataset.connId;
          if(!state.connStates[id]) return;
        }
        if(ev.altKey){
          // Alt+click: toggle entire subtree
          const isClosed = getComputedStyle(ch).display==='none';
          tree.toggleRecursive(li, isClosed);
        } else {
          // default: immediate only
          tree.toggleOne(li);
        }
      });
    });
  },
  node(text, tw, kind){
    const li = document.createElement('li');
    li.dataset.kind = kind;
    li.dataset.label = text;
    const a = document.createElement('div');
    a.className = 'node';
    a.setAttribute('tabindex', '0');
    a.setAttribute('role', 'treeitem');
    const twEl = document.createElement('span');
    twEl.className = 'tw';
    twEl.textContent = tw;
    a.appendChild(twEl);
    const iconSpan = document.createElement('span');
    iconSpan.innerHTML = this.icon(kind);
    a.appendChild(iconSpan);
    const tx = document.createElement('span');
    tx.textContent = text;
    a.appendChild(tx);
    const tag = document.createElement('span');
    tag.className = 'tag';
    tag.textContent = '';
    a.appendChild(tag);
    li.appendChild(a);
    return li;
  },

  buildNodeInfo(li){
    const info = {
      li,
      kind: li.dataset.kind || 'folder',
      label: (li.dataset.label || '').trim(),
      connId: null,
      schema: null,
      table: null,
      column: null
    };
    const connLi = li.closest('li[data-conn-id]');
    if(connLi){
      info.connId = connLi.dataset.connId;
    }
    const schemaLi = li.closest('li[data-kind="schema"]');
    if(schemaLi){
      const raw = schemaLi.dataset.label || '';
      info.schema = schemaLi.dataset.schema || raw.replace(/^schema:\s*/, '').trim();
    }
    if(li.dataset.schema){ info.schema = li.dataset.schema; }
    if(li.dataset.table){ info.table = li.dataset.table; }
    if(li.dataset.column){ info.column = li.dataset.column; }
    if(!info.table && info.kind === 'table'){ info.table = info.label; }
    return info;
  },

  bindTreeContextMenu(el){
    if(typeof treeCtxConfig === 'undefined' || typeof treeCtx === 'undefined'){
      return;
    }
    el.querySelectorAll('li > .node').forEach(node=>{
      const li = node.parentElement;
      // 연결 루트는 기존 conn 컨텍스트 메뉴 사용
      if(li.dataset.connId) return;
      node.addEventListener('contextmenu', (e)=>{
        e.preventDefault();
        if (typeof dbFolderUi !== 'undefined' && typeof dbFolderUi.setSelectedNode === 'function') {
          dbFolderUi.setSelectedNode(node);
        }
        const kind = li.dataset.kind || 'folder';
        const cfg = treeCtxConfig[kind] || treeCtxConfig._default;
        if(!cfg) return;
        const info = tree.buildNodeInfo(li);
        treeCtx.open(e.clientX, e.clientY, info, cfg);
      });
    });
  },

  updateConnBadges(){
    document.querySelectorAll('#dbTree li[data-conn-id]').forEach(li=>{
      const id = li.dataset.connId;
      const on = !!state.connStates[id];
      const nodeEl = li.querySelector('.node');
      const dot = nodeEl.querySelector('.conn-dot');
      if(dot){ dot.classList.toggle('conn-on', on); dot.classList.toggle('conn-off', !on); }
      const tag = nodeEl.querySelector('.tag');
      if(tag){ tag.style.color = on ? 'var(--ok)' : 'var(--danger)'; tag.textContent = on ? 'conn' : 'discon'; }
      if(!on){ const sub = li.querySelector(':scope > ul'); if(sub){ sub.style.display='none'; const tw = li.querySelector(':scope > .node .tw'); if(tw){ tw.textContent='▶'; } } }
    });
  },
  getConnLi(id){ return Array.from(document.querySelectorAll('#dbTree li[data-conn-id]')).find(li=>li.dataset.connId===id) || null; },
  collapseConn(id){ const li = this.getConnLi(id); if(!li) return; const sub = li.querySelector(':scope > ul'); if(sub){ sub.style.display='none'; const tw = li.querySelector(':scope > .node .tw'); if(tw){ tw.textContent='▶'; } } },
  collapseAllConns(){ document.querySelectorAll('#dbTree li[data-conn-id] > ul').forEach(u=>{u.style.display='none'; const tw = u.parentElement.querySelector(':scope > .node .tw'); if(tw){ tw.textContent='▶'; }}); },
  expandAll(){ document.querySelectorAll('#dbTree ul').forEach(u=>u.style.display='block'); },
  collapseAll(){ document.querySelectorAll('#dbTree ul ul').forEach(u=>{u.style.display='none'; const tw = u.parentElement.querySelector(':scope > .node .tw'); if(tw){ tw.textContent='▶'; }}); }
}
/* ---------------- DB Tree Folder / Drag&Drop ---------------- */
const dbFolderUi = (function(){
  let selectedNode = null;
  let draggingLi = null;
  let pendingNewDbTargetLi = null;
  let folderClipboardName = null;

  function getNodeType(li){
    if(!li) return null;
    if(li.dataset.kind === 'folder') return 'folder';  // custom folder
    if(li.dataset.connId) return 'db';                 // connection root
    return null;
  }

  function clearSelection(){
    document.querySelectorAll('#dbTree .node.dbtree-selected')
      .forEach(n=>n.classList.remove('dbtree-selected'));
    selectedNode = null;
  }

  function setSelected(node){
    if(selectedNode === node) return;
    clearSelection();
    selectedNode = node;
    if(node){
      node.classList.add('dbtree-selected');
      node.focus();
    }
  }

  function clearDropIndicators(){
    document.querySelectorAll('#dbTree li.dbtree-drop-target')
      .forEach(li=>li.classList.remove('dbtree-drop-target'));
  }

  function isDescendant(childLi, maybeAncestor){
    let cur = childLi.parentElement;
    while(cur){
      if(cur === maybeAncestor) return true;
      cur = cur.parentElement;
    }
    return false;
  }



  // 전역 클릭으로 폴더 선택 해제: 트리 밖이나 빈 영역 클릭 시 선택 해제
  function initGlobalClickClear(){
    if (document.body && document.body.dataset.dbtreeClickClearBound === '1') return;
    document.addEventListener('click', (e)=>{
      if (e.target.closest('#dbTree .node')) return;
      clearSelection();
    });
    if (document.body) {
      document.body.dataset.dbtreeClickClearBound = '1';
    }
  }


  // 트리 내부 노드 공통 클릭 시 단일 선택 유지
  function initNodeClickSelect(){
    const container = document.getElementById('dbTree');
    if (!container) return;
    if (container.dataset.nodeClickSelectBound === '1') return;
    container.dataset.nodeClickSelectBound = '1';
    container.addEventListener('click', (e)=>{
      // li 기준으로 찾고, 그 안의 .node를 대표 선택 요소로 사용
      const li = e.target.closest('#dbTree li');
      if (!li) return;
      const node = li.querySelector(':scope > .node') || li.querySelector('.node');
      if (!node) return;
      setSelected(node);
    });
  }

  function attachNodeEvents(node, li){
    const t = getNodeType(li);
    if(t !== 'folder' && t !== 'db') return;

    node.draggable = true;

    node.addEventListener('click', ()=>{
      setSelected(node);
    });

    node.addEventListener('dragstart', (e)=>{
      const type = getNodeType(li);
      if(type !== 'folder' && type !== 'db'){
        e.preventDefault();
        return;
      }
      draggingLi = li;
      node.classList.add('dbtree-dragging');
      e.dataTransfer.effectAllowed = 'move';
      e.dataTransfer.setData('text/plain', 'dbtree:'+type);
    });

    node.addEventListener('dragend', ()=>{
      node.classList.remove('dbtree-dragging');
      draggingLi = null;
      clearDropIndicators();
    });

    node.addEventListener('dragover', (e)=>{
      if(!draggingLi) return;
      const type = getNodeType(li);
      if(type !== 'folder' && type !== 'db') return;
      e.preventDefault();
      e.dataTransfer.dropEffect = 'move';
      clearDropIndicators();
      li.classList.add('dbtree-drop-target');
    });

    node.addEventListener('dragleave', ()=>{
      li.classList.remove('dbtree-drop-target');
    });

    node.addEventListener('drop', (e)=>{
      if(!draggingLi) return;
      e.preventDefault();
      clearDropIndicators();

      const targetLi   = li;
      const targetType = getNodeType(targetLi);
      if(!targetType) return;
      if(draggingLi === targetLi) return;

      const dragType = getNodeType(draggingLi);
      if(dragType !== 'folder' && dragType !== 'db') return;

      // don't allow folder to be dropped into itself or its descendants
      if(dragType === 'folder' && isDescendant(targetLi, draggingLi)) return;

      if(targetType === 'folder'){
        let childUl = targetLi.querySelector(':scope > ul');
        if(!childUl){
          childUl = document.createElement('ul');
          targetLi.appendChild(childUl);
        }
        childUl.appendChild(draggingLi);
      }else{
        const parentUl = targetLi.parentElement;
        parentUl.insertBefore(draggingLi, targetLi.nextSibling);
      }
    });
  }

  function ensureRootUl(){
    const container = document.getElementById('dbTree');
    if(!container) return null;
    let rootUl = container.querySelector(':scope > ul');
    if(!rootUl){
      rootUl = document.createElement('ul');
      container.innerHTML = '';
      container.appendChild(rootUl);
    }
    return rootUl;
  }

  // 같은 UL 내에서 폴더(kind==='folder')를 위로 정렬
  function sortFolderFirst(parentUl){
    if(!parentUl) return;
    if(typeof sortDbTreeDepth === 'function'){
      sortDbTreeDepth(parentUl);
      return;
    }
    const items = Array.from(parentUl.querySelectorAll(':scope > li'));
    if(!items.length) return;
    const folders = [];
    const others  = [];
    items.forEach(function(li){
      if(li.dataset && li.dataset.kind === 'folder'){
        folders.push(li);
      }else{
        others.push(li);
      }
    });
    if(!folders.length || !others.length) return;
    items.forEach(function(li){
      parentUl.removeChild(li);
    });
    folders.concat(others).forEach(function(li){
      parentUl.appendChild(li);
    });
  }



  
function getUniqueName(parentUl, baseName, kind){
    if(!parentUl) return baseName;
    const items = Array.from(parentUl.querySelectorAll(':scope > li'));
    if(!items.length) return baseName;

    const exists = (name)=>{
      return items.some(li=>{
        if(!li.dataset) return false;
        if(kind && li.dataset.kind !== kind) return false;
        const lbl = (li.dataset.label || '').trim();
        return lbl === name;
      });
    };

    let candidate = baseName;
    if(!exists(candidate)) return candidate;

    let n = 1;
    while(n < 1000){
      candidate = baseName + '(' + n + ')';
      if(!exists(candidate)) return candidate;
      n++;
    }
    return candidate;
  }

  
function startFolderLabelEdit(li, opts){
    opts = opts || {};
    const node = li.querySelector(':scope > .node');
    if(!node) return;
    const labelSpan =
      node.querySelector('span:nth-of-type(3)') ||
      node.querySelector('span:nth-of-type(2)');
    if(!labelSpan) return;

    const originalText = (labelSpan.textContent || '').trim();
    const input = document.createElement('input');
    input.type = 'text';
    input.value = originalText;
    input.className = 'dbtree-folder-edit';

    // 오류 메시지용 툴팁 요소
    let err = node.querySelector(':scope > .dbtree-folder-edit-error');
    if(!err){
      err = document.createElement('div');
      err.className = 'dbtree-folder-edit-error';
      node.appendChild(err);
    }
    err.textContent = '';
    err.style.display = 'none';

    labelSpan.style.display = 'none';
    const tagSpan = node.querySelector(':scope > .tag');
    if(tagSpan){
      node.insertBefore(input, tagSpan);
    }else{
      node.appendChild(input);
    }
    input.focus();
    input.select();

    function hasDuplicateName(val){
      const parentUl = li.parentElement;
      if(!parentUl) return false;
      const siblings = parentUl.querySelectorAll(':scope > li');
      val = (val || '').trim();
      for(const sib of siblings){
        if(sib === li) continue;
        if(sib.dataset && sib.dataset.kind === 'folder'){
          const sibNode = sib.querySelector(':scope > .node');
          if(!sibNode) continue;
          const sibLabelSpan =
            sibNode.querySelector('span:nth-of-type(3)') ||
            sibNode.querySelector('span:nth-of-type(2)');
          if(!sibLabelSpan) continue;
          const sibText = (sibLabelSpan.textContent || '').trim();
          if(!sibText) continue;
          if(sibText === val){
            return true;
          }
        }
      }
      return false;
    }

    function showError(msg){
      if(!err) return;
      err.textContent = msg || '';
      err.style.display = msg ? 'block' : 'none';
    }

    let finished = false;

    function cleanup(){
      if(finished) return;
      finished = true;
      input.removeEventListener('keydown', onKey);
      document.removeEventListener('mousedown', onDocMouseDown);
    }

    function finish(save){
      const raw = input.value;
      const val = (raw || '').trim();

      if(!save){
        // 취소
        showError('');
        if(input.parentElement){
          node.removeChild(input);
        }
        labelSpan.style.display = '';
        if(opts.isNew){
          const parentUl = li.parentElement;
          if(parentUl){
            parentUl.removeChild(li);
          }
        }
        cleanup();
        return;
      }

      if(!val){
        // 빈 값은 새 폴더면 취소, 기존 폴더는 이름 유지
        showError('');
        if(input.parentElement){
          node.removeChild(input);
        }
        labelSpan.style.display = '';
        if(opts.isNew){
          const parentUl = li.parentElement;
          if(parentUl){
            parentUl.removeChild(li);
          }
        }
        cleanup();
        return;
      }

      if(hasDuplicateName(val)){
        // 같은 Depth 폴더명 중복 -> 삭제하지 않고 편집 상태 유지
        showError('같은 위치에 동일한 폴더명이 이미 있습니다.');
        setTimeout(()=>{
          input.focus();
          input.select();
        }, 0);
        return;
      }

      // 정상 저장
      showError('');
      labelSpan.textContent = val;
      labelSpan.style.display = '';
      li.dataset.label = val;
      if(input.parentElement){
        node.removeChild(input);
      }
      setSelected(node);
      cleanup();
    }

    function onKey(e){
      if(e.key === 'Enter'){
        e.preventDefault();
        finish(true);
      }else if(e.key === 'Escape'){
        e.preventDefault();
        finish(false);
      }
    }

    function onDocMouseDown(e){
      // 인풋 자체를 클릭한 경우에는 편집 유지
      if(e.target === input || input.contains(e.target)){
        return;
      }
      // 그 외 영역 클릭 시 현재 값으로 저장
      finish(true);
    }

    input.addEventListener('keydown', onKey);
    document.addEventListener('mousedown', onDocMouseDown);
    input.addEventListener('input', function(){
      showError('');
    });
  }


function startTabTitleEdit(tabEl){
  if(!tabEl) return;
  const titleSpan = tabEl.querySelector('.tab-title');
  if(!titleSpan) return;

  const fullText = (titleSpan.textContent || '').trim();
  const tabId = tabEl.dataset.tabId;
  let coreOriginal = '';

  try{
    if (typeof state !== 'undefined' && state && Array.isArray(state.tabs)) {
      const t = state.tabs.find(t => String(t.id) === String(tabId));
      if (t && t.title) {
        coreOriginal = String(t.title);
      }
    }
  }catch(e){
    console.warn('startTabTitleEdit: read core title from state error', e);
  }

  // state 에 코어 제목이 없으면, 표시 문자열에서 접두사 제거해서 코어 추출
  if (!coreOriginal) {
    try{
      if (typeof getTabCoreTitle === 'function') {
        coreOriginal = getTabCoreTitle(fullText);
      } else {
        coreOriginal = fullText;
      }
    }catch(e){
      console.warn('startTabTitleEdit: fallback core title build error', e);
      coreOriginal = fullText;
    }
  }

  const input = document.createElement('input');
  input.type = 'text';
  // 이름 변경 입력창에는 항상 코어 제목만 보여준다.
  input.value = coreOriginal;
  input.className = 'tab-title-edit';

  // 숨기고 input 삽입
  titleSpan.style.display = 'none';
  titleSpan.parentElement.insertBefore(input, titleSpan);

  input.focus();
  input.select();

  let finished = false;
  function cleanup(){
    if(finished) return;
    finished = true;
    input.removeEventListener('keydown', onKey);
    input.removeEventListener('blur', onBlur);
  }

  function apply(val){
    const v = (val || '').trim();
    const core = v || coreOriginal || fullText;

    if(input.parentElement){
      input.parentElement.removeChild(input);
    }

    try{
      if(typeof state !== 'undefined' && state && Array.isArray(state.tabs)){
        const tab = state.tabs.find(t => String(t.id) === String(tabId));
        if(tab){
          // 내부 상태에는 코어 제목만 저장
          tab.title = core;
        }
      }
      // 전체 탭을 다시 렌더링해서, 접두사(＜DB라벨＞)는 통일된 규칙대로 다시 붙인다.
      if (typeof ui !== 'undefined' && ui) {
        if (typeof ui.renderTabs === 'function') {
          ui.renderTabs();
        }
        if (typeof ui._scheduleAutoSave === 'function') {
          ui._scheduleAutoSave();
        }
      }
    }catch(e){
      console.warn('startTabTitleEdit: update tab title error', e);
    }
  }

  function finish(applyChange){
    if(applyChange){
      apply(input.value);
    }else{
      // 취소: 원래 표시 문자열 복원
      titleSpan.style.display = '';
      if(input.parentElement){
        input.parentElement.removeChild(input);
      }
    }
    cleanup();
  }

  function onKey(e){
    if(e.key === 'Enter'){
      e.preventDefault();
      finish(true);
    }else if(e.key === 'Escape'){
      e.preventDefault();
      finish(false);
    }
  }
  function onBlur(){
    finish(true);
  }

  input.addEventListener('keydown', onKey);
  input.addEventListener('blur', onBlur);
}

function startDbLabelEdit(li){
  // 연결 중인 DB는 이름 변경 불가 (연결 상태에서는 폴더만 이름 변경 허용)
  try{
    if (li && li.dataset && li.dataset.connId){
      var cid = li.dataset.connId;
      if (typeof state !== 'undefined' && state && state.connStates && state.connStates[cid]){
        return;
      }
    }
  }catch(e){
    console.warn('startDbLabelEdit: rename blocked for connected DB', e);
  }

  if(!li) return;
  const node = li.querySelector(':scope > .node');
  if(!node) return;
  const labelSpan =
    node.querySelector('span:nth-of-type(3)') ||
    node.querySelector('span:nth-of-type(2)');
  if(!labelSpan) return;

  const originalText = (labelSpan.textContent || '').trim();
  const input = document.createElement('input');
  input.type = 'text';
  input.value = originalText;
  input.className = 'dbtree-folder-edit';

  // DB 이름 편집 시에도 폴더와 동일한 에러 툴팁을 재사용
  let err = node.querySelector(':scope > .dbtree-folder-edit-error');
  if(!err){
    err = document.createElement('div');
    err.className = 'dbtree-folder-edit-error';
    node.appendChild(err);
  }
  // 이름 변경 시작 시에는 항상 에러 툴팁을 숨긴다
  err.textContent = '';
  err.style.display = 'none';

  labelSpan.style.display = 'none';
  const tagSpan = node.querySelector(':scope > .tag');
  if(tagSpan){
    node.insertBefore(input, tagSpan);
  }else{
    node.appendChild(input);
  }
  input.focus();
  input.select();

  function showError(msg){
    if(!err) return;
    err.textContent = msg || '';
    err.style.display = msg ? 'block' : 'none';
  }

  let finished = false;

  function cleanup(){
    if(finished) return;
    finished = true;
    input.removeEventListener('keydown', onKey);
    document.removeEventListener('mousedown', onDocMouseDown);
  }

  function finish(save){
    const raw = input.value;
    const val = (raw || '').trim();

    if(!save){
      // 취소: 원래 이름 유지
      showError('');
      if(input.parentElement){
        input.parentElement.removeChild(input);
      }
      labelSpan.style.display = '';
      cleanup();
      return;
    }

    if(!val){
      // 빈 값이면 원래 이름 유지
      showError('');
      if(input.parentElement){
        input.parentElement.removeChild(input);
      }
      labelSpan.style.display = '';
      cleanup();
      return;
    }

    // 동일 depth 내에서 DB 이름 중복 체크 (자기 자신은 제외)
    const parentUl = li.parentElement;
    if(parentUl){
      const siblings = parentUl.querySelectorAll(':scope > li');
      const trimmed = (val || '').trim();
      let hasDup = false;
      for(const sib of siblings){
        if(sib === li) continue;
        if(!sib.dataset) continue;
        // DB 노드(kind='conn')만 검사
        if(sib.dataset.kind && sib.dataset.kind !== 'conn') continue;
        const sibLabel = (sib.dataset.label || '').trim();
        if(sibLabel && sibLabel === trimmed){
          hasDup = true;
          break;
        }
      }
      if(hasDup){
        showError('같은 위치에 동일한 데이터베이스명이 이미 있습니다.');
        // 다시 편집 가능하도록 포커스 복원
        setTimeout(()=>{
          input.focus();
          input.select();
        }, 0);
        return;
      }
    }


    // 라벨 및 데이터셋 갱신
    showError('');
    labelSpan.textContent = val;
    labelSpan.style.display = '';
    if(input.parentElement){
      input.parentElement.removeChild(input);
    }

    li.dataset.label = val;

    // 상태 라벨 갱신
    try{
      if(typeof state !== 'undefined' && state && Array.isArray(state.availableConns)){
        const connId = li.dataset.connId;
        if(connId){
          const found = state.availableConns.find(c => c.id === connId);
          if(found){
            found.label = val;
          }
        }
      }
    }catch(e){
      console.warn('startDbLabelEdit: update state label error', e);
    }

    cleanup();
  }

  function onKey(e){
    if(e.key === 'Enter'){
      e.preventDefault();
      finish(true);
    }else if(e.key === 'Escape'){
      e.preventDefault();
      finish(false);
    }
  }

  function onDocMouseDown(e){
    // 인풋 자체를 클릭한 경우에는 편집 유지
    if(e.target === input || input.contains(e.target)){
      return;
    }
    // 그 외 영역 클릭 시 현재 값으로 저장
    finish(true);
  }

  input.addEventListener('keydown', onKey);
  document.addEventListener('mousedown', onDocMouseDown);
}
function getNextFolderLabel(targetUl){
    const base = '새 폴더';
    if(!targetUl){
      return base;
    }
    const used = new Set();
    targetUl.querySelectorAll(':scope > li').forEach(li=>{
      if(!li.dataset || li.dataset.kind !== 'folder') return;
      const label = (li.dataset.label || '').trim();
      if(!label) return;
      if(label === base){
        used.add(0);
        return;
      }
      const m = label.match(/^새 폴더\((\d+)\)$/);
      if(m){
        used.add(parseInt(m[1], 10));
      }
    });
    if(used.size === 0){
      return base;
    }
    let n = 0;
    while(used.has(n)){
      n++;
    }
    return n === 0 ? base : base + '(' + n + ')';
  }
function addFolder(){
    const rootUl = ensureRootUl();
    if(!rootUl) return;

    let targetUl = null;
    if(!selectedNode){
      targetUl = rootUl;
    }else{
      const selLi   = selectedNode.closest('li');
      const selType = getNodeType(selLi);
      if(selType === 'folder'){
        let selChildUl = selLi.querySelector(':scope > ul');
        if(!selChildUl){
          selChildUl = document.createElement('ul');
          selLi.appendChild(selChildUl);
        }
        targetUl = selChildUl;
      }else if(selType === 'db'){
        // DB 선택 시: DB와 같은 depth(형제)로 생성
        const parentUl = selLi.parentElement;
        targetUl = parentUl;
      }else{
        // 테이블/컬럼 등 기타 노드 선택 시: 폴더는 루트에 생성
        targetUl = rootUl;
      }
    }

    const folderLabel = getNextFolderLabel(targetUl || rootUl);
    const li = tree.node(folderLabel, '▶', 'folder');
    const childUl = document.createElement('ul');
    li.appendChild(childUl);

    if(!selectedNode){
      rootUl.appendChild(li);
    }else{
      const selLi   = selectedNode.closest('li');
      const selType = getNodeType(selLi);
      if(selType === 'folder'){
        targetUl.appendChild(li);
      }else if(selType === 'db'){
        const parentUl = selLi.parentElement;
        parentUl.insertBefore(li, selLi.nextSibling);
      }else{
        rootUl.appendChild(li);
      }
    }

    if(targetUl){
      sortFolderFirst(targetUl);
    }

    const node = li.querySelector(':scope > .node');
    if(node){
      attachNodeEvents(node, li);
      // 폴더 컨텍스트 메뉴 연결
      if (typeof treeCtxConfig !== 'undefined' && typeof treeCtx !== 'undefined') {
        node.addEventListener('contextmenu', (e)=>{
          e.preventDefault();
          if (typeof dbFolderUi !== 'undefined' && typeof dbFolderUi.setSelectedNode === 'function') {
            dbFolderUi.setSelectedNode(node);
          }
          const li = node.parentElement;
          const kind = li.dataset.kind || 'folder';
          const cfg = treeCtxConfig[kind] || treeCtxConfig._default;
          if(!cfg) return;
          const info = tree.buildNodeInfo(li);
          treeCtx.open(e.clientX, e.clientY, info, cfg);
        });
      }
      setSelected(node);
      startFolderLabelEdit(li, { isNew: true });
    }
  }
  function renameFolder(){
    if(!selectedNode){
      window.alert('이름을 변경할 폴더를 먼저 선택하세요.');
      return;
    }
    const li = selectedNode.closest('li');
    if(getNodeType(li) !== 'folder'){
      window.alert('폴더만 이름 변경이 가능합니다.');
      return;
    }
    startFolderLabelEdit(li, { isNew: false });
  }
  function deleteFolder(){
    if(!selectedNode){
      window.alert('삭제할 폴더를 먼저 선택하세요.');
      return;
    }
    const li = selectedNode.closest('li');
    if(getNodeType(li) !== 'folder'){
      window.alert('폴더만 삭제할 수 있습니다.');
      return;
    }
    const labelSpan =
      selectedNode.querySelector('span:nth-of-type(3)') ||
      selectedNode.querySelector('span:nth-of-type(2)');
    const label = labelSpan ? labelSpan.textContent.trim() : '';
    if(!window.confirm('폴더 "'+label+'" 및 그 하위 항목을 모두 삭제하시겠습니까?')) return;
    const parentUl = li.parentElement;
    if(parentUl){ parentUl.removeChild(li); }
    clearSelection();
  }

  function copyFolderFromLi(li){
    if(!li){
      window.alert('복사할 폴더를 찾을 수 없습니다.');
      return;
    }
    if(getNodeType(li) !== 'folder'){
      window.alert('폴더만 복사할 수 있습니다.');
      return;
    }
    const label = (li.dataset.label || '').trim() || '새 폴더';
    if (typeof dbTreeClipboard !== 'undefined') {
      dbTreeClipboard.type   = 'folder';
      dbTreeClipboard.label  = label;
      dbTreeClipboard.connId = null;
      dbTreeClipboard.folderLi = li;
    }
  }

  function copyFolderChildrenRecursive(srcFolderLi, dstFolderLi){
    if(!srcFolderLi || !dstFolderLi) return;

    const srcChildUl = srcFolderLi.querySelector(':scope > ul');
    if(!srcChildUl) return;

    let dstChildUl = dstFolderLi.querySelector(':scope > ul');
    if(!dstChildUl){
      dstChildUl = document.createElement('ul');
      dstFolderLi.appendChild(dstChildUl);
    }

    const srcChildLis = Array.from(srcChildUl.querySelectorAll(':scope > li'));

    srcChildLis.forEach((srcChildLi)=>{
      const childType = getNodeType(srcChildLi);
      if(!childType) return;

      if(childType === 'folder'){
        const baseName = (srcChildLi.dataset.label || '').trim() || '새 폴더';
        const folderName = getUniqueName(dstChildUl, baseName, 'folder');

        const newFolderLi = tree.node(folderName, '▶', 'folder');
        newFolderLi.dataset.label = folderName;

        const newFolderChildUl = document.createElement('ul');
        newFolderLi.appendChild(newFolderChildUl);
        dstChildUl.appendChild(newFolderLi);

        const node = newFolderLi.querySelector(':scope > .node');
        if(node){
          attachNodeEvents(node, newFolderLi);
          // 폴더 컨텍스트 메뉴 연결
          if (typeof treeCtxConfig !== 'undefined' && typeof treeCtx !== 'undefined') {
            node.addEventListener('contextmenu', (e)=>{
              e.preventDefault();
              if (typeof dbFolderUi !== 'undefined' && typeof dbFolderUi.setSelectedNode === 'function') {
                dbFolderUi.setSelectedNode(node);
              }
              const li = node.parentElement;
              const kind = li.dataset.kind || 'folder';
              const cfg = treeCtxConfig[kind] || treeCtxConfig._default;
              if(!cfg) return;
              const info = tree.buildNodeInfo(li);
              treeCtx.open(e.clientX, e.clientY, info, cfg);
            });
          }
        }

        copyFolderChildrenRecursive(srcChildLi, newFolderLi);
      }else if(childType === 'db'){
        const srcConnId = (srcChildLi.dataset.connId || '').trim();
        if(!srcConnId) return;

        let dbLabel = (srcChildLi.dataset.label || '').trim();
        if(!dbLabel){
          const srcNode = srcChildLi.querySelector(':scope > .node');
          if(srcNode){
            dbLabel = srcNode.textContent.trim();
          }else{
            dbLabel = srcConnId;
          }
        }

        // 원본과 다른 새 connId 생성 (폴더 복사 시에도 각 DB는 독립적으로 동작)
        let newConnId = '';
        try{
          const ts  = Date.now().toString(36);
          const rnd = Math.floor(Math.random()*1e6).toString(36);
          newConnId = (srcConnId || 'local') + '-copy-' + ts + '-' + rnd;
        }catch(e){
          console.warn('copyFolderChildrenRecursive: newConnId generate error', e);
        }
        if(!newConnId){
          const ts  = Date.now().toString(36);
          const rnd = Math.floor(Math.random()*1e6).toString(36);
          newConnId = 'local-' + ts + '-' + rnd;
        }

        // 가능한 경우 원본 프로필 복사
        let profile = null;
        try{
          if (typeof state !== 'undefined' && state && Array.isArray(state.availableConns)) {
            const found = state.availableConns.find(c => c && c.id === srcConnId);
            if (found && typeof found.profile !== 'undefined') {
              profile = found.profile;
            }
          }
        }catch(e){
          console.warn('copyFolderChildrenRecursive: profile clone error', e);
        }

        try{
          pendingNewDbTargetLi = dstFolderLi;
          let env = null;
          try{
            if (typeof state !== 'undefined' && state && state.connEnvs && srcConnId){
              env = state.connEnvs[srcConnId] || null;
            }
          }catch(e){
            console.warn('copyFolderChildrenRecursive: env clone error', e);
          }
          addDbNode({ id: newConnId, label: dbLabel, profile: profile, env: env });
        }catch(e){
          console.warn('copyFolderChildrenRecursive: addDbNode error', e);
        }
      }
    });

    if(dstChildUl){
      sortFolderFirst(dstChildUl);
    }
  }

  function pasteFolderAtLi(targetLi){
    if (typeof dbTreeClipboard === 'undefined' || !dbTreeClipboard || !dbTreeClipboard.type) {
      window.alert('복사된 정보가 없습니다.');
      return;
    }
    const rootUl = ensureRootUl();
    if(!rootUl) return;

    // 원본 폴더 자기 자신/하위에는 붙여넣기 금지
    if (dbTreeClipboard.type === 'folder' && targetLi && dbTreeClipboard.folderLi) {
      if (targetLi === dbTreeClipboard.folderLi || isDescendant(targetLi, dbTreeClipboard.folderLi)) {
        window.alert('원본 폴더 내부에는 붙여넣기할 수 없습니다.');
        return;
      }
    }

    // 폴더 클립보드 → 폴더 붙여넣기
    if (dbTreeClipboard.type === 'folder') {
      const baseName = dbTreeClipboard.label || '새 폴더';

      let targetUl = null;
      let selType = null;

      if(!targetLi){
        // 빈 영역 붙여넣기 → 루트에 생성
        targetUl = rootUl;
      }else{
        selType = getNodeType(targetLi);
        if(selType === 'folder'){
          let selChildUl = targetLi.querySelector(':scope > ul');
          if(!selChildUl){
            selChildUl = document.createElement('ul');
            targetLi.appendChild(selChildUl);
          }
          targetUl = selChildUl;
        }else{
          const parentUl = targetLi.parentElement;
          targetUl = parentUl || rootUl;
        }
      }

      if(!targetUl){
        targetUl = rootUl;
      }

      // 동일 depth 내에서 이름 중복 방지
      const folderName = getUniqueName(targetUl, baseName, 'folder');

      // 새 폴더 노드 생성 (이름만 복사, 하위 내용은 복사하지 않음)
      const li = tree.node(folderName, '▶', 'folder');
      const childUl = document.createElement('ul');
      li.appendChild(childUl);

      // 실제 삽입
      if(!targetLi){
        targetUl.appendChild(li);
      }else{
        if(selType === 'folder'){
          targetUl.appendChild(li);
        }else{
          const parentUl = targetLi.parentElement;
          if(parentUl){
            parentUl.insertBefore(li, targetLi.nextSibling);
          }else{
            rootUl.appendChild(li);
          }
        }
      }

      // 하위 폴더 및 DB까지 복사
      if (dbTreeClipboard.folderLi) {
        try{
          copyFolderChildrenRecursive(dbTreeClipboard.folderLi, li);
        }catch(e){
          console.warn('pasteFolderAtLi: copyFolderChildrenRecursive error', e);
        }
      }

      if(targetUl){
        sortFolderFirst(targetUl);
      }

      const node = li.querySelector(':scope > .node');
      if(node){
        attachNodeEvents(node, li);
        // 폴더 컨텍스트 메뉴 연결
        if (typeof treeCtxConfig !== 'undefined' && typeof treeCtx !== 'undefined') {
          node.addEventListener('contextmenu', (e)=>{
            e.preventDefault();
            if (typeof dbFolderUi !== 'undefined' && typeof dbFolderUi.setSelectedNode === 'function') {
              dbFolderUi.setSelectedNode(node);
            }
            const li = node.parentElement;
            const kind = li.dataset.kind || 'folder';
            const cfg = treeCtxConfig[kind] || treeCtxConfig._default;
            if(!cfg) return;
            const info = tree.buildNodeInfo(li);
            treeCtx.open(e.clientX, e.clientY, info, cfg);
          });
        }
        setSelected(node);
      }
      return;
    }



    // 데이터베이스 클립보드 → DB 붙여넣기
    if (dbTreeClipboard.type === 'db') {
      const srcConnId = dbTreeClipboard.connId;
      if(!srcConnId){
        window.alert('붙여넣기할 데이터베이스 정보를 찾을 수 없습니다.');
        return;
      }

      const baseLabel = dbTreeClipboard.label || srcConnId;

      let targetUlForDb = null;
      if(!targetLi){
        targetUlForDb = rootUl;
      }else{
        const selType = getNodeType(targetLi);
        if(selType === 'folder'){
          let selChildUl = targetLi.querySelector(':scope > ul');
          if(!selChildUl){
            selChildUl = document.createElement('ul');
            targetLi.appendChild(selChildUl);
          }
          targetUlForDb = selChildUl;
        }else if(selType === 'db'){
          const parentUl = targetLi.parentElement;
          targetUlForDb = parentUl || rootUl;
        }else{
          targetUlForDb = rootUl;
        }
      }

      if(!targetUlForDb){
        targetUlForDb = rootUl;
      }

      // 동일 depth 내에서 이름 중복 방지 (DB 노드)
      const label = getUniqueName(targetUlForDb, baseLabel, 'conn');

      // 원본과 독립적인 새 connId 생성
      let newConnId = '';
      try{
        const ts  = Date.now().toString(36);
        const rnd = Math.floor(Math.random()*1e6).toString(36);
        newConnId = (srcConnId || 'local') + '-copy-' + ts + '-' + rnd;
      }catch(e){
        console.warn('pasteFolderAtLi: newConnId generate error', e);
      }
      if(!newConnId){
        const ts  = Date.now().toString(36);
        const rnd = Math.floor(Math.random()*1e6).toString(36);
        newConnId = 'local-' + ts + '-' + rnd;
      }

      // 가능한 경우 원본 프로필 복사
      let profile = null;
      try{
        if (typeof state !== 'undefined' && state && Array.isArray(state.availableConns)) {
          const found = state.availableConns.find(c => c && c.id === srcConnId);
          if (found && typeof found.profile !== 'undefined') {
            profile = found.profile;
          }
        }
      }catch(e){
        console.warn('pasteFolderAtLi: profile clone error', e);
      }

      try{
        pendingNewDbTargetLi = targetLi || null;
        let env = null;
        try{
          if (typeof state !== 'undefined' && state && state.connEnvs && dbTreeClipboard.connId){
            env = state.connEnvs[dbTreeClipboard.connId] || null;
          }
        }catch(e){
          console.warn('pasteFolderAtLi: env clone error', e);
        }
        addDbNode({ id: newConnId, label: label, profile: profile, env: env });
      }catch(e){
        console.warn('pasteFolderAtLi: db paste error', e);
      }
      return;
    }


    window.alert('지원하지 않는 클립보드 타입입니다.');
  }


function initToolbar(){
    const addBtn = document.getElementById('dbtreeAddFolderBtn');
    if(addBtn){
      addBtn.addEventListener('click', addFolder);
    }

    const addDbBtn = document.getElementById('dbtreeAddDbBtn');
    if(addDbBtn){
      addDbBtn.addEventListener('click', ()=>{
        try{
          const info = getSelectionInfo();
          pendingNewDbTargetLi = info ? info.li : null;

          if (typeof connSettings !== 'undefined' && connSettings && typeof connSettings.openNew === 'function') {
            connSettings.openNew();
          }
        }catch(e){
          console.warn('dbtreeAddDbBtn click error', e);
        }
      });
    }

    // 트리 밖/빈 영역 클릭 시 선택 해제
    initGlobalClickClear();
    // 트리 내부 노드 공통 클릭 시 단일 선택 유지
    initNodeClickSelect();
  }

  function initAfterRender(){
    const container = document.getElementById('dbTree');
    if(!container) return;
    const rootUl = container.querySelector(':scope > ul');
    if(!rootUl) return;

    rootUl.querySelectorAll(':scope > li').forEach(li=>{
      const t = getNodeType(li);
      if(t !== 'folder' && t !== 'db') return;
      const node = li.querySelector(':scope > .node');
      if(node) attachNodeEvents(node, li);
    });

    // 빈 영역 우클릭 컨텍스트 메뉴 (Database 생성 / 폴더 생성 / 붙여넣기)
    container.addEventListener('contextmenu', (e)=>{
      const target = e.target;
      if(target && target.closest && target.closest('.node')){
        // 노드 우클릭은 기존 컨텍스트 메뉴가 처리
        return;
      }
      if(!container.contains(e.target)) return;

      e.preventDefault();

      try{
        if(typeof treeCtxConfig === 'undefined' || typeof treeCtx === 'undefined' || !treeCtx || typeof treeCtx.open !== 'function'){
          return;
        }

        // 선택 해제
        clearSelection();

        const items = treeCtxConfig['dbtree-empty'] || [
          { act: 'dbtree-create-db',     label: 'Database 생성', icon: 'fa-solid fa-database' },
          { act: 'dbtree-create-folder', label: '폴더 생성',     icon: 'fa-regular fa-folder' },
          { act: 'dbtree-paste',         label: '붙여넣기',     icon: 'fa-solid fa-clipboard' }
        ];
        treeCtx.open(e.clientX, e.clientY, null, items);
      }catch(err){
        console.warn('dbTree empty contextmenu error', err);
      }
    });
  }

  
  function addDbNode(conn){
    if(!conn) return;
    const rootUl = ensureRootUl();
    if(!rootUl) return;

    let label = (conn.label || conn.id || '').trim();
    if(!label){
      return;
    }

    let connId = (conn.id || '').trim();
    if(!connId){
      const ts  = Date.now().toString(36);
      const rnd = Math.floor(Math.random()*1e6).toString(36);
      connId = 'local-' + ts + '-' + rnd;
    }

    try{
      if (typeof state !== 'undefined' && state) {
        const list = state.availableConns || [];
        const existingIdx = list.findIndex(c => c && c.id === connId);
        if(existingIdx === -1){
          list.push({ id: connId, label: label, profile: conn.profile || null, env: conn.env || null });
        }else{
          const c = list[existingIdx];
          list[existingIdx] = {
            id: connId,
            label: label,
            profile: (conn.profile != null ? conn.profile : (c.profile || null)),
            env: (conn.env != null ? conn.env : (c.env || null))
          };
        }
        state.availableConns = list;

        // 환경 정보 별도 맵
        if (!state.connEnvs) {
          state.connEnvs = {};
        }
        if (conn.env != null) {
          state.connEnvs[connId] = conn.env || '';
        } else if (typeof state.connEnvs[connId] === 'undefined') {
          state.connEnvs[connId] = '';
        }
      }
    }catch(e){
      console.warn('addDbNode: state.availableConns update error', e);
    }

    const li = tree.node(label, '▶', 'conn');
    li.dataset.connId = connId;
    if (state && state.connEnvs && typeof state.connEnvs[connId] !== 'undefined') {
      li.dataset.env = state.connEnvs[connId];
    }
    attachConnPinControl(li, connId);

    const nodeEl = li.querySelector('.node');
    if(nodeEl){
      // 상태 점 아이콘
      const dot = document.createElement('i');
      dot.className = 'fa-solid fa-circle conn-off conn-dot';
      nodeEl.insertBefore(dot, nodeEl.children[1] || null);

      // 더블클릭 = 연결 시도
      nodeEl.addEventListener('dblclick', ()=>{
        try{
          const isOn = !!(state.connStates && state.connStates[connId]);
          if (isOn) {
            const liNode = nodeEl.closest('li');
            if (liNode) {
              tree.toggleOne(liNode);
            }
            return;
          }
          if(typeof ui !== 'undefined' && ui && typeof ui.openConnReasonModal === 'function'){
            ui._pendingConnSelectUsed   = false;
            ui._pendingConnAfterConnect = null;
            ui.openConnReasonModal(connId);
          }
        }catch(e){
          console.warn('addDbNode: dblclick handler error', e);
        }
      });

      // 우클릭 = 컨텍스트 메뉴
      nodeEl.addEventListener('contextmenu', (e)=>{
        try{
          e.preventDefault();
          // 우클릭 시에도 폴더/DB 단일 선택 유지: 기존 선택 모두 해제 후 이 DB만 선택
          document.querySelectorAll('#dbTree .node.dbtree-selected')
            .forEach(n=>n.classList.remove('dbtree-selected'));
          selectedNode = nodeEl;
          nodeEl.classList.add('dbtree-selected');
          nodeEl.focus();

          if(typeof ctxMenu !== 'undefined' && ctxMenu && typeof ctxMenu.open === 'function'){
            ctxMenu.open(e.clientX, e.clientY, connId);
          }
        }catch(err){
          console.warn('addDbNode: contextmenu handler error', err);
        }
      });

      // 폴더/DB 드래그앤드랍 이벤트
      attachNodeEvents(nodeEl, li);
    }

    // 삽입 위치 결정: 우선 pendingNewDbTargetLi, 없으면 현재 selectedNode
    let targetLi = pendingNewDbTargetLi;
    if(!targetLi && selectedNode){
      targetLi = selectedNode.closest('li');
    }

    let targetUl = null;
    if(!targetLi){
      targetUl = rootUl;
      rootUl.appendChild(li);
    }else{
      const selType = getNodeType(targetLi);
      if(selType === 'folder'){
        let selChildUl = targetLi.querySelector(':scope > ul');
        if(!selChildUl){
          selChildUl = document.createElement('ul');
          targetLi.appendChild(selChildUl);
        }
        targetUl = selChildUl;
        selChildUl.appendChild(li);
      }else if(selType === 'db'){
        const parentUl = targetLi.parentElement;
        targetUl = parentUl || rootUl;
        if(parentUl){
          parentUl.insertBefore(li, targetLi.nextSibling);
        }else{
          rootUl.appendChild(li);
        }
      }else{
        targetUl = rootUl;
        rootUl.appendChild(li);
      }
    }

    if(targetUl){
      sortFolderFirst(targetUl);
    }

    // 한 번 사용 후 초기화
    pendingNewDbTargetLi = null;

    // UI 동기화: 셀렉트/상태칩/badge
    if(typeof ui !== 'undefined' && ui){
      try{
        if(typeof ui.renderConnSelect === 'function'){
          ui.renderConnSelect();
        }else if(typeof ui.syncConnSelect === 'function'){
          ui.syncConnSelect();
        }
        if(typeof ui.updateConnStatusChip === 'function'){
          ui.updateConnStatusChip();
        }
      }catch(e){
        console.warn('addDbNode: ui sync error', e);
      }
    }
    if(typeof tree !== 'undefined' && tree && typeof tree.updateConnBadges === 'function'){
      try{
        tree.updateConnBadges();
      }catch(e){
        console.warn('addDbNode: updateConnBadges error', e);
      }
    }

    // 새 노드를 현재 선택으로
    if(nodeEl){
      setSelected(nodeEl);
    }
  }

  function getSelectionInfo(){
    if(!selectedNode) return null;
    const li = selectedNode.closest('li');
    if(!li) return null;
    const type = getNodeType(li);
    if(!type) return null;
    return { node: selectedNode, li, type };
  }

function setSelectedFromNode(node){
    if(node){
      setSelected(node);
    }else{
      clearSelection();
    }
  }

  return {
    initToolbar,
    initAfterRender,
    addFolder,
    renameFolder,
    deleteFolder,
    setSelectedNode: setSelectedFromNode,
    addDbNode,
    getSelectionInfo,
    copyFolder: copyFolderFromLi,
    pasteFolder: pasteFolderAtLi,
    startFolderLabelEdit,
    startDbLabelEdit
  };
})();;

// ---------------- DB Tree Keyboard Shortcuts ----------------
(function initDbTreeKeyboardShortcuts(){
  if (typeof document === 'undefined') return;

  function getTreeSelectionInfo(){
    // dbFolderUi의 선택 정보를 우선 사용
    try{
      if (typeof dbFolderUi !== 'undefined' &&
          dbFolderUi &&
          typeof dbFolderUi.getSelectionInfo === 'function') {
        const info = dbFolderUi.getSelectionInfo();
        if (info && info.li) {
          const li = info.li;
          const isDb = !!li.dataset.connId;
          const isFolder = (li.dataset.kind === 'folder');
          return {
            node: info.node || li.querySelector(':scope > .node'),
            li,
            isDb,
            isFolder
          };
        }
      }
    }catch(e){
      console.warn('dbTree shortcut getSelectionInfo error', e);
    }

    // fallback: .dbtree-selected 기준
    const selNode = document.querySelector('#dbTree .node.dbtree-selected');
    if (!selNode) return null;
    const li = selNode.closest('li');
    if (!li) return null;
    const isDb = !!li.dataset.connId;
    const isFolder = (li.dataset.kind === 'folder');
    return { node: selNode, li, isDb, isFolder };
  }

  function triggerConnMenuAction(act, info){
    if (!info || !info.isDb) return;
    if (typeof ctxMenu === 'undefined' || !ctxMenu || !ctxMenu.el) return;

    const connLi = info.li.closest('li[data-conn-id]');
    const connId = connLi && connLi.dataset.connId;
    if (!connId) return;

    ctxMenu.targetConn = connId;
    const menuItem = ctxMenu.el.querySelector('li[data-act="' + act + '"]');
    if (menuItem) {
      menuItem.click();
    }
  }

  function triggerFolderRefresh(info){
    if (!info || !info.isFolder) return;
    if (typeof tree === 'undefined' || !tree || typeof tree.buildNodeInfo !== 'function') return;
    if (typeof treeCtxConfig === 'undefined' || typeof handleTreeCtxAction !== 'function') return;

    const nodeInfo = tree.buildNodeInfo(info.li);
    const kind = nodeInfo.kind || info.li.dataset.kind || 'folder';
    const cfg = treeCtxConfig[kind] || treeCtxConfig._default;
    if (!cfg) return;
    const item = (cfg || []).find(x => x.act === 'refresh-node') || null;
    if (!item) return;
    try{
      handleTreeCtxAction('refresh-node', nodeInfo, item);
    }catch(e){
      console.warn('dbTree shortcut refresh-node error', e);
    }
  }

  document.addEventListener('keydown', function(e){
    // 에디터/입력창에서는 기본 동작 유지
    const target = e.target;
    if (target) {
      const tag = target.tagName;
      if (tag === 'INPUT' || tag === 'TEXTAREA' || target.isContentEditable) {
        return;
      }
    }

    const key = e.key;
    const ctrl = e.ctrlKey || e.metaKey;
    const alt = e.altKey;
    const shift = e.shiftKey;

    const info = getTreeSelectionInfo();
    // Ctrl+V는 선택이 없어도 루트 기준으로 붙여넣기 허용
    if (!info && !(ctrl && !alt && !shift && (key === 'v' || key === 'V'))) return;

    // 복사: Ctrl + C (DB / 폴더)
    if (ctrl && !alt && !shift && (key === 'c' || key === 'C')) {
      if (info.isDb) {
        triggerConnMenuAction('copy-conn', info);
        e.preventDefault();
        e.stopPropagation();
        return;
      }
      if (info.isFolder &&
          typeof dbFolderUi !== 'undefined' &&
          dbFolderUi &&
          typeof dbFolderUi.copyFolder === 'function') {
        try{
          dbFolderUi.copyFolder(info.li);
        }catch(err){
          console.warn('dbTree shortcut copyFolder error', err);
        }
        e.preventDefault();
        e.stopPropagation();
        return;
      }
    }

    // 붙여넣기: Ctrl + V (클립보드 타입에 따라 폴더/DB 처리)
    if (ctrl && !alt && !shift && (key === 'v' || key === 'V')) {
      if (typeof dbFolderUi !== 'undefined' &&
          dbFolderUi &&
          typeof dbFolderUi.pasteFolder === 'function') {
        try{
          const targetLi = info ? info.li : null; // 선택 없으면 루트 기준으로
          dbFolderUi.pasteFolder(targetLi);
        }catch(err){
          console.warn('dbTree shortcut pasteFolder error', err);
        }
        e.preventDefault();
        e.stopPropagation();
      }
      return;
    }

    // 삭제: Delete
    if (!ctrl && !alt && !shift && key === 'Delete') {
      if (info.isDb) {
        triggerConnMenuAction('delete-conn', info);
        e.preventDefault();
        e.stopPropagation();
        return;
      }
      if (info.isFolder &&
          typeof dbFolderUi !== 'undefined' &&
          dbFolderUi &&
          typeof dbFolderUi.deleteFolder === 'function') {
        try{
          dbFolderUi.deleteFolder();
        }catch(err){
          console.warn('dbTree shortcut deleteFolder error', err);
        }
        e.preventDefault();
        e.stopPropagation();
        return;
      }
    }

    // 이름 변경: F2
    if (!ctrl && !alt && !shift && key === 'F2') {
      if (info.isDb) {
        triggerConnMenuAction('rename-conn', info);
        e.preventDefault();
        e.stopPropagation();
        return;
      }
      if (info.isFolder &&
          typeof dbFolderUi !== 'undefined' &&
          dbFolderUi &&
          typeof dbFolderUi.renameFolder === 'function') {
        try{
          dbFolderUi.renameFolder();
        }catch(err){
          console.warn('dbTree shortcut renameFolder error', err);
        }
        e.preventDefault();
        e.stopPropagation();
        return;
      }
    }

    // 새로고침: Alt + R (브라우저 새로고침과 충돌 피하기 위해 Alt 사용)
    if (!ctrl && alt && !shift && (key === 'r' || key === 'R')) {
      if (info.isDb) {
        triggerConnMenuAction('refresh', info);
        e.preventDefault();
        e.stopPropagation();
        return;
      }
      if (info.isFolder) {
        triggerFolderRefresh(info);
        e.preventDefault();
        e.stopPropagation();
        return;
      }
    }
  });
})();

/* ---------------- Grid (result rendering) ---------------- */
const grid = { render(columns, rows){
  state.lastResult = {
    columns: columns || [],
    rows: rows || [],
    elapsedMs: (state.lastResult ? (state.lastResult.elapsedMs || 0) : 0),
    rowCount: (rows || []).length
  };
  const thead = document.querySelector('#grid thead'); const tbody = document.querySelector('#grid tbody'); thead.innerHTML = ''; tbody.innerHTML = ''; if(!columns || !columns.length){ document.getElementById('messages').textContent = '결과가 없습니다.'; return; } const trh = document.createElement('tr'); columns.forEach(c=>{ const th=document.createElement('th'); th.textContent=c; trh.appendChild(th); }); thead.appendChild(trh); rows.forEach(r=>{ const tr=document.createElement('tr'); columns.forEach(c=>{ const td=document.createElement('td'); td.textContent = (r[c]!==undefined && r[c]!==null)? String(r[c]) : ''; tr.appendChild(td); }); tbody.appendChild(tr); }); } };

// --- Query History Panel ---
const historyPanel = {
  add(entry){
    try{
      if(!state.history){ state.history = []; }
      // 직전 항목과 완전히 동일한 실행인 경우(같은 시각/쿼리/탭/건수/시간)라면 중복으로 쌓지 않는다.
      if(state.history.length){
        const last = state.history[0];
        if(
          last &&
          last.sql === entry.sql &&
          last.connId === entry.connId &&
          last.tabId === entry.tabId &&
          last.rowCount === entry.rowCount &&
          last.elapsedMs === entry.elapsedMs &&
          last.tsLabel === entry.tsLabel
        ){
          console.warn('historyPanel.add: duplicate entry skipped', entry);
          return;
        }
      }
      state.history.unshift(entry);
      if(state.history.length > 200){
        state.history.length = 200;
      }
      // 메인 히스토리 그리드 갱신
      this.render();

      // 우측 최근 쿼리 사이드바: 자동 열기 + 렌더
      const sideEl = document.getElementById('queryHistorySidebar');
      if(typeof queryHistorySidebar !== 'undefined' && queryHistorySidebar){
        if(sideEl && sideEl.classList.contains('show')){
          if(typeof queryHistorySidebar.render === 'function'){
            queryHistorySidebar.render();
          }
        }else{
          if(typeof queryHistorySidebar.open === 'function'){
            queryHistorySidebar.open();
          }
        }

        // 자동 닫기 타이머: 추가 쿼리 실행이 없으면 10초 후 사이드바 닫기
        if(queryHistorySidebar._autoCloseTimer){
          clearTimeout(queryHistorySidebar._autoCloseTimer);
        }
        queryHistorySidebar._autoCloseTimer = setTimeout(function(){
          try{
            const sideElNow = document.getElementById('queryHistorySidebar');
            if(sideElNow && sideElNow.classList.contains('show') &&
               typeof queryHistorySidebar.close === 'function'){
              queryHistorySidebar.close();
            }
          }catch(e){
            console.warn('queryHistorySidebar auto-close error', e);
          }
        }, 10000);
      }
    }catch(e){
      console.warn('historyPanel.add error', e);
    }
  },
  // 최근 쿼리 사이드바와 동일한 규칙으로 SQL 미리보기 한 줄 생성
  _buildSqlPreview(h, maxLen){
    const limit = (typeof maxLen === 'number' && maxLen > 0) ? maxLen : 160;
    let preview = '';
    if(h && h.sql){
      try{
        const lines = h.sql.split(/\r?\n/);
        let candidate = '';
        let startIdx = -1;
        for(let i=0;i<lines.length;i++){
          const t = lines[i].trim();
          if(!t) continue;
          // 전형적인 주석 라인들은 우선 건너뛴다.
          if(t.startsWith('--') || t.startsWith('//') || t.startsWith('/*') || t.startsWith('*') || t.startsWith('*/')){
            continue;
          }
          startIdx = i;
          break;
        }
        if(startIdx >= 0){
          // 첫 유효 라인부터 몇 줄 정도를 묶어서 한 줄로 만든다.
          const slice = lines.slice(startIdx, startIdx + 6);
          candidate = slice.join(' ');
        }else{
          // 전부 주석이거나 비어있으면 전체를 한 줄로 합친다.
          candidate = lines.join(' ');
        }
        let single = candidate.replace(/\s+/g, ' ').trim();
        if(single.length > limit){
          single = single.slice(0, limit - 3) + '...';
        }
        preview = single;
      }catch(e){
        // 실패 시 sqlFirstLine 또는 기존 로직으로 폴백
        if(h && h.sqlFirstLine){
          preview = String(h.sqlFirstLine).replace(/\s+/g, ' ').slice(0, limit);
        }else if(h && h.sql){
          preview = h.sql.split(/\r?\n/)[0].replace(/\s+/g, ' ').slice(0, limit);
        }
      }
    }else if(h && h.sqlFirstLine){
      preview = String(h.sqlFirstLine).replace(/\s+/g, ' ');
      if(preview.length > limit){
        preview = preview.slice(0, limit - 3) + '...';
      }
    }
    return preview;
  },
  render(){
    const tbody = document.querySelector('#historyGrid tbody');
    if(!tbody) return;
    tbody.innerHTML = '';

    // 현재 활성 탭의 연결(connId)을 기준으로 히스토리 필터링
    const tabs = state.tabs || [];
    const activeId = state.activeTabId;
    const tab = tabs.find(t=>t.id===activeId) || null;
    const connId = (tab && tab.connId) ? tab.connId : state.connId;

    const all = state.history || [];
    const items = connId ? all.filter(h=>h.connId === connId) : all;

    items.forEach((h, idx)=>{
      const tr = document.createElement('tr');

      // SQL 미리보기 한 줄 (최근 쿼리 사이드바와 동일 규칙)
      const sqlPreview = this._buildSqlPreview(h, 120);

      const cells = [
        h.tsLabel || '',
        h.connLabel || h.connId || '',
        h.tabTitle || '',
        (h.rowCount != null ? String(h.rowCount) : ''),
        (h.elapsedMs != null ? String(h.elapsedMs) : ''),
        sqlPreview || ''
      ];
      cells.forEach((v)=>{
        const td = document.createElement('td');
        td.textContent = v;
        tr.appendChild(td);
      });
      tr.addEventListener('dblclick', ()=>{
        if(h.sql && typeof ui !== 'undefined' && ui && typeof ui.appendSql === 'function'){
          ui.appendSql(h.sql);
        }
        if(h.tabId && state.tabs && state.tabs.find(t=>t.id===h.tabId) && typeof ui !== 'undefined' && ui && typeof ui.switchTab === 'function'){
          ui.switchTab(h.tabId);
        }
      });
      tr.addEventListener('contextmenu', (ev)=>{
        ev.preventDefault();
        try{
          if(typeof historyCtx !== 'undefined' && historyCtx && typeof historyCtx.open === 'function'){
            historyCtx.open(ev.clientX, ev.clientY, {
              source: 'history',
              sql: h.sql || '',
              connId: h.connId || '',
              tabId: h.tabId || '',
              tsLabel: h.tsLabel || ''
            });
          }
        }catch(err){
          console.warn('history row contextmenu error', err);
        }
      });
      tbody.appendChild(tr);
    });

    // 셀렉트박스 동기화 (현재 활성 탭의 연결 기준)
    const sel = document.getElementById('historySelect');
    if(sel){
      sel.innerHTML = '';
      const items2 = items || [];
      const baseOption = document.createElement('option');
      baseOption.value = '';
      baseOption.textContent = items2.length ? `최근 실행 ${items2.length}건` : '최근 실행 내역';
      sel.appendChild(baseOption);
      items2.forEach((h, idx)=>{
        const opt = document.createElement('option');
        opt.value = String(idx);
        const labelParts = [];
        if(h.tsLabel) labelParts.push(h.tsLabel);
        if(h.connLabel || h.connId) labelParts.push(h.connLabel || h.connId);
        const labelSql = this._buildSqlPreview(h, 80);
        if(labelSql) labelParts.push(labelSql);
        opt.textContent = labelParts.join(' | ').slice(0, 120);
        sel.appendChild(opt);
      });

      // 현재 렌더링 기준 데이터/연결 정보를 셀렉트에 보관
      sel._histItems = items2;
      sel._histConnId = connId || null;

      if(!sel._bound){
        sel.addEventListener('change', (e)=>{
          const v = sel.value;
          if(!v) return;
          const idx = parseInt(v, 10);
          const arr = sel._histItems || [];
          const h = arr[idx];
          if(!h) return;
          if(h.sql && typeof ui !== 'undefined' && ui && typeof ui.appendSql === 'function'){
            ui.appendSql(h.sql);
          }
          if(h.tabId && state.tabs && state.tabs.find(t=>t.id===h.tabId) && typeof ui !== 'undefined' && ui && typeof ui.switchTab === 'function'){
            ui.switchTab(h.tabId);
          }
        });
        sel._bound = true;
      }
    }
  },
  toggle(){
    if(bottomTabs){
      bottomTabs.toggle('historyPanel');
    }
  },
  clear(){
    state.history = [];
    const tbody = document.querySelector('#historyGrid tbody');
    if(tbody){ tbody.innerHTML = ''; }
  }
};


// --- Query History Sidebar (현재 DB 기준) ---
const queryHistorySidebar = {
  open(){
    this.render();
    const el = document.getElementById('queryHistorySidebar');
    if(!el) return;
    el.classList.add('show');
    el.classList.remove('hidden');
    el.setAttribute('aria-hidden','false');
  },
  close(){
    const el = document.getElementById('queryHistorySidebar');
    if(!el) return;
    el.classList.remove('show');
    el.classList.add('hidden');
    el.setAttribute('aria-hidden','true');
  },
  toggle(){
    const el = document.getElementById('queryHistorySidebar');
    if(!el) return;
    if(el.classList.contains('show')){
      this.close();
    }else{
      this.open();
    }
  },
  render(){
    const body = document.getElementById('qhSidebarBody');
    const meta = document.getElementById('qhSidebarMeta');
    if(!body) return;
    body.innerHTML = '';
    const tabs = state.tabs || [];
    const activeId = state.activeTabId;
    const tab = tabs.find(t=>t.id===activeId) || null;
    const connId = (tab && tab.connId) ? tab.connId : state.connId;
    const all = state.history || [];
    const items = connId ? all.filter(h=>h.connId === connId) : all;
    const connLabel = (typeof getConnLabel === 'function' && connId)
      ? getConnLabel(connId)
      : (connId || '');

    if(meta){
      if(connId){
        meta.textContent = connLabel ? `연결: ${connLabel}` : `연결 ID: ${connId}`;
      }else{
        meta.textContent = '연결되지 않음';
      }
    }

    if(!items.length){
      const div = document.createElement('div');
      div.className = 'empty';
      div.textContent = connId
        ? '현재 연결 기준 최근 실행 내역이 없습니다.'
        : '연결 정보가 없어 최근 실행 내역을 표시할 수 없습니다.';
      body.appendChild(div);
      return;
    }

    items.slice(0, 30).forEach((h)=>{
      const item = document.createElement('div');
      item.className = 'item';

      const metaLine = document.createElement('div');
      metaLine.className = 'meta';
      const rowInfo = (h.rowCount != null && h.rowCount !== '') ? `${h.rowCount}행` : '';
      const elapsedInfo = (h.elapsedMs != null && h.elapsedMs !== '') ? `${h.elapsedMs}ms` : '';
      const parts = [];
      if(h.tsLabel) parts.push(h.tsLabel);
      if(rowInfo) parts.push(rowInfo);
      if(elapsedInfo) parts.push(elapsedInfo);
      metaLine.textContent = parts.join(' · ');

      
      const sqlLine = document.createElement('div');
      sqlLine.className = 'sql';

      // 미리보기: 주석 라인은 가능하면 건너뛰고, 줄바꿈은 공백으로 합쳐 한 줄로 표시
      let preview = '';
      if(h.sql){
        try{
          const lines = h.sql.split(/\r?\n/);
          let candidate = '';
          let startIdx = -1;
          for(let i=0;i<lines.length;i++){
            const t = lines[i].trim();
            if(!t) continue;
            // 전형적인 주석 라인들은 우선 건너뛴다.
            if(t.startsWith('--') || t.startsWith('//') || t.startsWith('/*') || t.startsWith('*') || t.startsWith('*/')){
              continue;
            }
            startIdx = i;
            break;
          }
          if(startIdx >= 0){
            // 첫 유효 라인부터 몇 줄 정도를 묶어서 한 줄로 만든다.
            const slice = lines.slice(startIdx, startIdx + 6);
            candidate = slice.join(' ');
          }else{
            // 전부 주석이거나 비어있으면 전체를 한 줄로 합친다.
            candidate = lines.join(' ');
          }
          let single = candidate.replace(/\s+/g, ' ').trim();
          if(single.length > 160){
            single = single.slice(0, 157) + '...';
          }
          preview = single;
        }catch(e){
          // 실패 시 sqlFirstLine 또는 기존 로직으로 폴백
          if(h.sqlFirstLine){
            preview = String(h.sqlFirstLine).replace(/\s+/g, ' ').slice(0, 160);
          }else{
            preview = h.sql.split(/\r?\n/)[0].replace(/\s+/g, ' ').slice(0, 160);
          }
        }
      }else if(h.sqlFirstLine){
        preview = String(h.sqlFirstLine).replace(/\s+/g, ' ');
        if(preview.length > 160){
          preview = preview.slice(0, 157) + '...';
        }
      }
      sqlLine.textContent = preview || '';

      item.appendChild(metaLine);
      item.appendChild(sqlLine);

      item.addEventListener('click', ()=>{
        try{
          if(h.sql && typeof ui !== 'undefined' && ui && typeof ui.appendSql === 'function'){
            ui.appendSql(h.sql);
          }
          if(h.tabId && state.tabs && typeof ui !== 'undefined' && ui && typeof ui.switchTab === 'function'){
            const exists = state.tabs.find(t=>t.id===h.tabId);
            if(exists){
              ui.switchTab(h.tabId);
            }
          }
        }catch(err){
          console.warn('queryHistorySidebar item click error', err);
        }
      });
      item.addEventListener('contextmenu', (ev)=>{
        ev.preventDefault();
        try{
          if(typeof historyCtx !== 'undefined' && historyCtx && typeof historyCtx.open === 'function'){
            historyCtx.open(ev.clientX, ev.clientY, {
              source: 'recent',
              sql: h.sql || '',
              connId: h.connId || '',
              tabId: h.tabId || '',
              tsLabel: h.tsLabel || ''
            });
          }
        }catch(err){
          console.warn('queryHistorySidebar item contextmenu error', err);
        }
      });

      body.appendChild(item);
    });
  }
};



const favorites = {
  storageKey: 'dbam_favorites_v1',
  list: [],
  _escapeHtml(str){
    if(str == null) return '';
    return String(str)
      .replace(/&/g,'&amp;')
      .replace(/</g,'&lt;')
      .replace(/>/g,'&gt;');
  },
  load(){
    try{
      const raw = localStorage.getItem(this.storageKey);
      if(!raw){
        this.list = [];
        return;
      }
      const arr = JSON.parse(raw);
      this.list = Array.isArray(arr) ? arr : [];
    }catch(e){
      console.warn('favorites.load error', e);
      this.list = [];
    }
    this.render();
  },
  save(){
    try{
      localStorage.setItem(this.storageKey, JSON.stringify(this.list || []));
    }catch(e){
      console.warn('favorites.save error', e);
    }
  },
  addFromSelection(){
    let sql = '';
    // CodeMirror selection 우선 (전역 cm 인스턴스가 있으면 그것부터 사용)
    if (typeof cm !== 'undefined' && cm && typeof cm.getSelection === 'function') {
      sql = cm.getSelection();
    }else if(ui && typeof ui.getEditor === 'function'){
      const full = ui.getEditor() || '';
      const ta = document.getElementById('sqlEditor');
      if(ta && typeof ta.selectionStart === 'number' && typeof ta.selectionEnd === 'number'){
        sql = full.substring(ta.selectionStart, ta.selectionEnd);
      }else{
        sql = full;
      }
    }
    if(!sql || !sql.trim()){
      alert('선택된 SQL이 없습니다.');
      return;
    }
    const defaultName = (sql.split(/\r?\n/)[0] || '').slice(0, 60);
    const name = window.prompt('즐겨찾기 이름을 입력하세요.', defaultName);
    if(!name) return;
    const connId = state.connId || null;
    const now = new Date();
    const item = {
      id: now.getTime(),
      name,
      sql,
      connId,
      createdAt: now.toISOString().replace('T',' ').slice(0,19)
    };
    this.list = this.list || [];
    this.list.unshift(item);
    this.save();
    this.render();
    this.ensureVisible();
  },
  addFromEditor(){
    // 기존: 즉시 localStorage에 저장하던 방식에서,
    // 이제는 즐겨찾기/템플릿 저장 모달을 띄우는 진입점으로 사용
    if(typeof ui !== 'undefined' && ui && typeof ui.openFavSaveModal === 'function'){
      ui.openFavSaveModal();
    }else{
      alert('즐겨찾기 저장 모달 UI를 찾지 못했습니다.');
    }
  },

  addFromModal(payload){
    try{
      const data = payload || {};
      const name = (data.name || '').trim();
      const sql  = (data.sql  || '').trim();
      const description = (data.description || '').trim();
      if(!sql){
        alert('저장할 SQL이 없습니다.');
        return;
      }
      if(!name){
        alert('제목이 비어 있습니다.');
        return;
      }
      const now = new Date();
      const item = {
        id: now.getTime(),
        name: name,
        description: description,
        sql: sql,
        connId: data.connId || null,
        category: data.category || 'ETC',
        biz: data.biz || '',
        tags: data.tags || ''
      };
      this.list = this.list || [];
      this.list.unshift(item);
      this.save();
      this.render();
      this.ensureVisible();
    }catch(e){
      console.warn('favorites.addFromModal error', e);
      alert('개인 즐겨찾기 저장 중 오류가 발생했습니다. 콘솔을 확인하세요.');
    }
  },
  updateFromModal(payload){
    try{
      const data = payload || {};
      const id = data.id;
      if(!id){
        console.warn('favorites.updateFromModal: id 누락');
        return;
      }
      const list = this.list || [];
      const idx = list.findIndex(it => it.id === id);
      if(idx === -1){
        console.warn('favorites.updateFromModal: 대상 항목 없음', id);
        return;
      }
      const name = (data.name || '').trim();
      const sql  = (data.sql  || '').trim();
      const description = (data.description || '').trim();
      if(!sql){
        alert('저장할 SQL이 없습니다.');
        return;
      }
      if(!name){
        alert('제목이 비어 있습니다.');
        return;
      }
      const item = list[idx];
      item.name = name;
      item.description = description;
      item.sql = sql;
      item.connId = data.connId || item.connId || null;
      item.category = data.category || item.category || 'ETC';
      item.biz = data.biz || item.biz || '';
      item.tags = data.tags || item.tags || '';
      this.save();
      this.render();
    }catch(e){
      console.warn('favorites.updateFromModal error', e);
      alert('개인 즐겨찾기 수정 중 오류가 발생했습니다. 콘솔을 확인하세요.');
    }
  },


  remove(id){
    if(!this.list) return;
    this.list = this.list.filter(it => it.id !== id);
    this.save();
    this.render();
  },
  clear(){
    if(!window.confirm('모든 즐겨찾기 쿼리를 삭제할까요?')) return;
    this.list = [];
    this.save();
    this.render();
  },

  _pendingNewTabFavorite: null,
  _applyPendingFavoriteToNewTab(){
    const fav = this._pendingNewTabFavorite;
    this._pendingNewTabFavorite = null;
    if(!fav || !fav.sql) return;
    try{
      if (typeof ui !== 'undefined' && ui && typeof ui.setEditor === 'function') {
        ui.setEditor(fav.sql);
      }
    }catch(e){
      console.warn('favorites._applyPendingFavoriteToNewTab error', e);
    }
  },
  render(){
    const tbody = document.getElementById('favPersonalBody');
    if(!tbody) return;
    tbody.innerHTML = '';
    const items = this.list || [];

    const sysSel = document.getElementById('favPersonalSys');
    const catSel = document.getElementById('favPersonalCat');
    const bizSel = document.getElementById('favPersonalBiz');
    const keywordInput = document.getElementById('favPersonalKeyword');

    const sys = sysSel ? sysSel.value : '';
    const cat = catSel ? catSel.value : '';
    const biz = bizSel ? bizSel.value : '';
    const keyword = (keywordInput && keywordInput.value || '').toLowerCase();

    const filtered = items.filter((f)=>{
      // 시스템 코드는 connId의 prefix로 가정 (예: DEV_DB -> DEV)
      const connLabel = f.connId || '';
      let sysCode = '';
      if(connLabel){
        const parts = String(connLabel).split('_');
        sysCode = (parts[0] || '').toUpperCase();
      }
      const catCode = (f.category || 'ETC');
      const bizCode = (f.biz || '');

      if(sys && sysCode !== sys) return false;
      if(cat && catCode !== cat) return false;
      if(biz && bizCode !== biz) return false;

      if(!keyword) return true;
      const base = ((f.name || '') + ' ' + (f.sql || '')).toLowerCase();
      return base.includes(keyword);
    });

    filtered.forEach((f)=>{
      const tr = document.createElement('tr');
      tr.style.cursor = 'pointer';
      const fullSql = f.sql || '';
      const connLabel = f.connId || '';
      let sysCode = '';
      let dbLabel = connLabel || '';
      if(connLabel){
        const parts = String(connLabel).split('_');
        sysCode = (parts[0] || '').toUpperCase();
      }
      const sysLabel = sysCode;
      const catCode = (f.category || 'ETC');
      const catLabel = catCode;
      const bizCode = (f.biz || '');
      let bizLabel = bizCode;
      try{
        if(typeof favTpl !== 'undefined' && favTpl && typeof favTpl.getBizLabel === 'function'){
          bizLabel = favTpl.getBizLabel(bizCode || '') || bizCode;
        }
      }catch(e){
        bizLabel = bizCode;
      }

      const firstLine = (fullSql.split(/\r?\n/)[0] || '').slice(0, 120);
      const descText = (f.description && f.description.trim()) ? f.description : firstLine;

      const td = document.createElement('td');
      td.innerHTML = `
        <div class="favtpl-name">${this._escapeHtml(f.name || '')}</div>
        <div class="favtpl-desc">${this._escapeHtml(descText || '')}</div>
        <div class="favtpl-meta-row">
          ${bizLabel ? `<span class="favtpl-badge biz-${this._escapeHtml(bizCode || '')}">업무: ${this._escapeHtml(bizLabel)}</span>` : ''}
          ${sysLabel ? `<span class="favtpl-badge sys-${this._escapeHtml(sysLabel)}">${this._escapeHtml(sysLabel)}</span>` : ''}
          ${catLabel ? `<span class="favtpl-badge cat-${this._escapeHtml(catCode)}">${this._escapeHtml(catLabel)}</span>` : ''}
          ${dbLabel ? `<span class="favtpl-badge">${this._escapeHtml(dbLabel)}</span>` : ''}
        </div>
      `;
      tr.appendChild(td);

      // 클릭: 우측 미리보기 및 메타만 표시
      tr.addEventListener('click', ()=>{
        try{
          const preview = document.getElementById('favPersonalPreview');
          const metaLeft = document.getElementById('favPersonalMetaLeft');
          const metaRight = document.getElementById('favPersonalMetaRight');
          if(preview){
            preview.value = fullSql;
          }
          if(metaLeft){
            const parts = [];
            if(bizLabel) parts.push(bizLabel);
            if(sysLabel) parts.push(sysLabel);
            if(dbLabel) parts.push(dbLabel);
            if(catLabel) parts.push(catLabel);
            metaLeft.textContent = parts.join(' / ');
          }
          if(metaRight){
            metaRight.textContent = '';
          }
        }catch(err){
          console.warn('favorites click preview error', err);
        }
      });

      // 더블클릭: 현재 활성 에디터에 이어서 붙여넣기
      tr.addEventListener('dblclick', ()=>{
        try{
          if(f.sql && typeof ui !== 'undefined' && ui && typeof ui.setEditor === 'function'){
            const current = (ui.getEditor && ui.getEditor()) || '';
            let nextSql;
            if(!current || !current.trim()){
              // 에디터가 비어 있으면 즐겨찾기 쿼리만 그대로 적용
              nextSql = f.sql;
            }else{
              // 기존 내용이 있으면: 마지막 줄 이후에 빈 줄 + 즐겨찾기 주석 + 즐겨찾기 쿼리
              const trimmed = current.replace(/\s*$/, '');
              nextSql = trimmed + '\n\n-- Favorite: ' + (f.name || '') + '\n' + f.sql;
            }
            ui.setEditor(nextSql);
          }
        }catch(e){
          console.warn('favorites dblclick apply error', e);
        }
      });

      // 우클릭: 컨텍스트 메뉴 (수정/삭제)
      tr.addEventListener('contextmenu', (e)=>{
        e.preventDefault();
        try{
          if(typeof favCtx !== 'undefined' && favCtx && typeof favCtx.open === 'function'){
            favCtx.open(e.pageX, e.pageY, {
              type: 'personal',
              id: f.id,
              name: f.name || ''
            });
          }
        }catch(err){
          console.warn('favorites contextmenu error', err);
        }
      });

      tbody.appendChild(tr);
    });

    if(!filtered.length){
      const tr = document.createElement('tr');
      const td = document.createElement('td');
      td.textContent = '등록된 개인 즐겨찾기 쿼리가 없습니다.';
      td.style.textAlign = 'center';
      td.style.color = '#6b7280';
      td.style.padding = '8px';
      tr.appendChild(td);
      tbody.appendChild(tr);
    }
  },
  toggle(){
    if(!this.list || !this.list.length){
      this.load();
    }else{
      this.render();
    }
    if(bottomTabs){
      bottomTabs.toggle('favPanel');
    }
  },
  ensureVisible(){
    if(bottomTabs){
      bottomTabs.activate('favPanel');
      return;
    }
    const panel = document.getElementById('favPanel');
    if(!panel) return;
    if(getComputedStyle(panel).display === 'none'){
      panel.classList.remove('hidden');
      panel.style.display = 'block';
    }
  }
};
// 초기 로딩 시 즐겨찾기 복원
try{ favorites.load(); }catch(e){ }

// 조직 공용 템플릿 (프로토타입, 서버 연동 전)
const favTpl = {
  currentMode: 'personal',
  orgList: [
    {
      id: 101,
      name: '운영 세션 모니터링',
      description: '현재 접속 세션 및 잠금 상태 확인',
      targetSys: 'PRD',
      targetDbId: 'PRD_MAIN',
      category: 'MONITOR',
      biz: 'PORTAL',
      tags: 'monitor,session,lock',
      sqlText: `SELECT s.sid,
       s.serial#,
       s.username,
       s.machine,
       l.lock_type
  FROM v$session s
  LEFT JOIN v$lock l
    ON s.sid = l.sid;`
    },
    {
      id: 102,
      name: '표준 이력 테이블 INSERT 템플릿',
      description: 'TB_xxx_HIS 표준 INSERT 기본 형식',
      targetSys: 'PRD',
      targetDbId: 'PRD_MAIN',
      category: 'HISTORY',
      biz: 'COMMON',
      tags: 'history,insert,standard',
      sqlText: `INSERT INTO TB_SAMPLE_HIS (
    HIS_ID,
    TARGET_ID,
    COL_BEFORE,
    COL_AFTER,
    REG_DTM,
    REG_ID
) VALUES (
    :HIS_ID,
    :TARGET_ID,
    :COL_BEFORE,
    :COL_AFTER,
    SYSTIMESTAMP,
    :REG_ID
);`
    },
    {
      id: 103,
      name: '배치 검증용 집계 쿼리',
      description: '전일 배치 결과 집계 및 기준 값 비교',
      targetSys: 'STG',
      targetDbId: 'STG_BATCH',
      category: 'BATCH',
      biz: 'MSG',
      tags: 'batch,validate',
      sqlText: `SELECT job_id,
       run_dt,
       status,
       proc_cnt
  FROM tb_batch_result
 WHERE run_dt = TRUNC(SYSDATE-1);`
    }
  ],
  getBizLabel(code){
    switch(code){
      case 'MSG': return '메신저';
      case 'PORTAL': return '포탈';
      case 'COMMON': return '공통';
      case 'ETC': return '기타';
      default: return code || '';
    }
  },
  switchMode(mode){
    this.currentMode = mode;
    const personalBtn = document.getElementById('favtplTabPersonal');
    const orgBtn = document.getElementById('favtplTabOrg');
    const personalWrap = document.getElementById('favPersonalWrap');
    const orgWrap = document.getElementById('favOrgWrap');
    if(personalBtn && orgBtn && personalWrap && orgWrap){
      personalBtn.classList.toggle('active', mode === 'personal');
      orgBtn.classList.toggle('active', mode === 'org');
      personalWrap.classList.toggle('hidden', mode !== 'personal');
      orgWrap.classList.toggle('hidden', mode !== 'org');
    }
  },
  bindEvents(){
    const personalBtn = document.getElementById('favtplTabPersonal');
    const orgBtn = document.getElementById('favtplTabOrg');
    if(personalBtn){
      personalBtn.addEventListener('click', ()=> this.switchMode('personal'));
    }
    if(orgBtn){
      orgBtn.addEventListener('click', ()=> this.switchMode('org'));
    }
    const sysSel = document.getElementById('favOrgSys');
    const catSel = document.getElementById('favOrgCat');
    const bizSel = document.getElementById('favOrgBiz');
    const keywordInput = document.getElementById('favOrgKeyword');
    [sysSel, catSel, bizSel].forEach(el=>{
      if(el){
        el.addEventListener('change', ()=> this.renderOrgList());
      }
    });
    if(keywordInput){
      keywordInput.addEventListener('input', ()=> this.renderOrgList());
    }
  },
  renderOrgList(){
    const tbody = document.getElementById('favOrgBody');
    if(!tbody) return;
    tbody.innerHTML = '';
    const sysSel = document.getElementById('favOrgSys');
    const catSel = document.getElementById('favOrgCat');
    const bizSel = document.getElementById('favOrgBiz');
    const keywordInput = document.getElementById('favOrgKeyword');
    const sys = sysSel ? sysSel.value : '';
    const cat = catSel ? catSel.value : '';
    const biz = bizSel ? bizSel.value : '';
    const keyword = (keywordInput && keywordInput.value || '').toLowerCase();

    const filtered = this.orgList.filter(t=>{
      if(sys && t.targetSys !== sys) return false;
      if(cat && t.category !== cat) return false;
      if(biz && (t.biz || '') !== biz) return false;
      if(!keyword) return true;
      const base = (t.name + ' ' + (t.description||'') + ' ' + (t.tags||'') + ' ' + (t.sqlText||'')).toLowerCase();
      return base.includes(keyword);
    });

    filtered.forEach(t=>{
      const tr = document.createElement('tr');
      tr.addEventListener('click', ()=> this.selectOrg(t));
      tr.addEventListener('dblclick', ()=> this.applyToCurrent(t));
      // 우클릭: 컨텍스트 메뉴 (수정/삭제)
      tr.addEventListener('contextmenu', (e)=>{
        e.preventDefault();
        try{
          if(typeof favCtx !== 'undefined' && favCtx && typeof favCtx.open === 'function'){
            favCtx.open(e.pageX, e.pageY, {
              type: 'org',
              id: t.id,
              name: t.name || ''
            });
          }
        }catch(err){
          console.warn('favTpl renderOrgList contextmenu error', err);
        }
      });
      const td = document.createElement('td');
      td.innerHTML = `
        <div class="favtpl-name">${this.escapeHtml(t.name)}</div>
        <div class="favtpl-desc">${this.escapeHtml(t.description || '')}</div>
        <div class="favtpl-meta-row">
          <span class="favtpl-badge sys-${this.escapeHtml(t.targetSys || 'PRD')}">${this.escapeHtml(t.targetSys || '')}</span>
          <span class="favtpl-badge cat-${this.escapeHtml(t.category || 'ETC')}">${this.escapeHtml(t.category || '')}</span>
          ${t.biz ? `<span class="favtpl-badge biz-${this.escapeHtml(t.biz)}">업무: ${this.escapeHtml(this.getBizLabel(t.biz))}</span>` : ''}
          ${t.targetDbId ? `<span class="favtpl-badge">${this.escapeHtml(t.targetDbId)}</span>` : ''}
        </div>
      `;
      tr.appendChild(td);
      tbody.appendChild(tr);
    });

    if(!filtered.length){
      const tr = document.createElement('tr');
      const td = document.createElement('td');
      td.textContent = '조건에 맞는 조직 공용 템플릿이 없습니다.';
      td.style.textAlign = 'center';
      td.style.color = '#6b7280';
      td.style.padding = '8px';
      tr.appendChild(td);
      tbody.appendChild(tr);
    }
  },
  escapeHtml(str){
    if(str == null) return '';
    return String(str)
      .replace(/&/g,'&amp;')
      .replace(/</g,'&lt;')
      .replace(/>/g,'&gt;');
  },
  selectOrg(t){
    const preview = document.getElementById('favOrgPreview');
    const metaLeft = document.getElementById('favOrgMetaLeft');
    const metaRight = document.getElementById('favOrgMetaRight');
    if(preview){
      preview.value = t.sqlText || '';
    }
    if(metaLeft){
      metaLeft.textContent = `${this.getBizLabel(t.biz || '')} / ${t.targetSys || ''} / ${t.targetDbId || ''} / ${t.category || ''}`;
    }
    if(metaRight){
      metaRight.textContent = (t.tags || '').trim() ? `TAG: ${t.tags}` : '';
    }
  },
  applyToCurrent(t){
    const tpl = t || null;
    if(!tpl || !tpl.sqlText) return;
    try{
      if(typeof ui !== 'undefined' && ui && typeof ui.getEditor === 'function' && typeof ui.setEditor === 'function'){
        const current = ui.getEditor() || '';
        let nextSql = '';
        if(!current || !current.trim()){
          nextSql = tpl.sqlText;
        }else{
          const trimmed = current.replace(/\s*$/, '');
          nextSql = trimmed + '\n\n-- Template: ' + (tpl.name || '') + '\n' + tpl.sqlText;
        }
        ui.setEditor(nextSql);
      }
    }catch(e){
      console.warn('favTpl.applyToCurrent error', e);
    }
  },
  openNewTab(t){
    const tpl = t || null;
    if(!tpl || !tpl.sqlText) return;
    try{
      if(typeof ui !== 'undefined' && ui && typeof ui.newEditorTab === 'function' && typeof ui.setEditor === 'function'){
        ui.newEditorTab();
        ui.setEditor(tpl.sqlText);
      }
    }catch(e){
      console.warn('favTpl.openNewTab error', e);
    }
  },

  addOrgTemplateFromModal(payload){
    try{
      const data = payload || {};
      const now = new Date();
      const tpl = {
        id: 'ORG_' + now.getTime(),
        name: data.name || '',
        description: data.description || '',
        targetSys: data.targetSys || '',
        targetDbId: data.targetDbId || '',
        category: data.category || 'ETC',
        biz: data.biz || '',
        tags: data.tags || '',
        sqlText: data.sql || ''
      };
      this.orgList = this.orgList || [];
      this.orgList.unshift(tpl);
      this.renderOrgList();
    }catch(e){
      console.warn('favTpl.addOrgTemplateFromModal error', e);
    }
  },


  updateOrgFromModal(payload){
    try{
      const data = payload || {};
      const id = data.id;
      if(!id){
        console.warn('favTpl.updateOrgFromModal: id 누락');
        return;
      }
      const list = this.orgList || [];
      const idx = list.findIndex(t => t.id === id);
      if(idx === -1){
        console.warn('favTpl.updateOrgFromModal: 대상 항목 없음', id);
        return;
      }
      const name = (data.name || '').trim();
      const sql  = (data.sql  || '').trim();
      const description = (data.description || '').trim();
      if(!sql){
        alert('저장할 SQL이 없습니다.');
        return;
      }
      if(!name){
        alert('제목이 비어 있습니다.');
        return;
      }
      const tpl = list[idx];
      tpl.name = name;
      tpl.description = description;
      tpl.targetSys = data.targetSys || tpl.targetSys || '';
      tpl.targetDbId = data.targetDbId || tpl.targetDbId || '';
      tpl.category = data.category || tpl.category || 'ETC';
      tpl.biz = data.biz || tpl.biz || '';
      tpl.tags = data.tags || tpl.tags || '';
      tpl.sqlText = sql;
      this.renderOrgList();
    }catch(e){
      console.warn('favTpl.updateOrgFromModal error', e);
      alert('조직 공용 템플릿 수정 중 오류가 발생했습니다. 콘솔을 확인하세요.');
    }
  },

  removeOrg(id){
    try{
      const list = this.orgList || [];
      this.orgList = list.filter(t => t.id !== id);
      this.renderOrgList();
    }catch(e){
      console.warn('favTpl.removeOrg error', e);
    }
  },
  init(){
    try{
      this.bindEvents();
      this.switchMode('personal'); // 초기에는 개인 즐겨찾기 탭
      this.renderOrgList();
    }catch(e){
      console.warn('favTpl.init error', e);
    }
  }
};

window.addEventListener('DOMContentLoaded', ()=>{
  try{ favTpl.init(); }catch(e){ console.warn('favTpl.init DOMContentLoaded error', e); }
  try{
    const pSys = document.getElementById('favPersonalSys');
    const pCat = document.getElementById('favPersonalCat');
    const pBiz = document.getElementById('favPersonalBiz');
    const pKeyword = document.getElementById('favPersonalKeyword');
    [pSys, pCat, pBiz].forEach(el=>{
      if(el){
        el.addEventListener('change', ()=> favorites.render());
      }
    });
    if(pKeyword){
      pKeyword.addEventListener('input', ()=> favorites.render());
    }
  }catch(e){
    console.warn('favorites personal filter bind error', e);
  }
  try{
    const favSave = document.getElementById('favSaveBackdrop');
    if(favSave){
      const radios = favSave.querySelectorAll('input[name="favSaveType"]');
      radios.forEach(r=>{
        r.addEventListener('change', ()=> {
          if(typeof ui !== 'undefined' && ui && typeof ui._syncFavSaveTypeUI === 'function'){
            ui._syncFavSaveTypeUI();
          }
        });
      });
    }
  }catch(e){
    console.warn('favSave modal bind error', e);
  }
});


// 현재 접속/쿼리 모니터 (이 콘솔에서 열린 세션만 추적)
const sessionMonitor = {
  sessions: {}, // { connId: { connId, connLabel, profile, user, status, lastSql, lastRiskLevel, lastRiskLabel, lastUpdated, disconnected } }

  _nowIso(){
    try{ return new Date().toISOString(); }catch(e){ return new Date().toString(); }
  },
  _currentUser(){
    return (window.DBAM_CURRENT_USER || '');
  },
  _escape(str){
    return String(str || '')
      .replace(/&/g,'&amp;')
      .replace(/</g,'&lt;')
      .replace(/>/g,'&gt;');
  },
  _ensure(connId){
    if(!connId) return null;
    if(!this.sessions[connId]){
      this.sessions[connId] = {
        connId,
        connLabel: getConnLabel(connId),
        profile: getConnProfile(connId),
        user: this._currentUser(),
        status: 'idle',
        lastSql: '',
        lastRiskLevel: 'none',
        lastRiskLabel: '',
        lastUpdated: this._nowIso(),
        disconnected: false
      };
    }else{
      const s = this.sessions[connId];
      s.connLabel = getConnLabel(connId);
      s.profile = getConnProfile(connId);
      s.user = this._currentUser();
      s.lastUpdated = this._nowIso();
    }
    return this.sessions[connId];
  },
  onConnect(connId){
    const s = this._ensure(connId); if(!s) return;
    s.status = 'idle';
    s.disconnected = false;
    s.lastUpdated = this._nowIso();
    this.render();
  },
  onDisconnect(connId){
    const s = this.sessions[connId];
    if(!s) return;
    s.status = 'disconnected';
    s.disconnected = true;
    s.lastUpdated = this._nowIso();
    this.render();
  },
  markExecuting(connId, sql){
    const s = this._ensure(connId); if(!s) return;
    s.status = 'running';
    s.lastSql = (sql || '').split(/\r?\n/)[0].slice(0, 120);
    s.lastUpdated = this._nowIso();
    this.render();
  },
  markFinished(connId, info){
    const s = this._ensure(connId); if(!s) return;
    s.status = 'idle';
    if(info && info.lastSql){
      s.lastSql = (info.lastSql || '').split(/\r?\n/)[0].slice(0, 120);
    }
    s.lastUpdated = this._nowIso();
    this.render();
  },
  markRisk(connId, risk){
    const s = this._ensure(connId); if(!s) return;
    const level = risk && risk.level ? risk.level : 'warn';
    s.lastRiskLevel = (level === 'warn' || level === 'danger') ? level : 'none';
    if(risk && Array.isArray(risk.reasons) && risk.reasons.length){
      s.lastRiskLabel = risk.reasons[0];
    }else if(level === 'warn'){
      s.lastRiskLabel = '주의가 필요한 쿼리로 감지되었습니다.';
    }else if(level === 'danger'){
      s.lastRiskLabel = '고위험 쿼리로 감지되었습니다.';
    }else{
      s.lastRiskLabel = '';
    }
    s.lastUpdated = this._nowIso();
    this.render();

    if((level === 'warn' || level === 'danger') && typeof window.DBAM_ON_RISK_SESSION === 'function'){
      try{
        window.DBAM_ON_RISK_SESSION({
          connId,
          connLabel: s.connLabel,
          profile: s.profile,
          user: s.user,
          riskLevel: s.lastRiskLevel,
          riskReasons: (risk && risk.reasons) ? risk.reasons.slice() : [],
          lastSql: s.lastSql,
          lastUpdated: s.lastUpdated
        });
      }catch(e){
        console.warn('DBAM_ON_RISK_SESSION handler error', e);
      }
    }
  },
  clearClosed(){
    Object.keys(this.sessions).forEach(id=>{
      const s = this.sessions[id];
      if(s && s.disconnected){
        delete this.sessions[id];
      }
    });
    this.render();
  },
  refresh(){
    this.render();
  },
  render(){
    const tbody = document.querySelector('#sessionGrid tbody');
    if(!tbody) return;
    tbody.innerHTML = '';
    const list = Object.values(this.sessions || {});
    list.sort((a,b)=>{
      if(a.status === 'running' && b.status !== 'running') return -1;
      if(a.status !== 'running' && b.status === 'running') return 1;
      return (b.lastUpdated || '').localeCompare(a.lastUpdated || '');
    });
    list.forEach(s=>{
      const tr = document.createElement('tr');

      const statusLabel = (function(){
        if(s.status === 'running') return '<span><i class="fa-solid fa-circle-play"></i> 실행 중</span>';
        if(s.status === 'disconnected') return '<span><i class="fa-regular fa-circle-xmark"></i> 종료</span>';
        return '<span><i class="fa-regular fa-circle"></i> 대기</span>';
      })();

      const riskIcon = (function(){
        if(s.lastRiskLevel === 'danger') return '<span title="위험 쿼리"><i class="fa-solid fa-fire"></i> 위험</span>';
        if(s.lastRiskLevel === 'warn') return '<span title="주의 쿼리"><i class="fa-solid fa-triangle-exclamation"></i> 주의</span>';
        return '<span><i class="fa-regular fa-circle-check"></i> 정상</span>';
      })();

      const user = s.user || (window.DBAM_CURRENT_USER || '');
      const conn = s.connLabel || s.connId || '';
      const profile = s.profile || '-';
      const lastSql = s.lastSql || '';
      const updated = (s.lastUpdated || '').replace('T',' ').replace(/\..*$/,'');

      const cols = [
        this._escape(user),
        this._escape(conn),
        this._escape(profile),
        statusLabel,
        riskIcon,
        this._escape(lastSql),
        this._escape(updated)
      ];
      cols.forEach((val, idx)=>{
        const td = document.createElement('td');
        if(idx === 0 || idx === 1 || idx === 2 || idx === 5 || idx === 6){
          td.textContent = val;
        }else{
          td.innerHTML = val;
        }
        tr.appendChild(td);
      });
      tbody.appendChild(tr);
    });
  }
};

// 쿼리 스냅샷 공유 (경량 버전)
const snapshots = {
  _lastSnapshot: null,

  createFromCurrentTab(){
    try{
      const tab = state.tabs && state.tabs.find(t=>t.id===state.activeTabId);
      if(!tab){
        alert('활성 탭이 없습니다.');
        return;
      }
      const sql = (typeof cm!=='undefined' && cm && typeof cm.getValue==='function')
        ? cm.getValue()
        : (ui && typeof ui.getEditor==='function' ? ui.getEditor() : '');
      if(!sql || !sql.trim()){
        alert('저장할 SQL이 없습니다.');
        return;
      }
      const connId = tab.connId || state.connId || null;
      const accessInfo = (state.connAccessInfo && connId) ? (state.connAccessInfo[connId] || {}) : {};
      const user = window.DBAM_CURRENT_USER || '';
      const now = new Date();
      const id = 'QS-' + now.toISOString().replace(/[-:.TZ]/g,'').slice(0,14)
        + '-' + Math.random().toString(36).slice(2,8).toUpperCase();

      const snap = {
        id,
        createdAt: now.toISOString().replace('T',' ').slice(0,19),
        user,
        connId,
        connLabel: connId ? getConnLabel(connId) : '',
        profile: connId ? getConnProfile(connId) : null,
        tabId: tab.id,
        tabTitle: tab.title || '',
        sql,
        accessReason: accessInfo.reason   || '',
        ticketId:     accessInfo.ticketId || '',
        source: (location && location.href) ? location.href.split('#')[0] : ''
      };
      this._lastSnapshot = snap;
      const json = JSON.stringify(snap);
      this.openExportModal(id, json);
    }catch(e){
      console.error('snapshot.createFromCurrentTab error', e);
      alert('스냅샷 생성 중 오류가 발생했습니다.');
    }
  },

  openExportModal(id, json){
    const backdrop = document.getElementById('snapshotBackdrop');
    const idEl = document.getElementById('snapshotId');
    const jsonEl = document.getElementById('snapshotJson');
    if(!backdrop || !idEl || !jsonEl){
      alert('스냅샷 정보를 표시할 수 없습니다(요소 누락).');
      return;
    }
    idEl.value = id || '';
    jsonEl.value = json || '';
    backdrop.classList.add('show');
    backdrop.setAttribute('aria-hidden','false');
    // JSON 전체 선택
    jsonEl.scrollTop = 0;
    jsonEl.focus();
    jsonEl.select();
  },

  closeModal(){
    const backdrop = document.getElementById('snapshotBackdrop');
    if(backdrop){
      backdrop.classList.remove('show');
      backdrop.setAttribute('aria-hidden','true');
    }
  },

  copyJson(){
    const jsonEl = document.getElementById('snapshotJson');
    if(!jsonEl) return;
    jsonEl.focus();
    jsonEl.select();
    try{
      const ok = document.execCommand('copy');
      if(ok){
        alert('스냅샷 JSON을 클립보드에 복사했습니다.');
      }else{
        alert('복사에 실패했습니다. 직접 선택 후 복사하세요.');
      }
    }catch(e){
      alert('복사에 실패했습니다. 직접 선택 후 복사하세요.');
    }
  },

  importFromPrompt(){
    const raw = window.prompt('공유받은 스냅샷 JSON을 붙여넣으세요.');
    if(!raw) return;
    let snap = null;
    try{
      snap = JSON.parse(raw);
    }catch(e){
      alert('JSON 형식이 올바르지 않습니다.');
      return;
    }
    this.applyToNewTab(snap);
  },

  applyToNewTab(snap){
    if(!snap || !snap.sql){
      alert('스냅샷에 SQL 정보가 없습니다.');
      return;
    }
    // 새 탭을 만들고 그 위에 스냅샷 상태를 입힌다.
    ui.newEditorTab();
    const tab = state.tabs && state.tabs.find(t=>t.id===state.activeTabId);
    if(!tab) return;
    if(snap.tabTitle){
      tab.title = snap.tabTitle;
    }else if(snap.id){
      tab.title = 'Snap ' + snap.id;
    }
    if(snap.connId){
      tab.connId = snap.connId;
    }
    ui.renderTabs();
    if(snap.connId){
      ui.onConnSelectChange(snap.connId);
    }
    ui.setEditor(snap.sql);
    const msgEl = document.getElementById('messages');
    if(msgEl){
      msgEl.textContent = '스냅샷에서 불러온 쿼리입니다. ID: ' + (snap.id || '');
    }
  }
};


// Result grid context menu binding
const gridEl = document.getElementById('grid');
if(gridEl){
  gridEl.addEventListener('contextmenu', (e)=>{
    e.preventDefault();
    resultCtx.open(e.clientX, e.clientY);
  });
}

/* ---------------- Bottom Tabs Controller ---------------- */
const bottomTabs = {
  area: null,
  buttons: [],
  panels: ['result','ddlPanel','historyPanel','approvalPanel','favPanel','sessionPanel','serverPanel'],
  activePanel: 'result',
  visible: false,
  init(){
    this.area = document.getElementById('bottomArea');
    this.buttons = Array.from(document.querySelectorAll('.bottom-tabs .bottom-tab'));
    this.buttons.forEach(btn=>{
      btn.addEventListener('click', ()=>{
        const panelId = btn.dataset.panel;
        this.activate(panelId);
      });
    });
  },
  showArea(){
    if(!this.area) return;
    this.area.style.display = 'flex';
    this.visible = true;
  },
  hideArea(){
    if(!this.area) return;
    this.area.style.display = 'none';
    this.visible = false;
  },
  activate(panelId){
    if(!panelId) panelId = this.activePanel || 'result';
    this.showArea();
    this.activePanel = panelId;
    // 버튼 상태
    this.buttons.forEach(btn=>{
      btn.classList.toggle('active', btn.dataset.panel === panelId);
    });
    // 패널 표시
    this.panels.forEach(id=>{
      const panel = document.getElementById(id);
      if(!panel) return;
      if(id === panelId){
        panel.classList.remove('hidden');
        panel.style.display = 'flex';
      }else{
        panel.style.display = 'none';
      }
    });
  },
  toggle(panelId){
    if(this.visible && (!panelId || this.activePanel === panelId)){
      this.hideArea();
    }else{
      this.activate(panelId || this.activePanel || 'result');
    }
  }
};


// DBeaver 스타일 테이블 편집 모달 컨트롤러
const tableEditor = {
  current: null,

  open(info) {
    const backdrop = document.getElementById('tableEditBackdrop');
    if (!backdrop) {
      alert('테이블 편집 모달 DOM을 찾지 못했습니다.');
      return;
    }

    this.current = info || null;

    const schema = info && info.schema ? info.schema : '';
    const table  = info && info.table  ? info.table  : '';
    const connId = info && info.connId ? info.connId : '';

    const fullName = (schema ? schema + '.' : '') + table;

    const titleEl = document.getElementById('teTableTitle');
    const metaEl  = document.getElementById('teTableMeta');

    if (titleEl) {
      titleEl.textContent = fullName || '(테이블 미선택)';
    }

    if (metaEl) {
      const parts = [];
      if (connId) {
        const label = (typeof getConnLabel === 'function')
          ? (getConnLabel(connId) || connId)
          : connId;
        parts.push('연결: ' + label);
      }
      if (schema) parts.push('스키마: ' + schema);
      if (table)  parts.push('테이블: ' + table);
      metaEl.textContent = parts.join('  |  ');
    }

    // 기본 탭 상태
    this.activateMainTab('props');
    this.activateSubTab('columns');

    // 내용 채우기
    this.renderColumns();
    this.renderDdl();

    // 모달 표시
    backdrop.classList.remove('hidden');
    backdrop.classList.add('show');
    backdrop.setAttribute('aria-hidden', 'false');
  },

  close() {
    const backdrop = document.getElementById('tableEditBackdrop');
    if (!backdrop) return;
    backdrop.classList.remove('show');
    backdrop.classList.add('hidden');
    backdrop.setAttribute('aria-hidden', 'true');
  },

  activateMainTab(name) {
    const root = document.getElementById('tableEditBackdrop');
    if (!root) return;

    const buttons = root.querySelectorAll('.te-tab-btn');
    buttons.forEach(btn => {
      const key = btn.getAttribute('data-main-tab');
      if (key === name) {
        btn.classList.add('active');
      } else {
        btn.classList.remove('active');
      }
    });

    const panes = root.querySelectorAll('.te-pane');
    panes.forEach(pane => {
      const key = pane.getAttribute('data-main-pane');
      if (key === name) {
        pane.classList.add('active');
      } else {
        pane.classList.remove('active');
      }
    });
  },

  activateSubTab(name) {
    const root = document.getElementById('tableEditBackdrop');
    if (!root) return;

    const buttons = root.querySelectorAll('.te-subtab-btn');
    buttons.forEach(btn => {
      const key = btn.getAttribute('data-sub-tab');
      if (key === name) {
        btn.classList.add('active');
      } else {
        btn.classList.remove('active');
      }
    });

    const panes = root.querySelectorAll('.te-subpane');
    panes.forEach(pane => {
      const key = pane.getAttribute('data-sub-pane');
      if (key === name) {
        pane.classList.add('active');
      } else {
        pane.classList.remove('active');
      }
    });
  },

  // SQL Hint 테이블(window.dbamSqlTables)에 있는 컬럼 정보로 Columns 탭 채우기
  renderColumns() {
    const info = this.current;
    const root = document.getElementById('tableEditBackdrop');
    if (!root) return;

    const tbody = root.querySelector('#teColumnsGrid tbody');
    if (!tbody) return;

    tbody.innerHTML = '';

    if (!info || !info.table) {
      return;
    }

    let cols = [];
    try {
      const map = window.dbamSqlTables || {};
      if (map && Array.isArray(map[info.table])) {
        cols = map[info.table];
      }
    } catch (e) {
      cols = [];
    }

    if (!cols.length) {
      const tr = document.createElement('tr');
      const td = document.createElement('td');
      td.colSpan = 6;
      td.textContent = '컬럼 메타데이터가 아직 준비되지 않았습니다. (SQL 힌트 테이블과 연동 예정)';
      tr.appendChild(td);
      tbody.appendChild(tr);
      return;
    }

    cols.forEach((c, idx) => {
      const tr = document.createElement('tr');
      const cells = [
        String(idx + 1),
        c.name || '',
        c.type || '',
        c.nullable != null ? String(c.nullable) : '',
        c.defaultValue != null ? String(c.defaultValue) : '',
        c.comment || c.label || ''
      ];
      cells.forEach(val => {
        const td = document.createElement('td');
        td.textContent = val;
        tr.appendChild(td);
      });
      tbody.appendChild(tr);
    });
  },

  // DDL 탭: 아직 실제 DDL 조회는 없고, 기본 골격만
  renderDdl() {
    const info  = this.current;
    const ddlEl = document.getElementById('teDdlText');
    if (!ddlEl) return;

    if (!info || !info.table) {
      ddlEl.textContent = '';
      return;
    }

    const schema   = info.schema || '';
    const table    = info.table  || '';
    const fullName = (schema ? '"' + schema + '".' : '') + '"' + table + '"';

    const lines = [];
    lines.push('-- TODO: DB 메타데이터 연동 후 실제 DDL로 대체 예정');
    lines.push('CREATE TABLE ' + fullName + ' (');
    lines.push('    -- columns ...');
    lines.push(');');

    ddlEl.textContent = lines.join('\n');
  }
};

/* ---------------- SQL Split Helpers ---------------- */
const sqlSplit = {
  // Convert CodeMirror {line,ch} to absolute offset
  offsetFromPos(cm, pos){
    const doc = cm.getDoc();
    let off = 0;
    for(let i=0;i<pos.line;i++){ off += doc.getLine(i).length + 1; } // +1 for '\n'
    return off + pos.ch;
  },
  // Convert absolute offset back to {line,ch}
  posFromOffset(cm, offset){
    const doc = cm.getDoc();
    let acc = 0;
    for(let i=0;i<doc.lineCount();i++){
      const len = doc.getLine(i).length + 1;
      if(acc + len > offset){
        return { line: i, ch: offset - acc };
      }
      acc += len;
    }
    const last = doc.lineCount()-1;
    return { line: last, ch: doc.getLine(last).length };
  },
  // Split SQL by semicolons ignoring those inside ' " /* */ -- and $...$ (PostgreSQL)
  splitStatements(sql){
    const parts = [];
    let start = 0;
    let i = 0;
    const n = sql.length;
    let inS=false,inD=false,inLC=false,inBC=false,inDollar=null;
    while(i<n){
      const c = sql[i];
      const c2 = i+1<n? sql[i+1]: '';
      // end of line-comment
      if(inLC){
        if(c === '\n'){ inLC=false; }
        i++; continue;
      }
      // end of block-comment
      if(inBC){
        if(c==='*' && c2=== '/'){ inBC=false; i+=2; continue; }
        i++; continue;
      }
      // dollar-quote
      if(inDollar){
        if(c === '$'){
          const tag = inDollar;
          if(sql.substr(i, tag.length) === tag){
            inDollar = null;
            i += tag.length;
            continue;
          }
        }
        i++; continue;
      }
      // strings
      if(inS){ if(c==="'" && sql[i-1] !== '\\\\'){ inS=false; } i++; continue; }
      if(inD){ if(c==='"' && sql[i-1] !== '\\\\'){ inD=false; } i++; continue; }
      // comment starts
      if(c==='-' && c2==='-'){ inLC=true; i+=2; continue; }
      if(c==='/' && c2==='*'){ inBC=true; i+=2; continue; }
      // string starts
      if(c==="'"){ inS=true; i++; continue; }
      if(c==='"'){ inD=true; i++; continue; }
      // dollar-quote start $tag$
      if(c==='$'){
        const m = sql.slice(i).match(/^\$[A-Za-z_]*\$/);
        if(m){ inDollar = m[0]; i += inDollar.length; continue; }
      }
      // split point
      if(c === ';'){
        const stmt = sql.slice(start, i).trim();
        if(stmt.length){ parts.push({ text: stmt, start, end: i+1 }); }
        start = i+1;
      }
      i++;
    }
    const tail = sql.slice(start).trim();
    if(tail.length){ parts.push({ text: tail, start: n }); }
    return parts;
  },
  // Get selected SQL or current statement under cursor
  selectedOrCurrent(cm){
    const doc = cm.getDoc();
    const sel = doc.getSelection();
    const full = doc.getValue();
    if(sel && sel.trim().length){ return { sql: sel, range: doc.listSelections()[0] }; }
    const cursor = doc.getCursor();
    const curOff = sqlSplit.offsetFromPos(cm, cursor);
    const stmts = sqlSplit.splitStatements(full);
    let pick = null;
    for(const s of stmts){
      if(curOff >= s.start && curOff <= s.end){ pick = s; break; }
    }
    if(!pick && stmts.length){ pick = stmts[stmts.length-1]; }
    const from = sqlSplit.posFromOffset(cm, pick.start);
    const to   = sqlSplit.posFromOffset(cm, pick.end);
    return { sql: pick.text, range: { anchor: from, head: to } };
  },
  // All statements in the editor
  all(cm){
    const doc = cm.getDoc();
    const all = doc.getValue();
    return sqlSplit.splitStatements(all);
  }
};


/* ---------------- Security: 위험 쿼리 감지 & 2단계 확인 ---------------- */

const SENSITIVE_TABLES = [
  // 운영 환경에서는 실제 개인정보/중요 테이블명을 여기에 등록
  'TB_CUST',
  'TB_CUSTOMER',
  'TB_MEMBER',
  'TB_USER'
];

// DROP/TRUNCATE/ALTER TABLE 등을 허용할 프로필 (예: DBA/OPS)
const SEC_DDL_ALLOWED_PROFILES = ['DBA', 'OPS'];

function getConnProfile(connId){
  return (state.connProfiles && connId) ? (state.connProfiles[connId] || null) : null;
}

function isDdlAllowedForConn(connId){
  const p = getConnProfile(connId);
  return !!(p && SEC_DDL_ALLOWED_PROFILES.includes(p));
}

const security = {
  analyzeSqlForRisk(sqlRaw, connId){
    const text = (sqlRaw || '').trim();
    if(!text){ return { level: 'none', reasons: [] }; }

    // 주석 제거 (/* */ 블록 + -- 한 줄 주석) 후 첫 번째 문장만 기준으로 간단 분석
    const noBlock = text.replace(/\/\*[\s\S]*?\*\//g, ' ');
    const noLine  = noBlock.replace(/--.*$/gm, ' ');
    const upper   = noLine.toUpperCase();
    const firstStmt = upper.split(';')[0];
    const simple  = firstStmt.replace(/\s+/g, ' ').trim();

    let level = 'none';
    const reasons = [];

    // 1) DROP / TRUNCATE / ALTER TABLE
    if(/\b(DROP|TRUNCATE)\s+TABLE\b/.test(simple) || /\bALTER\s+TABLE\b/.test(simple)){
      const allowed = isDdlAllowedForConn(connId);
      reasons.push('DROP/TRUNCATE/ALTER TABLE 문장입니다.' + (allowed ? ' (DBA/OPS 프로필에서만 허용됩니다.)' : ' 관리자 또는 별도 모드에서만 허용해야 합니다.'));
      if(!allowed){
        level = 'block';
      }else if(level === 'none'){
        // DBA/OPS의 경우 경고만 띄우고 확인 후 진행
        level = 'warn';
      }
    }

    // 2) UPDATE / DELETE 이면서 WHERE 없음 → 경고 후 진행 여부 선택
    if(/^UPDATE\b/.test(simple) || /^DELETE\b/.test(simple)){
      if(!/\bWHERE\b/.test(simple)){
        reasons.push('UPDATE/DELETE 문에 WHERE 절이 없습니다.');
        if(level === 'none'){
          level = 'warn';
        }
      }
    }

    // 3) 개인정보 테이블에 대한 SELECT * → 승인 요청 대상 (데모)
    const m = simple.match(/^SELECT\s+\*\s+FROM\s+([A-Z0-9_\.]+)/);
    if(m){
      const fullName = m[1];
      const baseName = fullName.split('.').pop();
      if(SENSITIVE_TABLES.includes(baseName)){
        reasons.push(`개인정보 테이블(${baseName})에 대한 SELECT * 입니다. 승인 절차가 필요합니다.`);
        if(level === 'none' || level === 'warn'){
          level = 'approval';
        }
      }
    }

    return { level, reasons };
  },

  /**
   * 단일 실행(runCurrent) 전에 위험도 확인.
   * true  → 그대로 실행 계속
   * false → 실행 중단
   */
  beforeExecuteSingle(sql, connId){
    const risk = this.analyzeSqlForRisk(sql, connId);
    if(!risk || risk.level === 'none'){ return true; }

    const msg = (risk.reasons && risk.reasons.length)
      ? risk.reasons.join('\n')
      : '위험도가 높은 SQL로 감지되었습니다.';

    if(risk.level === 'block'){
      alert(msg + '\n\n보안 정책에 따라 이 쿼리는 UI에서 실행할 수 없습니다.');
      return false;
    }

    if(risk.level === 'approval'){
      if(typeof approvalCenter !== 'undefined' && approvalCenter.beginRequest){
        try{
          approvalCenter.beginRequest({ sql, connId, risk });
        }catch(e){
          console.warn('approvalCenter.beginRequest error', e);
          alert(msg + '\n\n승인 요청 처리 중 오류가 발생했습니다. 관리자에게 문의하세요.');
        }
      }else{
        alert(msg + '\n\n(승인 워크플로가 아직 연결되지 않아 실행이 취소됩니다.)');
      }
      return false;
    }

    if(risk.level === 'warn'){
      const ok = confirm(msg + '\n\n계속 실행하시겠습니까?');
      if(ok && typeof sessionMonitor!=='undefined' && sessionMonitor.markRisk){
        sessionMonitor.markRisk(connId, risk);
      }
      return !!ok;
    }

    if(risk.level === 'otp'){
      const code = prompt(
        msg + '\n\n2단계 확인(OTP/비밀번호 등)을 입력하세요.\n' +
        '(데모 모드에서는 값만 입력하면 값이 비어있지만 않으면 통과합니다.)'
      );
      if(!code){
        alert('2단계 확인이 취소되어 쿼리를 실행하지 않습니다.');
        return false;
      }
      // 실제 환경에서는 여기에서 서버 쪽 검증 추가 필요
      if(typeof sessionMonitor!=='undefined' && sessionMonitor.markRisk){
        sessionMonitor.markRisk(connId, risk);
      }
      return true;
    }

    return true;
  }
}
/* ---------------- Excel Export Policy (엑셀 내보내기 정책 1단계) ---------------- */
const excelPolicy = {
  // 민감/중요 데이터가 들어있는 테이블명 목록 (대문자 기준 매칭 권장)
  // 예: 'TB_CUST', 'TB_ACCOUNT', ...
  sensitiveTables: [
    // 'TB_CUST',
    // 'TB_ACCOUNT',
    // 'TB_EMPLOYEE'
  ],

  // 컬럼명 기준으로 민감 데이터를 판별할 때 사용할 키워드 목록
  // 예: 주민번호, 계좌번호, 카드번호, 연락처 등
  sensitiveColumns: [
    // 'RRN',          // 주민등록번호
    // 'JUMIN_NO',
    // 'RESIDENT_NO',
    // 'ACCOUNT_NO',   // 계좌번호
    // 'CARD_NO',
    // 'PHONE_NO',
    // 'MOBILE_NO',
    // 'TEL_NO',
    // 'EMAIL'
  ],

  // 승인 없이 엑셀로 내보내기를 허용할 최대 건수 (비민감 데이터 기준)
  // 이 값을 초과하면 최소 경고 또는 승인 요청 대상으로 판단
  maxRowsWithoutApproval: 5000,

  // 사용자별 일일 누적 다운로드 허용 건수(행 기준)
  // 운영 환경/업무 특성에 맞게 추후 조정 가능
  dailyRowLimitPerUser: 20000
};


/* ---------------- Excel Result Meta (엑셀 쿼리 결과 메타 정보 2단계) ---------------- */
/**
 * currentResultMeta
 * - 마지막으로 실행된 쿼리/그리드 결과에 대한 메타 정보
 * - 이후 엑셀 내보내기 위험도 평가(evaluateExcelRisk) 등에 사용될 예정
 */
let currentResultMeta = null;

/**
 * resultMeta 객체를 생성하는 헬퍼.
 * options: {
 *   queryId, sql, rowCount, tableNames, columnNames,
 *   hasSensitiveTable, hasSensitiveColumn, userId, executedAt
 * }
 */
function createResultMeta(options){
  const now = options && options.executedAt ? new Date(options.executedAt) : new Date();

  return {
    queryId: options && options.queryId != null ? options.queryId : null,
    sql: options && options.sql ? String(options.sql) : '',
    rowCount: options && typeof options.rowCount === 'number' ? options.rowCount : 0,
    tableNames: options && Array.isArray(options.tableNames) ? options.tableNames.slice() : [],
    columnNames: options && Array.isArray(options.columnNames) ? options.columnNames.slice() : [],
    hasSensitiveTable: !!(options && options.hasSensitiveTable),
    hasSensitiveColumn: !!(options && options.hasSensitiveColumn),
    userId: options && options.userId ? String(options.userId) : null,
    executedAt: now
  };
}

/**
 * 쿼리 실행 결과 정보(execInfo)를 기반으로 currentResultMeta를 갱신한다.
 * execInfo: {
 *   queryId, sql, rowCount, tableNames, columnNames, userId, executedAt
 * }
 *
 * - tableNames / columnNames는 대문자로 변환 후 excelPolicy의 기준과 비교
 * - 실제 쿼리 실행 시점에서 이 함수를 호출해 currentResultMeta를 최신 상태로 유지
 */
function setCurrentResultMetaFromExecution(execInfo){
  execInfo = execInfo || {};

  const sql = execInfo.sql || '';
  const rowCount = typeof execInfo.rowCount === 'number' ? execInfo.rowCount : 0;
  const tableNames = Array.isArray(execInfo.tableNames) ? execInfo.tableNames : [];
  const columnNames = Array.isArray(execInfo.columnNames) ? execInfo.columnNames : [];

  const upperTables = tableNames.map(n => String(n || '').toUpperCase());
  const upperCols = columnNames.map(n => String(n || '').toUpperCase());

  const hasSensitiveTable = upperTables.some(n => excelPolicy.sensitiveTables.includes(n));
  const hasSensitiveColumn = upperCols.some(n => excelPolicy.sensitiveColumns.includes(n));

  currentResultMeta = createResultMeta({
    queryId: execInfo.queryId || null,
    sql,
    rowCount,
    tableNames,
    columnNames,
    hasSensitiveTable,
    hasSensitiveColumn,
    userId: execInfo.userId || null,
    executedAt: execInfo.executedAt || new Date()
  });
}

/**
 * currentResultMeta를 초기화
 */
function clearCurrentResultMeta(){
  currentResultMeta = null;
}

/**
 * 현재 설정된 resultMeta를 반환 (없으면 null)
 */
function getCurrentResultMeta(){
  return currentResultMeta;
}

/* ---------------- Excel Risk Evaluation (엑셀 내보내기 위험도 평가 3단계) ---------------- */
/**
 * 사용자별 일일 누적 다운로드 건수를 조회하는 헬퍼.
 * - 현재 단계에서는 항상 0을 반환 (8단계에서 실제 구현 예정)
 */
function getDailyDownloadRows(userId, tableNames){
  // 간단한 데모 구현:
  // - 오늘 날짜 기준으로, 동일 사용자에 대해 실제 다운로드가 수행된 행(rowCount)의 합계를 반환
  // - 실제 운영에서는 서버측 로그/통계 쿼리로 대체 가능
  if(!userId){
    return 0;
  }

  // 오늘(로컬 기준) YYYY-MM-DD 키 생성
  const now = new Date();
  const y = now.getFullYear();
  const m = String(now.getMonth() + 1).padStart(2, '0');
  const d = String(now.getDate()).padStart(2, '0');
  const todayKey = y + '-' + m + '-' + d;

  // 비교용 테이블명(대문자) 목록
  const targetTables = Array.isArray(tableNames)
    ? tableNames.map(n => String(n || '').toUpperCase())
    : null;

  let sum = 0;

  try{
    if(Array.isArray(excelExportLogs)){
      for(const log of excelExportLogs){
        if(!log) continue;
        if(log.userId !== userId) continue;

        // 날짜 비교 (로컬 기준)
        const ts = new Date(log.timestamp);
        if(!ts || isNaN(ts.getTime())) continue;
        const ly = ts.getFullYear();
        const lm = String(ts.getMonth() + 1).padStart(2, '0');
        const ld = String(ts.getDate()).padStart(2, '0');
        const logKey = ly + '-' + lm + '-' + ld;
        if(logKey !== todayKey) continue;

        // 실제 다운로드가 수행된 로그만 집계
        const mode = log.mode || 'DIRECT';
        const approved = !!log.approved;
        // DIRECT 모드는 항상 다운로드 수행,
        // APPROVAL 모드는 approved=true인 경우에만 다운로드로 간주
        if(!(mode === 'DIRECT' || (mode === 'APPROVAL' && approved))){
          continue;
        }

        // 테이블명 필터: targetTables가 있으면 교집합이 있을 때만 집계
        if(targetTables && targetTables.length){
          const logTables = Array.isArray(log.tableNames)
            ? log.tableNames.map(n => String(n || '').toUpperCase())
            : [];
          const hasIntersection = logTables.some(t => targetTables.includes(t));
          if(!hasIntersection){
            continue;
          }
        }

        const rows = typeof log.rowCount === 'number' ? log.rowCount : 0;
        if(rows > 0){
          sum += rows;
        }
      }
    }
  }catch(e){
    console.warn('getDailyDownloadRows failed', e);
  }

  return sum;
}

/**
 * resultMeta를 기반으로 엑셀 내보내기 위험도를 평가한다.
 * meta: createResultMeta / setCurrentResultMetaFromExecution으로 생성된 객체
 * 반환: { level: 'LOW' | 'MID' | 'HIGH', reasons: string[] }
 */
function evaluateExcelRisk(meta){
  meta = meta || {};
  const levelConst = { LOW: 'LOW', MID: 'MID', HIGH: 'HIGH' };
  let level = levelConst.LOW;
  const reasons = [];

  const rowCount = typeof meta.rowCount === 'number' ? meta.rowCount : 0;
  const hasSensitiveTable = !!meta.hasSensitiveTable;
  const hasSensitiveColumn = !!meta.hasSensitiveColumn;
  const userId = meta.userId || null;
  const tableNames = Array.isArray(meta.tableNames) ? meta.tableNames : [];

  // 1) 민감 데이터 포함 여부 (테이블/컬럼)
  if(hasSensitiveTable || hasSensitiveColumn){
    level = levelConst.HIGH;
    reasons.push('민감 데이터(테이블/컬럼) 포함');
  }

  // 2) 단일 다운로드 건수 기준
  if(rowCount > excelPolicy.maxRowsWithoutApproval){
    if(level === levelConst.LOW){
      level = levelConst.MID;
    }
    reasons.push('다운로드 건수 초과: ' + rowCount + '건');
  }

  // 3) 사용자별 일일 누적 다운로드 기준 (선택 사항, 8단계에서 확장)
  try{
    const dailyUsage = getDailyDownloadRows(userId, tableNames);
    if(dailyUsage != null && (dailyUsage + rowCount) > excelPolicy.dailyRowLimitPerUser){
      level = levelConst.HIGH;
      reasons.push('일일 누적 다운로드 한도 초과 가능');
    }
  }catch(e){
    console.warn('evaluateExcelRisk: daily usage check failed', e);
  }

  return { level, reasons };
}

/* ---------------- Excel Export Logging (엑셀 내보내기 로그/감사 7단계) ---------------- */
/**
 * Excel 내보내기 로그 목록 (데모/프론트 전용)
 * - 실제 운영에서는 서버 측 테이블/로그로 전환 예정
 */
const excelExportLogs = [];

/**
 * Excel 내보내기 시 로그를 남기는 헬퍼 함수.
 * meta: resultMeta 또는 유사 객체 (sql, rowCount, tableNames 등 포함)
 * info: {
 *   level: 'LOW' | 'MID' | 'HIGH',
 *   reasons: string[],
 *   approved: boolean,         // 결재 승인 후 다운로드 여부
 *   approvalId: string|null,   // 결재 ID (EXCEL_EXPORT 타입일 때)
 *   mode: 'DIRECT'|'APPROVAL'  // 바로 내보내기 / 결재 후 내보내기 구분
 * }
 */
function logExcelExport(meta, info){
  try{
    meta = meta || {};
    info = info || {};

    const entry = {
      timestamp: new Date(),
      userId: meta.userId || (typeof approvalCenter !== 'undefined' && typeof approvalCenter._currentUser === 'function'
        ? approvalCenter._currentUser()
        : (window.DBAM_CURRENT_USER || null)),
      sql: meta.sql || '',
      rowCount: typeof meta.rowCount === 'number' ? meta.rowCount : (meta.rowCount || null),
      tableNames: Array.isArray(meta.tableNames) ? meta.tableNames.slice() : [],
      riskLevel: info.level || null,
      riskReasons: Array.isArray(info.reasons) ? info.reasons.slice() : [],
      approved: !!info.approved,
      approvalId: info.approvalId || null,
      mode: info.mode || 'DIRECT'
    };

    excelExportLogs.push(entry);
    // 콘솔에서 확인할 수 있도록 디버그 출력 (운영 시 제거 가능)
    console.debug('Excel export logged', entry);
  }catch(e){
    console.warn('logExcelExport failed', e);
  }
}



/**
 * 엑셀 내보내기 버튼 클릭 핸들러 (4단계)
 * - state.lastResult / state.lastSql 을 기반으로 resultMeta를 구성
 * - evaluateExcelRisk(meta)로 LOW/MID/HIGH 판정 후 분기
 *   - LOW  : 바로 기존 감사/반출 모달(actions.exportCsv) 실행
 *   - MID  : 경고 confirm 후 계속 시 기존 감사/반출 모달 실행
 *   - HIGH : 경고 alert 후 현재 단계에서는 기존 감사/반출 모달 실행
 *            (다음 단계에서 쿼리 결재 연동 로직을 추가 예정)
 */
function onClickExportExcel(){
  // 1) 연결된 DB 여부 체크: 하나도 없으면 안내 후 종료
  try{
    let hasActiveConn = false;
    if (state && state.connStates) {
      for (const id in state.connStates) {
        if (Object.prototype.hasOwnProperty.call(state.connStates, id) && state.connStates[id]) {
          hasActiveConn = true;
          break;
        }
      }
    }
    if (!hasActiveConn) {
      alert('DB 연결 후 실행하세요.');
      return;
    }
  }catch(e){
    console.warn('onClickExportExcel: conn 상태 확인 중 오류', e);
  }

  // 2) 내보낼 결과 존재 여부 체크
  try{
    if(!state || !state.lastResult || !state.lastResult.columns || !state.lastResult.columns.length){
      alert('내보낼 결과가 없습니다.');
      return;
    }
  }catch(e){
    console.warn('onClickExportExcel: state 확인 중 오류', e);
  }


  const lr = state.lastResult || {};
  const rowCount = typeof lr.rowCount === 'number' ? lr.rowCount : (lr.rows ? lr.rows.length : 0);
  const cols = lr.columns || [];
  const colNames = cols.map(function(c){
    if(!c) return '';
    if(typeof c === 'string') return c;
    return c.name || c.label || '';
  });

  let userId = null;
  try{
    if(typeof approvalCenter !== 'undefined' && typeof approvalCenter._currentUser === 'function'){
      userId = approvalCenter._currentUser();
    }else if(window.DBAM_CURRENT_USER){
      userId = window.DBAM_CURRENT_USER;
    }
  }catch(e){
    console.warn('onClickExportExcel: userId 확인 중 오류', e);
  }

  try{
    setCurrentResultMetaFromExecution({
      queryId: null,
      sql: (state && state.lastSql) ? state.lastSql : '',
      rowCount: rowCount,
      tableNames: [], // TODO: 필요 시 쿼리 파싱/메타 정보와 연계
      columnNames: colNames,
      userId: userId,
      executedAt: new Date()
    });
  }catch(e){
    console.warn('onClickExportExcel: setCurrentResultMetaFromExecution 오류', e);
  }

  const meta = getCurrentResultMeta();
  const risk = evaluateExcelRisk(meta);
  const level = risk && risk.level ? risk.level : 'LOW';
  const reasons = Array.isArray(risk && risk.reasons) ? risk.reasons : [];

  // LOW: 바로 기존 Excel 내보내기 절차로 이동 (직접 내보내기 모드)
  if(level === 'LOW'){
    logExcelExport(meta, {
      level: level,
      reasons: reasons,
      approved: false,
      approvalId: null,
      mode: 'DIRECT'
    });
    actions.exportCsv();
    return;
  }

  // MID: 경고 후 계속 진행 여부 확인 (직접 내보내기 모드)
  if(level === 'MID'){
    const ok = window.confirm(
      '[주의] 대량 데이터 Excel 내보내기입니다.\n' +
      (reasons.length ? reasons.join('\n') + '\n\n' : '') +
      '계속 진행하시겠습니까?'
    );
    if(!ok) return;
    logExcelExport(meta, {
      level: level,
      reasons: reasons,
      approved: false,
      approvalId: null,
      mode: 'DIRECT'
    });
    actions.exportCsv();
    return;
  }

  // HIGH: 고위험 Excel 내보내기인 경우: 쿼리 결재함(EXCEL_EXPORT 타입)으로 승인 요청
  if(level === 'HIGH'){
    if(typeof approvalCenter === 'undefined' || typeof approvalCenter.beginRequest !== 'function'){
      alert(
        '[경고] 고위험 Excel 내보내기입니다.\n' +
        (reasons.length ? reasons.join('\n') + '\n\n' : '') +
        '승인 요청 모듈(approvalCenter)을 찾을 수 없어,\n' +
        '기존 Excel 내보내기 절차로 진행합니다.'
      );
      logExcelExport(meta, {
        level: level,
        reasons: reasons,
        approved: false,
        approvalId: null,
        mode: 'DIRECT'
      });
      actions.exportCsv();
      return;
    }

    // 엑셀 전용 EXCEL_EXPORT 타입으로 결재 요청 시작 (결재 후 내보내기 모드)
    const ctx = {
      sql: meta && meta.sql ? meta.sql : ((state && state.lastSql) ? state.lastSql : ''),
      connId: (state && state.activeConnId) ? state.activeConnId : null,
      risk: {
        level: level,
        reasons: reasons.slice()
      },
      type: 'EXCEL_EXPORT',
      exportRowCount: rowCount
    };

    // 결재 요청 단계 로그 (approved=false, mode='APPROVAL')
    logExcelExport(meta, {
      level: level,
      reasons: reasons,
      approved: false,
      approvalId: ctx.id || null,
      mode: 'APPROVAL'
    });

    approvalCenter.beginRequest(ctx);
    return;
  }

  // 그 외 예외적인 경우에도 기본 동작 유지
  actions.exportCsv();
}






;


/* ---------------- Query Approval Center (민감 쿼리 결재 데모) ---------------- */
const approvalCenter = {
  _seq: 1,
  requests: [],
  currentDraft: null,
  currentFilter: 'all',
  currentPeriod: '30d',
  currentTypeFilter: 'all',
  currentDetailId: null,

  _nowIso(dt){
    const d = dt || new Date();
    try{
      return d.toISOString();
    }catch(e){
      return d.toString();
    }
  },
  _nowLabel(dt){
    const d = dt || new Date();
    try{
      const y = d.getFullYear();
      const m = String(d.getMonth()+1).padStart(2,'0');
      const day = String(d.getDate()).padStart(2,'0');
      const hh = String(d.getHours()).padStart(2,'0');
      const mm = String(d.getMinutes()).padStart(2,'0');
      const ss = String(d.getSeconds()).padStart(2,'0');
      return y + '-' + m + '-' + day + ' ' + hh + ':' + mm + ':' + ss;
    }catch(e){
      return d.toString();
    }
  },
  _fmtMmDd(dt){
    if(!dt) return '';
    try{
      const d = (dt instanceof Date) ? dt : new Date(dt);
      if(!(d instanceof Date) || isNaN(d.getTime())) return '';
      const m = String(d.getMonth()+1).padStart(2,'0');
      const day = String(d.getDate()).padStart(2,'0');
      return m + '/' + day;
    }catch(e){
      return '';
    }
  },
  _fmtHm(dt){
    if(!dt) return '';
    try{
      const d = (dt instanceof Date) ? dt : new Date(dt);
      if(!(d instanceof Date) || isNaN(d.getTime())) return '';
      const hh = String(d.getHours()).padStart(2,'0');
      const mm = String(d.getMinutes()).padStart(2,'0');
      return hh + ':' + mm;
    }catch(e){
      return '';
    }
  },
  _decorateApprovalLineWithTime(container, req){
    if(!container || !req) return;

    const children = Array.from(container.children || []);
    if(!children.length) return;

    // 첫 번째 DIV는 요청자 노드, 나머지 DIV는 승인자 노드로 본다.
    const requesterNode = children.find(function(el){ return el && el.tagName === 'DIV'; });
    const approverNodes = children.filter(function(el){
      return el && el.tagName === 'DIV' && el !== requesterNode;
    });

    const requestedAt = req.requestedAt ? new Date(req.requestedAt) : null;

    // 요청자 박스는 항상 동일하게 데코레이션
    if(requesterNode){
      this._decorateRequesterNode(requesterNode, requestedAt);
    }

    const hasSteps = Array.isArray(req.approvalSteps) && req.approvalSteps.length > 0;
    let approvalSteps = [];
    let currentStep = null;

    if(hasSteps){
      const steps = req.approvalSteps;
      approvalSteps = steps.filter(function(step){
        return step && (step.type || 'approval') === 'approval';
      });
      if(typeof req.currentStepIndex === 'number' &&
         req.currentStepIndex >= 0 &&
         req.currentStepIndex < steps.length){
        currentStep = steps[req.currentStepIndex];
      }
    }

    if(hasSteps && approvalSteps.length){
      // 다단계 결재 정보가 있을 때: 각 승인자 박스를 단계별로 데코레이션
      approverNodes.forEach((node, idx)=>{
        const step = approvalSteps[idx] || null;
        let approverAt = null;
        let stepStatus = null;
        let isCurrent = false;

        if(step){
          stepStatus = step.status || null;
          if(step.decidedAt){
            try{
              approverAt = new Date(step.decidedAt);
            }catch(e){}
          }
          if(currentStep && currentStep === step){
            isCurrent = true;
          }
        }

        this._decorateApproverNode(node, approverAt, stepStatus, isCurrent, step);
      });
    }else{
      // 결재선 정보가 없는 경우: 기존 단일 단계 표시 방식 유지 (호환용)
      let approverAtRaw = null;
      if(req.status === 'REJECTED'){
        approverAtRaw = req.rejectedAt || null;
      }else{
        approverAtRaw = req.approvedAt || null;
      }
      const approverAt = approverAtRaw ? new Date(approverAtRaw) : null;

      approverNodes.forEach((node)=>{
        this._decorateApproverNode(node, approverAt, req.status, false, null);
      });
    }
  },  _decorateRequesterNode(node, requestedAt){
    if(!node || node.dataset.detailDecorated === '1') return;
    node.dataset.detailDecorated = '1';

    const oldTop = node.firstElementChild;
    const oldBottom = oldTop ? oldTop.nextElementSibling : null;
    const roleLabel = oldTop && oldTop.textContent ? oldTop.textContent.trim() : '직급';
    const userLabel = oldBottom && oldBottom.textContent ? oldBottom.textContent.trim() : '로그인 사용자';

    const dateStr = this._fmtMmDd(requestedAt);
    const timeStr = this._fmtHm(requestedAt);

    // 공통 박스 스타일 (요청자도 높이 맞추기)
    node.style.borderRadius = node.style.borderRadius || '8px';
    node.style.padding = '6px 10px';
    node.style.border = node.style.border || '1px solid #e5e7eb';
    node.style.background = node.style.background || '#f9fafb';
    node.style.textAlign = 'center';
    node.style.display = 'flex';
    node.style.flexDirection = 'column';
    node.style.justifyContent = 'center';
    node.style.minHeight = '72px';

    node.innerHTML = '';

    const line1 = document.createElement('div');
    line1.style.fontSize = '11px';
    line1.style.color = '#6b7280';
    line1.textContent = roleLabel;
    node.appendChild(line1);

    if(dateStr){
      const dEl = document.createElement('div');
      dEl.style.fontSize = '10px';
      dEl.style.color = '#6b7280';
      dEl.textContent = dateStr;
      node.appendChild(dEl);
    }
    if(timeStr){
      const tEl = document.createElement('div');
      tEl.style.fontSize = '10px';
      tEl.style.color = '#6b7280';
      tEl.textContent = timeStr;
      node.appendChild(tEl);
    }

    const nameEl = document.createElement('div');
    nameEl.style.fontSize = '12px';
    nameEl.style.fontWeight = '500';
    nameEl.style.color = '#111827';
    nameEl.textContent = userLabel;
    node.appendChild(nameEl);
  },
  _decorateApproverNode(node, approvedAt, stepStatus, isCurrent, step){
    if(!node) return;

    const oldTop = node.firstElementChild;
    const oldBottom = oldTop ? oldTop.nextElementSibling : null;
    const roleLabel = oldTop && oldTop.textContent ? oldTop.textContent.trim() : '직급';
    const nameLabelRaw = oldBottom && oldBottom.textContent ? oldBottom.textContent.trim() : '미지정';

    // 기존 이름에서 "(대결)" 꼬리표가 이미 붙어 있다면 제거
    const baseName = nameLabelRaw.replace(/\s*\(대결\)\s*$/, '');

    // delegate 관련 정보 (approvalSteps에서 전달된 step 기준)
    const isDelegate = step && step.isDelegate === 'Y';
    const originalName = (step && step.originalName) ? step.originalName : '';
    const originalTitle = (step && step.originalTitle) ? step.originalTitle : '';

    const hasTime = (approvedAt instanceof Date) && !isNaN(approvedAt.getTime());
    const dateStr = hasTime ? this._fmtMmDd(approvedAt) : '';
    const timeStr = hasTime ? this._fmtHm(approvedAt) : '';

    const isApproved = (stepStatus === 'APPROVED');
    const isRejected = (stepStatus === 'REJECTED');
    const isPending  = (stepStatus === 'PENDING');

    // 박스 기본 스타일
    node.style.borderRadius = node.style.borderRadius || '8px';
    node.style.padding = node.style.padding || '6px 10px';
    node.style.border = node.style.border || '1px solid #e5e7eb';
    node.style.background = node.style.background || '#f9fafb';
    node.style.textAlign = 'center';
    node.style.display = 'flex';
    node.style.flexDirection = 'column';
    node.style.justifyContent = 'center';
    node.style.minHeight = '72px';

    // 기존 내용 제거
    node.innerHTML = '';

    // 역할 + 상태 텍스트
    const roleEl = document.createElement('div');
    roleEl.style.fontSize = '11px';
    roleEl.style.marginBottom = '1px';

    let roleText = roleLabel;
    if(isRejected){
      // 반려: 붉은색 + (반려)
      roleEl.style.color = '#b91c1c';
      roleText = roleLabel + ' (반려)';
    }else{
      // 기본: 초록색, 승인/현재 상태에 따라 꼬리표
      roleEl.style.color = '#16a34a';
      if(isApproved){
        roleText = roleLabel + ' (승인)';
      }else if(isCurrent && isPending){
        roleText = roleLabel + ' (현재)';
      }else{
        roleText = roleLabel;
      }
    }

    roleEl.textContent = roleText;
    node.appendChild(roleEl);

    // 날짜
    if(dateStr){
      const dEl = document.createElement('div');
      dEl.style.fontSize = '10px';
      dEl.style.color = '#6b7280';
      dEl.textContent = dateStr;
      node.appendChild(dEl);
    }
    // 시간
    if(timeStr){
      const tEl = document.createElement('div');
      tEl.style.fontSize = '10px';
      tEl.style.color = '#6b7280';
      tEl.textContent = timeStr;
      node.appendChild(tEl);
    }

    // 이름 (대결인 경우 "(대결)" 표기 + 원결재자 툴팁)
    const nameEl = document.createElement('div');
    nameEl.style.fontSize = '12px';
    nameEl.style.fontWeight = '500';
    nameEl.style.color = '#111827';

    if(isDelegate && originalName){
      nameEl.textContent = (baseName || '미지정') + ' (대결)';
      let tip = '원결재자: ' + originalName;
      if(originalTitle){
        tip += ' / ' + originalTitle;
      }
      node.title = tip;
    }else{
      nameEl.textContent = baseName || '미지정';
    }

    node.appendChild(nameEl);
  },

  _currentUser(){
    return window.DBAM_CURRENT_USER || 'demoUser';
  },
  _currentUserLabel(){
    return window.DBAM_CURRENT_USER_NAME || window.DBAM_CURRENT_USER || 'demoUser';
  },
  _canCurrentUserApprove(req){
    if(!req || req.status !== 'REQUESTED') return false;

    // 결재선이 정의되어 있지 않으면, 호환성을 위해 로그인한 사용자면 승인 가능하게 둠
    if(!Array.isArray(req.approvalSteps) || req.approvalSteps.length === 0){
      const meFallback = this._currentUser();
      return !!meFallback;
    }

    if(typeof req.currentStepIndex !== 'number' ||
       req.currentStepIndex < 0 ||
       req.currentStepIndex >= req.approvalSteps.length){
      return false;
    }

    const step = req.approvalSteps[req.currentStepIndex];
    if(!step || (step.type || 'approval') !== 'approval') return false;

    const me = this._currentUser();
    return !!me && step.empId === me;
  },

  _statusLabel(st){
    switch(st){
      case 'REQUESTED': return '승인대기';
      case 'APPROVED':  return '승인';
      case 'REJECTED':  return '반려';
      case 'EXECUTED':  return '실행완료';
      default:          return st || '임시';
    }
  },
  _statusBadgeHtml(st){
    const label = this._statusLabel(st);
    let bg = '#e5e7eb', color = '#374151';
    if(st === 'REQUESTED'){ bg = '#f97316'; color = '#fff'; }
    else if(st === 'APPROVED'){ bg = '#22c55e'; color = '#fff'; }
    else if(st === 'REJECTED'){ bg = '#ef4444'; color = '#fff'; }
    else if(st === 'EXECUTED'){ bg = '#0ea5e9'; color = '#fff'; }
    return '<span style="display:inline-block;padding:2px 6px;border-radius:999px;font-size:11px;background:'+bg+';color:'+color+';">'+label+'</span>';
  },

  beginRequest(ctx){
    const sql     = (ctx && ctx.sql)     || '';
    const connId  = (ctx && ctx.connId)  || null;
    const risk    = (ctx && ctx.risk)    || {reasons:[]};
    const reasons = Array.isArray(risk.reasons) ? risk.reasons.slice() : [];

    const tab = state.tabs.find(t => t.id === state.activeTabId) || {};
    const connLabel = (typeof getConnLabel === 'function') ? (getConnLabel(connId) || connId || '') : (connId || '');
    const dbName    = tab.dbName || '';
    const schema    = tab.schema || tab.schemaName || '';

    const draft = {
      id: 'APR-' + String(this._seq++).padStart(4,'0'),
      status: 'DRAFT',
      connId,
      connLabel,
      dbName,
      schemaName: schema,
      requester: this._currentUser(),
      requesterLabel: this._currentUserLabel(),
      approver: '',
      approverLabel: '',
      reason: '',
      itsmNo: '',
      riskReasons: reasons,
      sql: sql,
      sqlFirstLine: (sql || '').split(/\r?\n/)[0].slice(0,120),
      // 결재 유형: 기본은 SQL_EXECUTE, 엑셀 내보내기는 EXCEL_EXPORT
      approvalType: (ctx && ctx.type) || 'SQL_EXECUTE',
      // 엑셀 내보내기 요청 시 예상 행 수(선택)
      exportRowCount: (ctx && typeof ctx.exportRowCount === 'number') ? ctx.exportRowCount : null,
      // 다단계 결재선을 위한 초기 구조
      approvalSteps: [],
      currentStepIndex: null,
      requestedAt: null,
      approvedAt: null,
      rejectedAt: null,
      executedAt: null,
      allowedExecCount: 1,
      usedExecCount: 0,
      requestedExecCount: 1,
      validFrom: null,
      validTo: null
    };
    this.currentDraft = draft;
    this._openRequestModal(draft);
  },

  _openRequestModal(req){
    const backdrop = document.getElementById('approvalRequestBackdrop');
    if(!backdrop){
      alert('승인 요청 모달 DOM을 찾지 못했습니다.');
      return;
    }

    const type = req.approvalType || req.type || 'SQL_EXECUTE';

    const titleSpan      = backdrop.querySelector('[data-role="apReqTitleText"]');
    const guideEl        = backdrop.querySelector('[data-role="apReqGuide"]');
    const reasonLabel    = backdrop.querySelector('[data-role="apReqReasonLabel"]');
    const reasonTa       = backdrop.querySelector('#apReqReason');
    const execCountLabel = backdrop.querySelector('[data-role="apReqExecCountLabel"]');

    if(type === 'EXCEL_EXPORT'){
      if(titleSpan) titleSpan.textContent = '엑셀 내보내기 승인 요청';
      if(guideEl) guideEl.textContent = '대량 데이터/개인정보를 엑셀로 내보낼 때는 승인 후 다운로드하도록 설계된 데모입니다.';
      if(reasonLabel){
        for(const node of reasonLabel.childNodes){
          if(node.nodeType === Node.TEXT_NODE){
            node.textContent = '엑셀 내보내기 사유';
            break;
          }
        }
      }
      if(execCountLabel){
        for(const node of execCountLabel.childNodes){
          if(node.nodeType === Node.TEXT_NODE){
            node.textContent = '허용 다운로드 횟수';
            break;
          }
        }
      }
      if(reasonTa){
        reasonTa.placeholder = '왜 이 데이터를 엑셀로 내보내야 하는지 업무 사유를 입력하세요.';
      }
    }else{
      if(titleSpan) titleSpan.textContent = '위험 쿼리 승인 요청';
      if(guideEl) guideEl.textContent = '개인정보/민감 테이블에 대한 쿼리는 바로 실행하지 않고 승인 요청 후 실행하도록 설계된 데모입니다.';
      if(reasonLabel){
        for(const node of reasonLabel.childNodes){
          if(node.nodeType === Node.TEXT_NODE){
            node.textContent = '사유';
            break;
          }
        }
      }
      if(execCountLabel){
        for(const node of execCountLabel.childNodes){
          if(node.nodeType === Node.TEXT_NODE){
            node.textContent = '허용 실행 횟수';
            break;
          }
        }
      }
      if(reasonTa){
        reasonTa.placeholder = '왜 이 쿼리를 실행해야 하는지 업무 사유를 입력하세요.';
      }
    }

    // 채우기
    const connEl   = backdrop.querySelector('[data-field="connLabel"]');
    const schemaEl = backdrop.querySelector('[data-field="schemaName"]');
    const userEl   = backdrop.querySelector('[data-field="requester"]');
    const bizEl    = backdrop.querySelector('[data-field="bizName"]');
    const riskEl   = backdrop.querySelector('[data-field="riskReasons"]');
    const sqlEl    = backdrop.querySelector('#apReqSql');

    if(connEl)   connEl.textContent   = (req.connLabel || req.connId || '');
    if(schemaEl) schemaEl.textContent = req.schemaName || '';
    if(userEl)   userEl.textContent   = req.requesterLabel || req.requester || '';
    if(bizEl)    bizEl.textContent    = req.bizName || req.biz || '';
    if(riskEl)   riskEl.textContent   = (req.riskReasons && req.riskReasons.length) ? req.riskReasons.join(' / ') : '위험 사유 정보 없음';
    if(sqlEl)    sqlEl.value          = req.sql || '';

    const reasonEl    = backdrop.querySelector('#apReqReason');
    const approverEl  = backdrop.querySelector('#apReqApprover');
    const ticketEl    = backdrop.querySelector('#apReqTicket');
    const execCountEl = backdrop.querySelector('#apReqExecCount');
    const validFromEl = backdrop.querySelector('#apReqValidFrom');
    const validToEl   = backdrop.querySelector('#apReqValidTo');

    if(reasonEl)    reasonEl.value    = req.reason || '';
    if(approverEl)  approverEl.value  = req.approver || '';
    if(ticketEl)    ticketEl.value    = req.itsmNo || '';
    if(execCountEl) execCountEl.value = String(req.requestedExecCount || req.allowedExecCount || 1);
    if(validFromEl) validFromEl.value = req.validFrom || '';
    if(validToEl)   validToEl.value   = req.validTo || '';

    backdrop.classList.remove('hidden');
    backdrop.classList.add('show');
    backdrop.setAttribute('aria-hidden','false');
  },

  closeRequestModal(){
    const backdrop = document.getElementById('approvalRequestBackdrop');
    if(!backdrop) return;
    backdrop.classList.remove('show');
    backdrop.classList.add('hidden');
    backdrop.setAttribute('aria-hidden','true');
    this.currentDraft = null;
  },

  submitCurrentRequest(){

    const req = this.currentDraft;
    const backdrop = document.getElementById('approvalRequestBackdrop');
    if(!req || !backdrop){ return; }

    // 결재선 미리보기 HTML을 함께 저장 (상세 모달에서 재사용)
    const outerLine = backdrop.querySelector('#apReqApprovalPreviewLine');
    const outerRef  = backdrop.querySelector('#apReqApprovalPreviewRef');
    req.approvalLineHtml = outerLine ? outerLine.innerHTML : '';
    req.approvalRefHtml  = outerRef  ? outerRef.innerHTML  : '';

    const reasonEl    = backdrop.querySelector('#apReqReason');
    const approverEl  = backdrop.querySelector('#apReqApprover');
    const ticketEl    = backdrop.querySelector('#apReqTicket');
    const execCountEl = backdrop.querySelector('#apReqExecCount');
    const validFromEl = backdrop.querySelector('#apReqValidFrom');
    const validToEl   = backdrop.querySelector('#apReqValidTo');

    const reason    = reasonEl   ? reasonEl.value.trim()   : '';
    const approver  = approverEl ? approverEl.value.trim() : '';
    const ticket    = ticketEl   ? ticketEl.value.trim()   : '';
    const execCount = execCountEl ? (parseInt(execCountEl.value,10) || 1) : 1;
    const validFrom = validFromEl ? validFromEl.value : '';
    const validTo   = validToEl   ? validToEl.value   : '';

    if(!reason){
      alert('사유를 입력하세요.');
      if(reasonEl) reasonEl.focus();
      return;
    }
    if(execCount <= 0){
      alert('허용 실행 횟수는 1회 이상이어야 합니다.');
      if(execCountEl) execCountEl.focus();
      return;
    }
    if(validFrom && validTo){
      try{
        const fromTs = Date.parse(validFrom);
        const toTs   = Date.parse(validTo);
        if(!isNaN(fromTs) && !isNaN(toTs) && toTs < fromTs){
          alert('유효 종료일시는 시작일시 이후로 설정하세요.');
          if(validToEl) validToEl.focus();
          return;
        }
      }catch(e){}
    }

    // 3단계: 결재선 구조 보정 및 필수 체크
    const steps = Array.isArray(req.approvalSteps) ? req.approvalSteps : [];
    const approvalSteps = steps.filter(function(step){
      return step && (step.type || 'approval') === 'approval';
    });

    if(approvalSteps.length === 0){
      alert('결재선을 지정해 주세요. (최소 1명의 승인자를 추가해야 합니다.)');
      return;
    }

    // 단계 상태 초기화
    steps.forEach(function(step){
      if(!step) return;
      const t = step.type || 'approval';
      if(t === 'approval'){
        step.status = 'PENDING';
      }else{
        step.status = step.status || 'NONE';
      }
      step.decidedAt = null;
    });

    // currentStepIndex 재계산
    let firstIdx = null;
    for(let i=0;i<steps.length;i++){
      const s = steps[i];
      if(s && (s.type || 'approval') === 'approval'){
        firstIdx = i;
        break;
      }
    }
    req.currentStepIndex = (firstIdx !== null ? firstIdx : null);

    // 나머지 필드 세팅
    req.reason          = reason;
    req.approver        = approver;
    req.approverLabel   = approver;
    req.itsmNo          = ticket;
    req.requestedExecCount = execCount;
    req.allowedExecCount   = execCount;
    req.validFrom       = validFrom || null;
    req.validTo         = validTo   || null;
    req.status          = 'REQUESTED';
    req.requestedAt     = new Date();

    this.requests.unshift(req);
    this.currentDraft = null;
    this.closeRequestModal();
    this.renderList();

    if(typeof bottomTabs !== 'undefined' && bottomTabs.activate){
      bottomTabs.activate('approvalPanel');
    }
    if(typeof ui !== 'undefined' && ui.setExecMeta){
      ui.setExecMeta('승인 대기 중인 쿼리로 등록되었습니다.');
    }
  },

  applyFilter(kind){
    this.currentFilter = kind || 'all';
    this.renderList();
  },

  applyTypeFilter(kind){
    this.currentTypeFilter = kind || 'all';
    this.renderList();
  },

  applyPeriod(kind){
    this.currentPeriod = kind || '30d';
    this.renderList();
  },

  refresh(){
    this.renderList();
  },

  renderList(){
    const tbody = document.querySelector('#approvalGrid tbody');
    if(!tbody) return;

    const me = this._currentUser();
    const filter = this.currentFilter || 'all';
    const period = this.currentPeriod || '30d';
    const typeFilter = this.currentTypeFilter || 'all';

    // 쿼리 결재함 탭 배지: 내가 승인해야 할 건수 표시
    try{
      const badgeEl = document.getElementById('approvalTodoBadge');
      if(badgeEl){
        const reqs = Array.isArray(this.requests) ? this.requests : [];
        const todoCount = reqs.filter(r => r && r.status === 'REQUESTED' && this._canCurrentUserApprove(r)).length;
        if(todoCount > 0){
          badgeEl.textContent = String(todoCount);
          badgeEl.style.display = 'flex';
        }else{
          badgeEl.style.display = 'none';
        }
      }
    }catch(e){
      console.warn('update approval todo badge error', e);
    }

    let list = this.requests.slice();

    // 1) 역할/상태 기준 필터
    if(filter === 'mine'){
      // 내가 요청한 쿼리
      list = list.filter(r => r.requester === me);
    }else if(filter === 'todo'){
      // 내가 승인해야 할 쿼리 (다단계 결재 기준 현재 차수의 승인자)
      list = list.filter(r => this._canCurrentUserApprove(r));
    }else if(filter === 'approvedByMe'){
      // 내가 승인한 쿼리
      //  - 최종 승인/실행 완료 건 (req.approver 기준)
      //  - 다단계 결재 중 내가 한 차수라도 승인한 건 (step.approverSessionId 기준)
      list = list.filter(r => {
        // 1) 최종 승인/실행 완료 건
        if(r.approver && r.approver === me && (r.status === 'APPROVED' || r.status === 'EXECUTED')){
          return true;
        }
        // 2) 다단계 결재: 어떤 승인 단계든 내가 승인한 기록이 있는지
        if(Array.isArray(r.approvalSteps) && r.approvalSteps.length > 0){
          return r.approvalSteps.some(function(step){
            if(!step) return false;
            const type = step.type || 'approval';
            const st   = step.status || 'PENDING';
            return type === 'approval' &&
                   st === 'APPROVED' &&
                   step.approverSessionId === me;
          });
        }
        return false;
      });
    }else if(filter === 'rejectedByMe'){
      // 내가 반려한 쿼리
      list = list.filter(r => r.approver && r.approver === me && r.status === 'REJECTED');
    }else if(filter === 'refByMe'){
      // 내가 참조확인한 쿼리 (참조 단계의 status가 CONFIRMED이고, 나의 empId로 기록된 경우)
      list = list.filter(r => {
        if(!Array.isArray(r.approvalSteps) || r.approvalSteps.length === 0) return false;
        return r.approvalSteps.some(function(step){
          if(!step) return false;
          const type = step.type || 'approval';
          const st   = step.status || 'NONE';
          return type === 'ref' &&
                 st === 'CONFIRMED' &&
                 step.approverSessionId === me;
        });
      });
    }else if(filter === 'completed'){
      // 완료된 쿼리 (승인/반려/실행)
      list = list.filter(r => r.status === 'APPROVED' || r.status === 'REJECTED' || r.status === 'EXECUTED');
    }


    // 1-b) 유형(SQL/엑셀) 기준 필터
    if(typeFilter === 'excel'){
      list = list.filter(function(r){
        if(!r) return false;
        const t = r.approvalType || r.type || 'SQL_EXECUTE';
        return t === 'EXCEL_EXPORT';
      });
    }else if(typeFilter === 'sql'){
      list = list.filter(function(r){
        if(!r) return false;
        const t = r.approvalType || r.type || 'SQL_EXECUTE';
        return t !== 'EXCEL_EXPORT';
      });
    }

    // 2) 기간 필터: 승인할 쿼리(todo)는 기간 제한 없이 전체 조회
    if(filter !== 'todo' && period && period !== 'all'){
      const nowTs = Date.now();
      let days = 0;
      if(period.endsWith('d')){
        const n = parseInt(period.slice(0, -1), 10);
        if(!isNaN(n) && n > 0) days = n;
      }
      if(days > 0){
        const fromTs = nowTs - days * 24 * 60 * 60 * 1000;
        list = list.filter(r => {
          if(!r.requestedAt) return true;
          const t = Date.parse(r.requestedAt);
          if(isNaN(t)) return true;
          return t >= fromTs;
        });
      }
    }

    tbody.innerHTML = '';
    if(!list.length){
      const tr = document.createElement('tr');
      const td = document.createElement('td');
      td.colSpan = 9;
      td.style.textAlign = 'center';
      td.style.padding = '8px';
      td.style.color = '#6b7280';
      td.textContent = '아직 등록된 결재 요청이 없습니다.';
      tr.appendChild(td);
      tbody.appendChild(tr);
      return;
    }

    list.forEach(req => {
      const tr = document.createElement('tr');
      tr.dataset.reqId = req.id;
      tr.style.cursor = 'pointer';
      tr.addEventListener('click', () => {
        approvalCenter.openDetail(req.id);
      });

      function td(text){
        const cell = document.createElement('td');
        cell.textContent = text;
        cell.style.textAlign = 'center';
        return cell;
      }

      // 유형 컬럼: SQL / 엑셀(EXCEL_EXPORT) 구분 아이콘
      const typeTd = document.createElement('td');
      const type = req.approvalType || req.type || 'SQL_EXECUTE';
      let typeHtml = '';
      if(type === 'EXCEL_EXPORT'){
        typeHtml =
          '<span style="display:inline-flex;align-items:center;gap:4px;font-size:11px;padding:2px 6px;border-radius:9999px;background:#ecfdf5;color:#166534;">' +
          '<i class="fa-solid fa-file-excel"></i>' +
          '<span>엑셀</span>' +
          '</span>';
      }else{
        typeHtml =
          '<span style="display:inline-flex;align-items:center;gap:4px;font-size:11px;padding:2px 6px;border-radius:9999px;background:#eff6ff;color:#1d4ed8;">' +
          '<i class="fa-solid fa-database"></i>' +
          '<span>SQL</span>' +
          '</span>';
      }
      typeTd.innerHTML = typeHtml;
      typeTd.style.textAlign = 'center';

      const statusTd = document.createElement('td');
      statusTd.innerHTML = this._statusBadgeHtml(req.status);
      statusTd.style.textAlign = 'center';

      const requesterTd = td(req.requesterLabel || req.requester || '');

      // 진행 중(REQUESTED)인 건은 현재 승인자만 표시,
      // 최종 완료(승인/반려/실행완료 등)된 건은 기존 approverLabel 전체를 그대로 사용
      let approverLabelForList = req.approverLabel || req.approver || '';

      if(req.status === 'REQUESTED' &&
         Array.isArray(req.approvalSteps) && req.approvalSteps.length > 0){
        const steps = req.approvalSteps;
        let currentStep = null;

        if(typeof req.currentStepIndex === 'number' &&
           req.currentStepIndex >= 0 &&
           req.currentStepIndex < steps.length){
          currentStep = steps[req.currentStepIndex];
        }

        let currentApprovals = [];

        // currentStep이 승인 단계인 경우: 해당 단계만 현재 승인자로 본다.
        if(currentStep && (currentStep.type || 'approval') === 'approval'){
          currentApprovals = [currentStep];
        }else{
          // currentStep이 없거나 approval 타입이 아닌 경우: PENDING 상태의 승인 단계 중 첫 번째를 fallback으로 사용
          currentApprovals = steps.filter(function(step){
            if(!step) return false;
            const type = step.type || 'approval';
            const st   = step.status || 'PENDING';
            return type === 'approval' && st === 'PENDING';
          }).slice(0,1);
        }

        if(currentApprovals.length){
          const names = currentApprovals.map(function(s){
            let baseName = (s.name || '').replace(/\s*\(대결\)\s*$/, '');
            const title  = s.title || '';
            const isDelegate = s.isDelegate === 'Y';
            const originalName  = (s.originalName || '').replace(/\s*\(대결\)\s*$/, '');
            const originalTitle = s.originalTitle || '';
            let label = baseName || '';

            if(title){
              label = label ? (label + ' ' + title) : title;
            }

            if(isDelegate){
              let suffix = ' (대결';
              if(originalName){
                suffix += ', 원결재자: ' + originalName;
                if(originalTitle){
                  suffix += ' ' + originalTitle;
                }
              }
              suffix += ')';
              label += suffix;
            }

            return label;
          }).filter(Boolean);

          if(names.length){
            // 현재 승인자 이름(직급 포함)을 리스트에 표시
            approverLabelForList = names.join(', ');
          }
        }
      }

      // 진행 중이 아닌 건에서도 대결 승인자가 있는 경우 리스트에서 식별 가능하도록 표시
      if(req.status !== 'REQUESTED' &&
         Array.isArray(req.approvalSteps) && req.approvalSteps.length > 0){
        const approvals = req.approvalSteps.filter(function(step){
          return step && (step.type || 'approval') === 'approval';
        });

        const delegates = approvals.filter(function(step){
          return step.isDelegate === 'Y';
        });

        if(delegates.length > 0){
          const step = delegates[delegates.length - 1];

          let baseName = (step.name || '').replace(/\s*\(대결\)\s*$/, '');
          const title  = step.title || '';
          let label = baseName || '';

          if(title){
            label = label ? (label + ' ' + title) : title;
          }

          const originalName  = (step.originalName || '').replace(/\s*\(대결\)\s*$/, '');
          const originalTitle = step.originalTitle || '';

          let suffix = ' (대결';
          if(originalName){
            suffix += ', 원결재자: ' + originalName;
            if(originalTitle){
              suffix += ' ' + originalTitle;
            }
          }
          suffix += ')';

          approverLabelForList = label + suffix;
        }
      }

      const approverTd  = td(approverLabelForList);
      const reasonTd    = td(req.reason || '');

      let execCountLabel = '';
      if(typeof req.allowedExecCount === 'number'){
        execCountLabel = String(req.allowedExecCount);
      }else if(typeof req.requestedExecCount === 'number'){
        execCountLabel = String(req.requestedExecCount);
      }
      if(execCountLabel){
        execCountLabel += '회';
      }
      const execCountTd = td(execCountLabel);

      let validLabel = '';
      if(req.validFrom || req.validTo){
        const from = req.validFrom || '';
        const to   = req.validTo   || '';
        if(from && to){
          validLabel = from + ' ~ ' + to;
        }else if(from){
          validLabel = from + ' ~';
        }else if(to){
          validLabel = '~ ' + to;
        }
      }
      const validTd = td(validLabel);

      const tsLabel = req.requestedAt ? this._nowLabel(req.requestedAt) : '';
      const timeTd  = td(tsLabel);

      // 사용 실행횟수: usedExecCount
      let usedExecLabel = '';
      if(typeof req.usedExecCount === 'number'){
        usedExecLabel = String(req.usedExecCount) + '회';
      }
      const usedExecTd = td(usedExecLabel);

      // 정렬: 컬럼/데이터는 가운데 정렬, 승인요청사유(reasonTd)만 좌측 정렬
      reasonTd.style.textAlign = 'left';

      tr.appendChild(typeTd);
      tr.appendChild(statusTd);
      tr.appendChild(requesterTd);
      tr.appendChild(approverTd);
      tr.appendChild(reasonTd);
      tr.appendChild(execCountTd);
      tr.appendChild(usedExecTd);
      tr.appendChild(validTd);
      tr.appendChild(timeTd);

      tbody.appendChild(tr);
    });
  },

  openDetail(id){
    const req = this.requests.find(r => r.id === id);
    if(!req) return;

    this.currentDetailId = id;
    const backdrop = document.getElementById('approvalDetailBackdrop');
    if(!backdrop){
      alert('결재 상세 모달 DOM을 찾지 못했습니다.');
      return;
    }

    const type = req.approvalType || req.type || 'SQL_EXECUTE';

    const titleSpan   = backdrop.querySelector('[data-role="apDetailTitleText"]');
    const statusEl    = backdrop.querySelector('[data-field="status"]');
    const connEl      = backdrop.querySelector('[data-field="connLabel"]');
    const schemaEl    = backdrop.querySelector('[data-field="schemaName"]');
    const reqUserEl   = backdrop.querySelector('[data-field="requester"]');
    const bizEl       = backdrop.querySelector('[data-field="bizName"]');
    const appUserEl   = backdrop.querySelector('[data-field="approver"]');
    const riskEl      = backdrop.querySelector('[data-field="riskReasons"]');
    const reasonEl    = backdrop.querySelector('[data-field="requestReason"]');
    const rejectEl    = backdrop.querySelector('[data-field="rejectReason"]');
    const rejectRow   = backdrop.querySelector('#apDetailRejectRow');
    const metaEl      = backdrop.querySelector('[data-field="meta"]');
    const sqlEl       = backdrop.querySelector('#apDetailSql');
    const sqlLabelEl  = backdrop.querySelector('#apDetailSqlLabel');
    const execInfoEl  = backdrop.querySelector('[data-field="execInfo"]');
    const validRangeEl = backdrop.querySelector('#apDetailValidRange');

    const detailLineEl = backdrop.querySelector('#apDetailApprovalLine');
    const detailRefEl  = backdrop.querySelector('#apDetailApprovalRef');
    const detailBoxEl  = backdrop.querySelector('#apDetailApprovalBox');

    const reasonLabelEl    = backdrop.querySelector('[data-role="apDetailReasonLabel"]');
    const execCountLabelEl = backdrop.querySelector('[data-role="apDetailExecCountLabel"]');

    // 타입에 따라 타이틀/라벨 문구 변경
    if(type === 'EXCEL_EXPORT'){
      if(titleSpan) titleSpan.textContent = '엑셀 다운로드 결재 상세';
      if(reasonLabelEl){
        reasonLabelEl.textContent = '엑셀 내보내기 사유';
      }
      if(execCountLabelEl){
        // 라벨 첫 텍스트 노드만 교체
        const txtNodes = Array.from(execCountLabelEl.childNodes).filter(function(n){ return n.nodeType === Node.TEXT_NODE; });
        if(txtNodes.length){
          txtNodes[0].textContent = '허용 다운로드 횟수';
        }
      }
    }else{
      if(titleSpan) titleSpan.textContent = '쿼리 결재 상세';
      if(reasonLabelEl){
        reasonLabelEl.textContent = '승인 요청 사유';
      }
      if(execCountLabelEl){
        const txtNodes = Array.from(execCountLabelEl.childNodes).filter(function(n){ return n.nodeType === Node.TEXT_NODE; });
        if(txtNodes.length){
          txtNodes[0].textContent = '허용 실행 횟수';
        }
      }
    }

    if(statusEl) statusEl.innerHTML = this._statusBadgeHtml(req.status);
    if(connEl)   connEl.textContent = req.connLabel || req.connId || '';
    if(schemaEl) schemaEl.textContent = req.schemaName || '';
    if(reqUserEl) reqUserEl.textContent = req.requesterLabel || req.requester || '';
    if(bizEl)    bizEl.textContent  = req.bizName || req.biz || '';

    // 승인자 요약: 대결 여부를 반영해서 상단 텍스트에 표시
    if(appUserEl){
      let approverText = '';

      if(Array.isArray(req.approvalSteps) && req.approvalSteps.length > 0){
        const approvals = req.approvalSteps.filter(function(step){
          return step && (step.type || 'approval') === 'approval';
        });

        if(approvals.length > 0){
          // 1) 대결 승인자가 있는 경우: 가장 마지막(차수 높은) 대결 승인자 기준으로 표시
          const delegates = approvals.filter(function(step){
            return step.isDelegate === 'Y';
          });

          if(delegates.length > 0){
            const step = delegates[delegates.length - 1];

            // 기본 이름에서 "(대결)" 꼬리표가 이미 붙어있다면 제거
            let baseName = (step.name || '').replace(/\s*\(대결\)\s*$/, '');
            const title  = step.title || '';
            let label = baseName || '';

            if(title){
              label = label ? (label + ' ' + title) : title;
            }

            const originalName  = (step.originalName  || '').replace(/\s*\(대결\)\s*$/, '');
            const originalTitle = step.originalTitle || '';

            let suffix = ' (대결';
            if(originalName){
              suffix += ', 원결재자: ' + originalName;
              if(originalTitle){
                suffix += ' ' + originalTitle;
              }
            }
            suffix += ')';

            approverText = label + suffix;
          }else{
            // 2) 대결이 없는 경우: 승인 라인 이름들을 단순 나열
            const names = approvals.map(function(step){
              const n = step.name || '';
              const t = step.title || '';
              return t ? (n + ' ' + t) : n;
            }).filter(Boolean);
            approverText = names.join(', ');
          }
        }
      }

      appUserEl.textContent = approverText;
    }

    if(riskEl)  riskEl.textContent  = (req.riskReasons && req.riskReasons.length) ? req.riskReasons.join(' / ') : '위험 사유 정보 없음';
    if(reasonEl) reasonEl.textContent = req.reason || '';
    if(rejectEl) rejectEl.textContent = req.rejectReason || '';
    if(rejectRow && rejectEl){
      if(req.status === 'REJECTED'){
        rejectRow.style.display = '';
        rejectEl.style.display = '';
      }else{
        rejectRow.style.display = 'none';
        rejectEl.style.display = 'none';
        rejectEl.textContent = '';
      }
    }

    // 결재선 미리보기 (상세 모달)
    if(detailLineEl){
      detailLineEl.innerHTML = req.approvalLineHtml || '';
      this._decorateApprovalLineWithTime(detailLineEl, req);
    }
    if(detailRefEl){
      detailRefEl.innerHTML = req.approvalRefHtml || '';

      // 참조자 확인 여부에 따라 체크 아이콘 + 참조확인 시각 표시
      if(Array.isArray(req.approvalSteps) && req.approvalSteps.length > 0){
        const refSteps = req.approvalSteps.filter(function(step){
          return step && (step.type || 'approval') === 'ref';
        });
        const chips = detailRefEl.querySelectorAll('.ap-ref-chip');
        chips.forEach((chip, idx) => {
          const step = refSteps[idx] || null;
          if(!step) return;
          if(step.status === 'CONFIRMED'){
            chip.classList.add('confirmed');
            const tsSpan = document.createElement('span');
            tsSpan.className = 'ref-confirm-ts';
            tsSpan.textContent = step.confirmedAt ? (' (' + approvalCenter._nowLabel(step.confirmedAt) + ')') : '';
            chip.appendChild(tsSpan);
          }else{
            chip.classList.remove('confirmed');
          }
        });
      }
    }
    if(detailBoxEl){
      const hasLine = req.approvalLineHtml && String(req.approvalLineHtml).trim() !== '';
      const hasRef  = req.approvalRefHtml && String(req.approvalRefHtml).trim() !== '';
      detailBoxEl.style.display = (hasLine || hasRef) ? '' : 'none';
    }

    const metaParts = [];
    if(req.itsmNo){ metaParts.push('ITSM/작업요청: ' + req.itsmNo); }
    if(req.requestedAt){ metaParts.push('요청시각: ' + this._nowLabel(req.requestedAt)); }
    if(req.approvedAt){ metaParts.push('승인시각: ' + this._nowLabel(req.approvedAt)); }
    if(req.rejectedAt){ metaParts.push('반려시각: ' + this._nowLabel(req.rejectedAt)); }
    if(req.executedAt){ metaParts.push('실행시각: ' + this._nowLabel(req.executedAt)); }
    if(metaEl) metaEl.textContent = metaParts.join('  |  ');

    if(sqlEl) sqlEl.value = req.sql || '';

    // SQL 라벨: 승인 전에는 "요청된 쿼리", 승인/실행 후에는 "승인된 쿼리"
    if(sqlLabelEl){
      if(req.status === 'APPROVED' || req.status === 'EXECUTED'){
        sqlLabelEl.textContent = '승인된 쿼리';
      }else{
        sqlLabelEl.textContent = '요청된 쿼리';
      }
    }

    if(execInfoEl){
      const pieces = [];
      if(typeof req.allowedExecCount === 'number'){
        pieces.push('허용 ' + req.allowedExecCount + '회');
      }
      if(typeof req.usedExecCount === 'number'){
        pieces.push('사용 ' + req.usedExecCount + '회');
      }
      if(pieces.length){
        execInfoEl.textContent = pieces.join(' / ');
      }else{
        execInfoEl.textContent = '';
      }
    }

    // 유효 기간 표시 (텍스트)
    if(validRangeEl){
      const from = req.validFrom || '';
      const to   = req.validTo   || '';
      let label = '';
      if(from || to){
        if(from && to){
          label = '유효 기간: ' + from + ' ~ ' + to;
        }else if(from){
          label = '유효 기간: ' + from + ' ~';
        }else{
          label = '유효 기간: ~ ' + to;
        }
      }else{
        label = '유효 기간: -';
      }
      validRangeEl.textContent = label;
    }

    const approveBtn    = backdrop.querySelector('#apDetailApprove');
    const rejectBtn     = backdrop.querySelector('#apDetailReject');
    const refConfirmBtn = backdrop.querySelector('#apDetailRefConfirm');
    const execBtn       = backdrop.querySelector('#apDetailExecute');
    const excelBtn      = backdrop.querySelector('#apDetailExcelDownload');
    const execCountSel  = backdrop.querySelector('#apDetailExecCount');

    // SQL 실행/엑셀 다운로드/허용 횟수는 승인자만 변경 가능
    const me = this._currentUser();
    let canApprove = this._canCurrentUserApprove(req);
    let hasPendingRefForMe = false;

    if(Array.isArray(req.approvalSteps) && req.approvalSteps.length > 0){
      const steps = req.approvalSteps;

      // 참조자 중 내가 아직 확인하지 않은 건이 있는지 체크
      steps.forEach(function(step){
        if(!step) return;
        if((step.type || 'approval') !== 'ref') return;
        if(step.empId && step.empId === me && step.status !== 'CONFIRMED'){
          hasPendingRefForMe = true;
        }
      });
    }

    // 허용 실행/다운로드 횟수 셀렉트 값 적용 (승인자만 수정 가능)
    if(execCountSel){
      if(typeof req.allowedExecCount === 'number'){
        execCountSel.value = String(req.allowedExecCount);
      }else if(typeof req.requestedExecCount === 'number'){
        execCountSel.value = String(req.requestedExecCount);
      }else{
        execCountSel.value = '1';
      }
      execCountSel.disabled = !canApprove;
    }

    // 현재 차수 승인자가 아닌 경우 승인/반려 버튼 숨김
    if(approveBtn) approveBtn.style.display = (req.status === 'REQUESTED' && canApprove) ? '' : 'none';
    if(rejectBtn)  rejectBtn.style.display  = (req.status === 'REQUESTED' && canApprove) ? '' : 'none';

    // 참조자는 결재 순서와 무관하게 참조확인 버튼 노출 (아직 확인하지 않은 경우)
    if(refConfirmBtn) refConfirmBtn.style.display = hasPendingRefForMe ? '' : 'none';

    if(execBtn || excelBtn){
      const isRequester = (req.requester === this._currentUser());

      let canExec = isRequester && (req.status === 'APPROVED' || req.status === 'EXECUTED') && type !== 'EXCEL_EXPORT';

      // 허용 실행횟수 모두 사용한 경우 실행 버튼 숨김
      if(canExec && typeof req.allowedExecCount === 'number' && typeof req.usedExecCount === 'number' && req.usedExecCount >= req.allowedExecCount){
        canExec = false;
      }

      // 유효 기간이 설정되어 있고, 현재 시간이 범위를 벗어나면 실행 버튼 숨김
      if(canExec && (req.validFrom || req.validTo)){
        const nowTs = Date.now();
        try{
          if(req.validFrom){
            const fromTs = Date.parse(req.validFrom);
            if(!isNaN(fromTs) && nowTs < fromTs){
              canExec = false;
            }
          }
          if(req.validTo){
            const toTs = Date.parse(req.validTo);
            if(!isNaN(toTs) && nowTs > toTs){
              canExec = false;
            }
          }
        }catch(e){}
      }

      if(execBtn){
        execBtn.style.display = canExec ? '' : 'none';
      }

      // EXCEL_EXPORT: 엑셀 다운로드 버튼 노출 조건은 onClickExportExcel / downloadExcelForCurrent와 동일
      if(excelBtn){
        let canExcel = (type === 'EXCEL_EXPORT') && isRequester && (req.status === 'APPROVED' || req.status === 'EXECUTED');

        // 허용 다운로드 횟수 모두 사용한 경우 버튼 숨김
        if(canExcel && typeof req.allowedExecCount === 'number' && typeof req.usedExecCount === 'number' && req.usedExecCount >= req.allowedExecCount){
          canExcel = false;
        }

        // 유효 기간이 설정되어 있고, 현재 시간이 범위를 벗어나면 버튼 숨김
        if(canExcel && (req.validFrom || req.validTo)){
          const nowTs2 = Date.now();
          try{
            if(req.validFrom){
              const fromTs2 = Date.parse(req.validFrom);
              if(!isNaN(fromTs2) && nowTs2 < fromTs2){
                canExcel = false;
              }
            }
            if(req.validTo){
              const toTs2 = Date.parse(req.validTo);
              if(!isNaN(toTs2) && nowTs2 > toTs2){
                canExcel = false;
              }
            }
          }catch(e){}
        }

        excelBtn.style.display = canExcel ? '' : 'none';
      }
    }

    backdrop.classList.remove('hidden');
    backdrop.classList.add('show');
    backdrop.setAttribute('aria-hidden','false');
  },

  closeDetailModal(){
    const backdrop = document.getElementById('approvalDetailBackdrop');
    if(!backdrop) return;
    backdrop.classList.remove('show');
    backdrop.classList.add('hidden');
    backdrop.setAttribute('aria-hidden','true');
    this.currentDetailId = null;
  },

  approveCurrent(){
    const id = this.currentDetailId;
    const req = this.requests.find(r => r.id === id);
    if(!req) return;
    if(req.status !== 'REQUESTED'){
      alert('이미 처리된 건입니다.');
      return;
    }
    // 다단계 결재: 현재 차수의 승인자가 아닌 경우 승인 불가
    if(!this._canCurrentUserApprove(req)){
      alert('현재 결재 차수의 승인자가 아니어서 승인할 수 없습니다.');
      return;
    }

    const backdrop = document.getElementById('approvalDetailBackdrop');
    const execCountSel = backdrop ? backdrop.querySelector('#apDetailExecCount') : null;
    const allowed = execCountSel ? (parseInt(execCountSel.value,10) || 1) : 1;

    // 1) 결재선 정보가 없는 경우: 기존 단일 단계 승인 로직 (호환용)
    if(!Array.isArray(req.approvalSteps) || req.approvalSteps.length === 0 || typeof req.currentStepIndex !== 'number'){
      req.status = 'APPROVED';
      req.allowedExecCount = allowed;
      req.usedExecCount = req.usedExecCount || 0;
      req.approvedAt = new Date();
      req.approver = this._currentUser();
      req.approverLabel = this._currentUserLabel();
      this.renderList();
    this.closeDetailModal();
      return;
    }

    const steps = req.approvalSteps;
    const idx = req.currentStepIndex;
    if(idx < 0 || idx >= steps.length){
      alert('현재 결재 차수 정보를 찾을 수 없습니다.');
      return;
    }

    const step = steps[idx];
    if(!step || (step.type || 'approval') !== 'approval'){
      alert('현재 결재 차수의 정보가 올바르지 않습니다.');
      return;
    }

    const now = new Date();

    // 현재 차수 승인 처리
    step.status = 'APPROVED';
    step.decidedAt = now;
    step.approverSessionId = this._currentUser();
    step.approverLabel = this._currentUserLabel();

    // 실행 허용 횟수는 전체 건 단위이므로 여기서 갱신
    req.allowedExecCount = allowed;
    req.usedExecCount = req.usedExecCount || 0;

    // 2) 다음 승인 차수 찾기
    let nextIdx = null;
    for(let i = idx + 1; i < steps.length; i++){
      const s = steps[i];
      if(s && (s.type || 'approval') === 'approval'){
        nextIdx = i;
        break;
      }
    }

    if(nextIdx !== null){
      // 아직 남은 승인자가 있는 경우: 상태는 계속 REQUESTED, currentStepIndex만 다음으로 이동
      req.currentStepIndex = nextIdx;
      // 전체 상태는 '승인 대기'를 유지 (여전히 결재 진행 중)
      req.status = 'REQUESTED';
    }else{
      // 마지막 승인자까지 모두 승인한 경우: 최종 승인 처리
      req.currentStepIndex = null;
      req.status = 'APPROVED';
      req.approvedAt = now;
      req.approver = this._currentUser();
      req.approverLabel = this._currentUserLabel();
    }

    this.renderList();
    this.closeDetailModal();
  },

  rejectCurrent(){
    const id = this.currentDetailId;
    const req = this.requests.find(r => r.id === id);
    if(!req) return;
    if(req.status !== 'REQUESTED'){
      alert('이미 처리된 건입니다.');
      return;
    }
    // 다단계 결재: 현재 차수의 승인자가 아닌 경우 반려 불가
    if(!this._canCurrentUserApprove(req)){
      alert('현재 결재 차수의 승인자가 아니어서 반려할 수 없습니다.');
      return;
    }
    const reason = window.prompt('반려 사유를 입력하세요.', '');
    if(reason === null) return;

    const now = new Date();

    // 1) 결재선 정보가 없는 경우: 기존 단일 단계 반려 로직 (호환용)
    if(!Array.isArray(req.approvalSteps) || req.approvalSteps.length === 0 || typeof req.currentStepIndex !== 'number'){
      req.status = 'REJECTED';
      req.rejectReason = reason;
      req.rejectedAt = now;
      req.approver = this._currentUser();
      req.approverLabel = this._currentUserLabel();
      this.renderList();
    this.closeDetailModal();
      return;
    }

    const steps = req.approvalSteps;
    const idx = req.currentStepIndex;
    if(idx < 0 || idx >= steps.length){
      alert('현재 결재 차수 정보를 찾을 수 없습니다.');
      return;
    }

    const step = steps[idx];
    if(!step || (step.type || 'approval') !== 'approval'){
      alert('현재 결재 차수의 정보가 올바르지 않습니다.');
      return;
    }

    // 현재 차수 반려 처리
    step.status = 'REJECTED';
    step.decidedAt = now;
    step.approverSessionId = this._currentUser();
    step.approverLabel = this._currentUserLabel();

    // 전체 건은 즉시 반려 완료
    req.status = 'REJECTED';
    req.rejectReason = reason;
    req.rejectedAt = now;
    req.currentStepIndex = null;
    req.approver = this._currentUser();
    req.approverLabel = this._currentUserLabel();

    this.renderList();
    this.closeDetailModal();
  },

  confirmRefCurrent(){
    const id = this.currentDetailId;
    const req = this.requests.find(r => r.id === id);
    if(!req) return;

    const me = this._currentUser();
    const label = this._currentUserLabel ? this._currentUserLabel() : '';

    if(!me){
      alert('로그인 정보를 확인할 수 없습니다.');
      return;
    }

    if(!Array.isArray(req.approvalSteps) || req.approvalSteps.length === 0){
      alert('참조 대상이 아닌 결재선입니다.');
      return;
    }

    const now = new Date();
    let updated = false;

    req.approvalSteps.forEach(function(step){
      if(!step) return;
      const type = step.type || 'approval';
      const st   = step.status || 'NONE';
      if(type === 'ref' && step.empId === me && st !== 'CONFIRMED'){
        step.status = 'CONFIRMED';
        step.decidedAt = now;
        step.approverSessionId = me;
        step.approverLabel = label;
        updated = true;
      }
    });

    if(!updated){
      alert('참조 대상이 아니거나 이미 참조 확인한 건입니다.');
      return;
    }

    this.renderList();
    this.closeDetailModal();
  },

  executeCurrent: async function(){
    const id = this.currentDetailId;
    const req = this.requests.find(r => r.id === id);
    if(!req) return;

    // 요청자만 실행 가능
    if(req.requester !== this._currentUser()){
      alert('승인된 쿼리는 요청자만 실행할 수 있습니다.');
      return;
    }

    if(req.status !== 'APPROVED' && req.status !== 'EXECUTED'){
      alert('승인된 건만 실행할 수 있습니다.');
      return;
    }
    if(req.allowedExecCount && typeof req.usedExecCount === 'number' && req.usedExecCount >= req.allowedExecCount){
      alert('허용 실행 횟수를 초과했습니다.');
      return;
    }

    if(!state.connected){
      alert('DB 연결 후 실행하세요.');
      return;
    }
    if(!req.connId || !state.connStates[req.connId]){
      // 실제 서비스에서는 결재 시점의 DB/스키마와 동일하게 다시 연결했는지 검증해야 하지만,
      // 데모 버전에서는 현재 연결 기준으로 계속 진행한다.
      console.warn('결재 시점의 연결 정보(state.connStates)를 찾지 못했습니다. 데모에서는 현재 연결로 계속 진행합니다.');
    }

    try{
      // 실행 가능 횟수 및 유효 기간 검증
      if(req.allowedExecCount && req.usedExecCount >= req.allowedExecCount){
        alert('허용된 실행 횟수를 초과했습니다.');
        return;
      }
      if(req.validFrom || req.validTo){
        const nowTs = Date.now();
        try{
          if(req.validFrom){
            const fromTs = Date.parse(req.validFrom);
            if(!isNaN(fromTs) && nowTs < fromTs){
              alert('아직 유효 기간이 시작되지 않아 실행할 수 없습니다.');
              return;
            }
          }
          if(req.validTo){
            const toTs = Date.parse(req.validTo);
            if(!isNaN(toTs) && nowTs > toTs){
              alert('유효 기간이 경과되어 실행할 수 없습니다.');
              return;
            }
          }
        }catch(e){}
      }

      const result = await actions.runApprovedSql(req.sql, req.connId, { approvalId: req.id });
      if(result && result.ok){
        req.usedExecCount = (req.usedExecCount || 0) + 1;
        req.lastRowCount = result.rowCount;
        req.executedAt = new Date();
        if(!req.allowedExecCount || req.usedExecCount >= req.allowedExecCount){
          req.status = 'EXECUTED';
        }
        this.renderList();
        this.closeDetailModal();
      }
    }catch(e){
      console.error('executeCurrent failed', e);
      alert('승인된 쿼리 실행 중 오류가 발생했습니다.');
    }
  },

  downloadExcelForCurrent: async function(){
    const id = this.currentDetailId;
    const req = this.requests.find(r => r.id === id);
    if(!req) return;

    const type = req.approvalType || req.type || 'SQL_EXECUTE';
    if(type !== 'EXCEL_EXPORT'){
      alert('엑셀 내보내기 요청이 아닙니다.');
      return;
    }

    const me = this._currentUser();
    if(!me){
      alert('로그인 정보를 확인할 수 없습니다.');
      return;
    }
    if(req.requester !== me){
      alert('엑셀 다운로드는 요청자만 실행할 수 있습니다.');
      return;
    }

    if(req.status !== 'APPROVED' && req.status !== 'EXECUTED'){
      alert('승인 완료된 엑셀 내보내기 요청만 다운로드할 수 있습니다.');
      return;
    }

    if(!state.connected){
      alert('DB 연결 후 실행하세요.');
      return;
    }
    if(!req.connId || !state.connStates[req.connId]){
      // TODO: 실제 서비스에서는 결재 시점의 DB/스키마와 동일하게 다시 연결했는지 검증해야 함.
      // 데모/프론트 단독 버전에서는 현재 연결 기준으로 계속 진행한다.
      console.warn('결재 시점의 연결 정보를 찾지 못했습니다. 데모에서는 현재 연결로 계속 진행합니다.', req.connId, state.connStates);
      // return; // 데모에서는 막지 않음
    }

    // 유효 기간이 설정되어 있을 경우, 범위 외에는 다운로드 불가
    if(req.validFrom || req.validTo){
      const nowTs = Date.now();
      try{
        if(req.validFrom){
          const fromTs = Date.parse(req.validFrom);
          if(!isNaN(fromTs) && nowTs < fromTs){
            alert('아직 유효 기간이 시작되지 않아 엑셀을 다운로드할 수 없습니다.');
            return;
          }
        }
        if(req.validTo){
          const toTs = Date.parse(req.validTo);
          if(!isNaN(toTs) && nowTs > toTs){
            alert('유효 기간이 경과되어 엑셀을 다운로드할 수 없습니다.');
            return;
          }
        }
      }catch(e){}
    }

    try{
      // 승인된 쿼리를 한 번 실행하여 state.lastResult를 최신 상태로 만든 뒤,
      // 기존 Excel 감사/반출 모달(actions.exportCsv)을 호출한다.
      const result = await actions.runApprovedSql(req.sql, req.connId, { approvalId: req.id, mode: 'EXCEL_EXPORT' });
      if(result && result.ok){
        req.usedExecCount = (req.usedExecCount || 0) + 1;
        req.lastRowCount = result.rowCount;
        req.executedAt = new Date();
        if(!req.allowedExecCount || req.usedExecCount >= req.allowedExecCount){
          req.status = 'EXECUTED';
        }
        this.renderList();

        // 결재 후 실제 엑셀 내보내기 로그 (approved=true, mode='APPROVAL')
        try{
          const meta2 = getCurrentResultMeta() || {
            sql: req.sql,
            rowCount: result.rowCount,
            tableNames: [],
            userId: req.requester
          };
          logExcelExport(meta2, {
            level: 'HIGH',
            reasons: req.riskReasons || [],
            approved: true,
            approvalId: req.id || null,
            mode: 'APPROVAL'
          });
        }catch(e2){
          console.warn('logExcelExport from downloadExcelForCurrent failed', e2);
        }

        // state.lastResult를 기반으로 결재 사유를 이용해 바로 엑셀 내보내기 수행
        actions.exportCsvFromApproval(req);
        // 결재창(상세 모달) 닫기
        this.closeDetailModal();
      }
    }catch(e){
      console.error('downloadExcelForCurrent failed', e);
      alert('엑셀 내보내기 중 오류가 발생했습니다.');
    }
  }

};
/* -------------------------------------------------------------------- */

/* ---------------- Explain / Plan Analysis (Lightweight) ---------------- */

const planAnalyzer = {
  extractPlanText(result){
    try{
      if(!result || !result.rows || !result.rows.length){ return ''; }
      const cols = result.columns || [];
      let colIndex = 0;
      let colName = cols[0] || null;
      for(let i=0;i<cols.length;i++){
        const c = (cols[i] || '').toString().toUpperCase();
        if(c === 'QUERY PLAN' || c === 'PLAN'){
          colIndex = i;
          colName = cols[i];
          break;
        }
      }
      const lines = result.rows.map(row=>{
        if(Array.isArray(row)){
          return row[colIndex] != null ? String(row[colIndex]) : '';
        }
        if(row && typeof row === 'object'){
          if(colName && Object.prototype.hasOwnProperty.call(row, colName)){
            return row[colName] != null ? String(row[colName]) : '';
          }
          const keys = Object.keys(row);
          if(keys.length){
            const k = keys[0];
            return row[k] != null ? String(row[k]) : '';
          }
        }
        return '';
      }).filter(Boolean);
      return lines.join('\n');
    }catch(e){
      console.warn('planAnalyzer.extractPlanText error', e);
      return '';
    }
  },
  analyze(planText){
    const text = (planText || '').trim();
    const res = {
      risk: 'ok',
      label: '성능 위험 낮음',
      summaryText: '',
      details: [],
      estRows: null,
      actualRows: null,
      costStart: null,
      costEnd: null,
      hasSeqScan: false,
      hasIndexScan: false,
      hasNestedLoop: false
    };
    if(!text){
      res.summaryText = '실행 계획이 없습니다.';
      return res;
    }
    const upper = text.toUpperCase();

    const costMatch = text.match(/cost\s*=\s*([0-9\.]+)\.\.([0-9\.]+)/i);
    if(costMatch){
      res.costStart = parseFloat(costMatch[1]);
      res.costEnd = parseFloat(costMatch[2]);
    }
    const estRowsMatch = text.match(/rows\s*=\s*([0-9]+)/i);
    if(estRowsMatch){
      res.estRows = parseInt(estRowsMatch[1], 10);
    }
    const actRowsMatch = text.match(/actual\s+rows\s*=\s*([0-9]+)/i);
    if(actRowsMatch){
      res.actualRows = parseInt(actRowsMatch[1], 10);
    }

    res.hasSeqScan = /SEQ\s+SCAN/i.test(upper);
    res.hasIndexScan = /INDEX\s+SCAN/i.test(upper) || /BITMAP\s+INDEX\s+SCAN/i.test(upper);
    const hasBitmap = /BITMAP\s+HEAP\s+SCAN/i.test(upper);
    res.hasNestedLoop = /NESTED\s+LOOP/i.test(upper);
    const hasHashJoin = /HASH\s+JOIN/i.test(upper);
    const hasMergeJoin = /MERGE\s+JOIN/i.test(upper);

    let maxRows = 0;
    if(typeof res.estRows === 'number'){ maxRows = Math.max(maxRows, res.estRows); }
    if(typeof res.actualRows === 'number'){ maxRows = Math.max(maxRows, res.actualRows); }
    const bigRows = maxRows >= 100000;

    if(res.hasSeqScan){
      res.details.push('Seq Scan 검출: 전체 테이블 스캔입니다.');
    }
    if(res.hasNestedLoop){
      res.details.push('Nested Loop 조인 사용.');
    }
    if(bigRows){
      res.details.push('예상/실제 Row가 많습니다 (≈ ' + maxRows.toLocaleString('en-US') + ' rows).');
    }
    if(bigRows && !res.hasIndexScan && res.hasSeqScan){
      res.details.push('대량 Row + Seq Scan인데 인덱스 사용 흔적이 없습니다. 인덱스 추가/튜닝을 검토하세요.');
    }
    if(!bigRows && res.hasSeqScan && !res.hasIndexScan){
      res.details.push('현재 계획에서는 Index Scan이 감지되지 않고 Seq Scan 위주입니다. 인덱스 사용 가능 여부를 확인해 보세요.');
    }
    if(res.hasNestedLoop && bigRows){
      res.details.push('Nested Loop + 대량 Row 조합입니다. 조인 전략/인덱스 점검이 필요할 수 있습니다.');
    }

    let riskScore = 0;
    if(res.hasSeqScan) riskScore = Math.max(riskScore, 1);
    if(bigRows && !res.hasIndexScan) riskScore = Math.max(riskScore, 1);
    if(res.hasNestedLoop && bigRows) riskScore = Math.max(riskScore, 2);
    if(bigRows && !res.hasIndexScan && res.hasSeqScan) riskScore = Math.max(riskScore, 2);

    if(riskScore === 0){
      res.risk = 'ok';
      res.label = '성능 위험 낮음';
    }else if(riskScore === 1){
      res.risk = 'warn';
      res.label = '성능 주의 필요';
    }else{
      res.risk = 'danger';
      res.label = '성능 위험 높음';
    }

    const summaryParts = [];
    const rowParts = [];
    if(typeof res.estRows === 'number') rowParts.push('예상 rows≈' + res.estRows);
    if(typeof res.actualRows === 'number') rowParts.push('실제 rows≈' + res.actualRows);
    if(rowParts.length){ summaryParts.push(rowParts.join(', ')); }
    if(res.costStart != null && res.costEnd != null){
      summaryParts.push('cost≈' + res.costStart + '..' + res.costEnd);
    }
    const scanParts = [];
    if(res.hasSeqScan) scanParts.push('Seq Scan');
    if(res.hasIndexScan) scanParts.push('Index Scan');
    if(hasBitmap) scanParts.push('Bitmap Scan');
    if(res.hasNestedLoop) scanParts.push('Nested Loop');
    if(hasHashJoin) scanParts.push('Hash Join');
    if(hasMergeJoin) scanParts.push('Merge Join');
    if(scanParts.length){ summaryParts.push(scanParts.join(' · ')); }

    res.summaryText = summaryParts.join(' · ') || '요약 가능한 정보가 부족합니다.';

    if(res.summaryText){
      res.details.unshift('[요약] ' + res.summaryText);
    }

    if(res.details.length === 0){
      if(res.risk === 'ok'){
        res.details.push('명확한 성능 위험 패턴은 감지되지 않았습니다.');
      }else if(res.risk === 'warn'){
        res.details.push('일부 성능 주의 패턴이 감지되었습니다. 실행 계획을 상세 검토하세요.');
      }else{
        res.details.push('고위험 성능 패턴이 감지되었습니다. 인덱스/쿼리 구조 조정이 필요할 수 있습니다.');
      }
    }else{
      if(res.risk === 'warn'){
        res.details.push('추가 튜닝 여지가 있습니다. 실행 계획과 인덱스를 함께 검토해 보세요.');
      }else if(res.risk === 'danger'){
        res.details.push('실제 서비스에서는 실행 전에 DBA와 상의하는 것이 좋습니다.');
      }
    }

    return res;
  },
  escapeHtml(str){
    return String(str || '')
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;');
  },
  renderFromResult(result){
    const metaEl = document.getElementById('execMeta');
    const msgEl = document.getElementById('messages');
    if(!metaEl || !msgEl) return;

    const planText = this.extractPlanText(result);
    if(!planText.trim()){
      metaEl.textContent = '실행 계획: 분석할 데이터가 없습니다.';
      msgEl.textContent = '';
      return;
    }

    const a = this.analyze(planText);
    let cls = 'plan-summary-badge plan-ok';
    let icon = '<i class="fa-solid fa-circle-check"></i>';
    if(a.risk === 'warn'){
      cls = 'plan-summary-badge plan-warn';
      icon = '<i class="fa-solid fa-triangle-exclamation"></i>';
    }else if(a.risk === 'danger'){
      cls = 'plan-summary-badge plan-danger';
      icon = '<i class="fa-solid fa-fire"></i>';
    }

    const summaryHtml = this.escapeHtml(a.summaryText);
    metaEl.innerHTML = '실행 계획 <span class="' + cls + '">' + icon + '<span>' + summaryHtml + '</span></span>';
    msgEl.textContent = a.details.join('\n');
  },
  renderFromLastResult(){
    this.renderFromResult(state.lastResult || {});
  }
};
// --- SQL 저장 통합 모달 (파일/서버) ---
ui.openSqlSaveModal = function(){
  const el = document.getElementById('personalSqlSaveBackdrop');
  if(!el){
    alert('SQL 저장 UI 요소를 찾지 못했습니다.');
    return;
  }
  const tab = state.tabs.find(function(t){ return t.id === state.activeTabId; }) || null;
  const titleInput = document.getElementById('psSaveTitle');
  const infoSpan = document.getElementById('psSaveInfo');
  const preview = document.getElementById('psSavePreview');

  if(titleInput){
    titleInput.value = (tab && tab.title) ? tab.title : '';
  }
  if(infoSpan){
    infoSpan.textContent = tab ? (tab.title || tab.id) : '(활성 탭 없음)';
  }
  if(preview){
    try{
      const editorEl = document.getElementById('sqlEditor');
      const sql = (typeof cm !== 'undefined' && cm)
        ? cm.getValue()
        : (editorEl ? editorEl.value : '');
      preview.textContent = sql ? sql.slice(0, 800) : '';
    }catch(e){
      preview.textContent = '';
    }
  }

  const radios = document.querySelectorAll('input[name="psSaveTarget"]');
  if(radios && radios.length){
    radios.forEach(function(r){
      r.checked = (r.value === 'server');
    });
  }

  el.classList.remove('hidden');
  el.classList.add('show');
  el.setAttribute('aria-hidden','false');
};

ui.closeSqlSaveModal = function(){
  const el = document.getElementById('personalSqlSaveBackdrop');
  if(!el) return;
  el.classList.remove('show');
  el.classList.add('hidden');
  el.setAttribute('aria-hidden','true');
};

ui.confirmSqlSave = function(){
  const editorEl = document.getElementById('sqlEditor');
  const sql = (typeof cm !== 'undefined' && cm)
    ? cm.getValue()
    : (editorEl ? editorEl.value : '');
  if(!sql || !sql.trim()){
    alert('저장할 SQL이 없습니다.');
    return;
  }

  // 저장 위치 결정 (기본: 서버)
  let target = 'server';
  const radios = document.querySelectorAll('input[name="psSaveTarget"]');
  if(radios && radios.length){
    radios.forEach(function(r){
      if(r.checked) target = r.value;
    });
  }

  const titleInput = document.getElementById('psSaveTitle');
  const baseTitle = (titleInput && titleInput.value) ? titleInput.value.trim() : '';

  if(target === 'file'){
    // 파일로 저장
    let raw = baseTitle;
    if(!raw){
      const tab = state.tabs.find(function(t){ return t.id === state.activeTabId; }) || null;
      raw = (tab && tab.title) ? tab.title : (state.activeTabId || 'sql_tab');
    }
    let safeTitle = raw ? raw.trim().replace(/\s+/g, '_').replace(/[\\/:*?"<>|]/g, '') : 'sql_tab';
    if(!safeTitle){
      safeTitle = 'sql_tab';
    }
    const fileName = safeTitle + '.sql';

    try{
      const blob = new Blob([sql], {type:'text/sql;charset=utf-8;'});
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = fileName;
      document.body.appendChild(a);
      a.click();
      setTimeout(function(){
        URL.revokeObjectURL(a.href);
        a.remove();
      }, 0);
    }catch(e){
      console.warn('SQL 파일 저장 중 오류', e);
      alert('SQL 파일 저장 중 오류가 발생했습니다.');
    }

    ui.closeSqlSaveModal();
    return;
  }

  // 서버 개인 저장소 저장 (기존 confirmPersonalSqlSave 로직 유지)
  const descInput = document.getElementById('psSaveDesc');
  const desc = descInput ? descInput.value : '';
  // TODO: 서버 API 연동 시 baseTitle/desc/sql을 전송하는 로직을 추가
  alert('서버 개인 저장소 연동 전이라 실제 저장은 수행하지 않습니다.\nUI 흐름만 먼저 구현된 상태입니다.');
  ui.closeSqlSaveModal();
};

// 기존 함수명과의 호환 (기존 코드에서 사용 중일 수 있음)
ui.openPersonalSqlSave = function(){ ui.openSqlSaveModal(); };
ui.closePersonalSqlSave = function(){ ui.closeSqlSaveModal(); };
ui.confirmPersonalSqlSave = function(){ ui.confirmSqlSave(); };




/* ---------------- Actions (execute/explain/export) ---------------- */
const actions = {
  async runCurrent(){
    if(!state.connected){ console.warn('DB 연결 후 실행하세요 (데모에서는 계속 진행).'); }
    const sqlInfo = cm ? sqlSplit.selectedOrCurrent(cm) : { sql: ui.getEditor().trim() };
    const sql = (sqlInfo.sql||'').trim(); if(!sql){ return; }
    const tab = state.tabs.find(t=>t.id===state.activeTabId);
    const connId = tab && tab.connId ? tab.connId : null;
    if(!connId || !state.connStates[connId]){
      console.warn('이 탭의 연결을 선택/연결하세요 (데모에서는 계속 진행).', tab, state.connStates);
      // return; // 데모에서는 막지 않음
    }
    if(!security.beforeExecuteSingle(sql, connId)){
      ui.setExecMeta('위험 쿼리 감지 정책에 의해 실행이 취소되었습니다.');
      return;
    }
    if(typeof sessionMonitor!=='undefined' && sessionMonitor.markExecuting){
      sessionMonitor.markExecuting(connId, sql);
    }
    ui.showResult(); ui.setExecMeta('<span class="spin"></span> 실행 중…');
    if (typeof ui !== 'undefined' && typeof ui.beginQueryProgress === 'function') {
      ui.beginQueryProgress();
    }
    const result = await actions._runOne(sql, connId);
    if (typeof ui !== 'undefined' && typeof ui.endQueryProgress === 'function') {
      ui.endQueryProgress();
    }
    if(typeof sessionMonitor!=='undefined' && sessionMonitor.markFinished){
      sessionMonitor.markFinished(connId, { ok: !!(result && result.ok), lastSql: sql });
    }
    if(result && result.ok && tab){
      const execMetaHtml = document.getElementById('execMeta').innerHTML;
      const msgText = document.getElementById('messages').textContent;
      tab.result = {
        lastResult: Object.assign({}, state.lastResult),
        execMeta: execMetaHtml,
        messages: msgText
      };
      // 쿼리 히스토리 추가
      try{
        const d = new Date();
        const firstLine  = sql.split(/\r?\n/)[0].slice(0, 120);
        const accessInfo = (state.connAccessInfo && state.connAccessInfo[connId]) || {};
        historyPanel.add({
          ts: d,
          tsLabel: formatHistoryTime(d),
          connId,
          connLabel: getConnLabel(connId),
          tabId: tab.id,
          tabTitle: tab.title || tab.id,
          rowCount: result.rowCount,
          elapsedMs: result.elapsedMs,
          sql,
          sqlFirstLine: firstLine,
          accessReason: accessInfo.reason   || '',
          ticketId:     accessInfo.ticketId || ''
        });
      }catch(e){
        console.warn('history add failed (runCurrent)', e);
      }
    }
    return result;
  },
  async runApprovedSql(sql, connId, ctx){
    if(!state.connected){ console.warn('DB 연결 후 실행하세요 (데모에서는 계속 진행).'); }
    const tab = state.tabs.find(t=>t.id===state.activeTabId);
    if(!tab){
      alert('실행할 탭을 찾지 못했습니다.');
      return;
    }
    if(!connId || !state.connStates[connId]){
      console.warn('이 탭의 연결을 선택/연결하세요 (데모에서는 계속 진행).', connId, state.connStates);
      // return; // 데모에서는 막지 않음
    }
    if(typeof sessionMonitor!=='undefined' && sessionMonitor.markExecuting){
      sessionMonitor.markExecuting(connId, sql);
    }
    ui.showResult(); ui.setExecMeta('<span class="spin"></span> 승인된 쿼리 실행 중…');
    if (typeof ui !== 'undefined' && typeof ui.beginQueryProgress === 'function') {
      ui.beginQueryProgress();
    }
    const result = await actions._runOne(sql, connId);
    if (typeof ui !== 'undefined' && typeof ui.endQueryProgress === 'function') {
      ui.endQueryProgress();
    }
    if(typeof sessionMonitor!=='undefined' && sessionMonitor.markFinished){
      sessionMonitor.markFinished(connId, { ok: !!(result && result.ok), lastSql: sql });
    }
    if(result && result.ok && tab){
      const execMetaHtml = document.getElementById('execMeta').innerHTML;
      const msgText = document.getElementById('messages').textContent;
      tab.result = {
        lastResult: Object.assign({}, state.lastResult),
        execMeta: execMetaHtml,
        messages: msgText
      };
      try{
        const d = new Date();
        const firstLine  = sql.split(/\r?\n/)[0].slice(0, 120);
        const accessInfo = (state.connAccessInfo && state.connAccessInfo[connId]) || {};
        // 엑셀 다운로드(EXCEL_EXPORT)로 재실행되는 경우에는 히스토리에 중복으로 쌓지 않는다.
        const mode = ctx && ctx.mode;
        if(mode !== 'EXCEL_EXPORT'){
          historyPanel.add({
            ts: d,
            tsLabel: formatHistoryTime(d),
            connId,
            connLabel: getConnLabel(connId),
            tabId: tab.id,
            tabTitle: tab.title || tab.id,
            rowCount: result.rowCount,
            elapsedMs: result.elapsedMs,
            sql,
            sqlFirstLine: firstLine,
            accessReason: accessInfo.reason   || '',
            ticketId:     accessInfo.ticketId || ''
          });
        }
      }catch(e){
        console.warn('history add failed (runApprovedSql)', e);
      }
    }
    return result;
  },

  async runScript(){
    if(!state.connected){ console.warn('DB 연결 후 실행하세요 (데모에서는 계속 진행).'); }
    const tab = state.tabs.find(t=>t.id===state.activeTabId);
    const connId = tab && tab.connId ? tab.connId : null; if(!connId || !state.connStates[connId]){
      console.warn('이 탭의 연결을 선택/연결하세요 (데모에서는 계속 진행).', connId, state.connStates);
      // return; // 데모에서는 막지 않음
    }
    const stmts = cm ? sqlSplit.all(cm) : [{ text: ui.getEditor().trim() }];
    const execMsgs = [];
    ui.showResult();
    if (typeof ui !== 'undefined' && typeof ui.beginQueryProgress === 'function') {
      ui.beginQueryProgress('[스크립트 실행]');
    }
    if(typeof sessionMonitor!=='undefined' && sessionMonitor.markExecuting){
      sessionMonitor.markExecuting(connId, '[스크립트 실행]');
    }
    let totalRows = 0; let lastCols = 0; let totalMs = 0; let idx=0;
    for(const s of stmts){
      const sql = (s.text||'').trim(); if(!sql) continue; idx++;
      ui.setExecMeta(`<span class='spin'></span> 스크립트 실행 ${idx}/${stmts.length}…`);
      const r = await actions._runOne(sql, connId, true);
      if(r && r.ok){
        totalRows += r.rowCount||0;
        lastCols = r.colCount||0;
        totalMs += r.elapsedMs||0;
        execMsgs.push(`✔ [${idx}] rows=${r.rowCount} cols=${r.colCount} ${r.elapsedMs}ms`);
        // 각 문장별 히스토리도 남긴다
        try{
          const d = new Date();
          const firstLine  = sql.split(/\r?\n/)[0].slice(0, 120);
          const accessInfo = (state.connAccessInfo && state.connAccessInfo[connId]) || {};
          historyPanel.add({
            ts: d,
            tsLabel: formatHistoryTime(d),
            connId,
            connLabel: getConnLabel(connId),
            tabId: tab ? tab.id : null,
            tabTitle: tab && tab.title ? tab.title : (tab ? tab.id : ''),
            rowCount: r.rowCount,
            elapsedMs: r.elapsedMs,
            sql,
            sqlFirstLine: firstLine,
            accessReason: accessInfo.reason   || '',
            ticketId:     accessInfo.ticketId || ''
          });
        }catch(e){
          console.warn('history add failed (runScript)', e);
        }
      }else{
        execMsgs.push(`✖ [${idx}] 실패: ${r && r.error ? r.error: 'unknown'}`);
        break;
      }
    }
    document.getElementById('messages').textContent = execMsgs.join('\n');
    ui.setExecMeta(`스크립트 실행: ${idx}개 중 완료 · 총행 ${totalRows.toLocaleString()} · 마지막열 ${lastCols} · ~${totalMs} ms`);
    if(typeof sessionMonitor!=='undefined' && sessionMonitor.markFinished){
      sessionMonitor.markFinished(connId, { ok: true, lastSql: '[스크립트 실행]' });
    }
    if(tab){
      const execMetaHtml = document.getElementById('execMeta').innerHTML;
      const msgText = document.getElementById('messages').textContent;
      tab.result = {
        lastResult: Object.assign({}, state.lastResult),
        execMeta: execMetaHtml,
        messages: msgText
      };
    }
    if (typeof ui !== 'undefined' && typeof ui.endQueryProgress === 'function') {
      ui.endQueryProgress();
    }
  },
  async _runOne(sql, connId, silent){
    state.lastSql = sql;

    const accessInfo   = (state.connAccessInfo && connId) ? (state.connAccessInfo[connId] || {}) : {};
    const accessReason = accessInfo.reason   || '';
    const ticketId     = accessInfo.ticketId || '';

    try{
      if(USE_DEMO){
        const t0 = performance.now(); const mock = demo.exec(sql, connId); const t1 = performance.now();
        state.lastResult = {columns: mock.columns, rows: mock.rows, elapsedMs: Math.round(t1 - t0), rowCount: mock.rows.length};
        grid.render(mock.columns, mock.rows);
        if(!silent) ui.setExecMeta(`연결 ${connId} · 행 ${mock.rows.length.toLocaleString()} · ${mock.columns.length}열 · ${state.lastResult.elapsedMs} ms`);

        console.debug('DEMO exec meta', { connId, accessReason, ticketId });

        return { ok:true, rowCount: mock.rows.length, colCount: mock.columns.length, elapsedMs: state.lastResult.elapsedMs };
      }
      const controller = new AbortController();
      state.currentAbortController = controller;
      const timeout = setTimeout(()=> {
        controller.abort();
        state.currentAbortController = null;
      }, state.queryTimeoutMs || 15000);
      const payload = {
        connId,
        sql,
        maxRows: state.maxRows,
        timeoutMs: state.queryTimeoutMs || 15000,
        explain: false,
        accessReason,
        ticketId,
        autoCommit: state.autoCommit
      };
      const res = await fetch('/sql/execute', { method: 'POST', headers:{'Content-Type':'application/json'}, signal: controller.signal, body: JSON.stringify(payload) });
      clearTimeout(timeout);
      state.currentAbortController = null;
      if(!res.ok){ const txt = await res.text(); throw new Error(txt||res.statusText); }
      const data = await res.json();
      state.lastResult = {columns: data.columns||[], rows: data.rows||[], elapsedMs: data.elapsedMs||0, rowCount: (data.rows||[]).length};
      grid.render(state.lastResult.columns, state.lastResult.rows);
      if(!silent) ui.setExecMeta(`연결 ${connId} · 행 ${state.lastResult.rowCount.toLocaleString()} · ${state.lastResult.columns.length}열 · ${state.lastResult.elapsedMs} ms`);
      return { ok:true, rowCount: state.lastResult.rowCount, colCount: state.lastResult.columns.length, elapsedMs: state.lastResult.elapsedMs };
    }catch(err){ if(!silent) ui.setExecMeta(`<span class='warn'><i class="fa-solid fa-triangle-exclamation"></i> ${err.message||err}</span>`); return { ok:false, error: err.message||String(err) }; }
  },
  async runSql(){ // backward compat
    return await actions.runCurrent();
  },
  async explain(){
    if(!state.connected){ alert('DB 연결 후 실행하세요.'); return; }
    const sInfo = cm ? sqlSplit.selectedOrCurrent(cm) : { sql: ui.getEditor().trim() };
    const sql = (sInfo.sql||'').trim(); if(!sql){ return; }
    const tab = state.tabs.find(t=>t.id===state.activeTabId);
    const connId = tab && tab.connId ? tab.connId : null;
    if(!connId || !state.connStates[connId]){
      console.warn('이 탭의 연결을 선택/연결하세요 (데모에서는 계속 진행).', connId, state.connStates);
      // return; // 데모에서는 막지 않음
    }
    ui.showResult();

    if(USE_DEMO){
      const plan = [{"QUERY PLAN":"Seq Scan on foo  (cost=0.00..12.50 rows=5 width=4)"}];
      state.lastResult = {columns:['QUERY PLAN'], rows: plan, elapsedMs: 1, rowCount:1};
      grid.render(['QUERY PLAN'], plan);
      if(typeof planAnalyzer!=='undefined'){ planAnalyzer.renderFromLastResult(); }
      ui.setExecMeta('실행 계획 (모의 데이터)');
      if(tab){
        const execMetaHtml = document.getElementById('execMeta').innerHTML;
        const msgText = document.getElementById('messages').textContent;
        tab.result = {
          lastResult: Object.assign({}, state.lastResult),
          execMeta: execMetaHtml,
          messages: msgText
        };
      }
      return;
    }
    const res = await fetch('/sql/execute', {method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ connId, sql, maxRows: 500, timeoutMs: 15000, explain: true })});
    const data = await res.json();
    state.lastResult = {columns: data.columns||['QUERY PLAN'], rows: data.rows||[], elapsedMs: data.elapsedMs||0, rowCount: (data.rows||[]).length};
    grid.render(state.lastResult.columns, state.lastResult.rows);
    if(typeof planAnalyzer!=='undefined'){ planAnalyzer.renderFromLastResult(); }
    ui.setExecMeta('실행 계획');
    if(tab){
      const execMetaHtml = document.getElementById('execMeta').innerHTML;
      const msgText = document.getElementById('messages').textContent;
      tab.result = {
        lastResult: Object.assign({}, state.lastResult),
        execMeta: execMetaHtml,
        messages: msgText
      };
    }
  },
  
  // 실제 Excel 파일 생성 및 다운로드 (감사/반출 로직과 분리)
  _doExportExcel(){
    if(!state.lastResult || !state.lastResult.columns || !state.lastResult.columns.length){
      alert('내보낼 결과가 없습니다.');
      return;
    }
    const {columns, rows} = state.lastResult;

    const escHtml = (v)=>{
      const s = String(v == null ? '' : v);
      return s
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#39;');
    };

    let html = '<table border="1"><thead><tr>';
    html += columns.map(c => '<th>' + escHtml(c) + '</th>').join('');
    html += '</tr></thead><tbody>';
    rows.forEach(r => {
      html += '<tr>' + columns.map(c => '<td>' + escHtml(r[c]) + '</td>').join('') + '</tr>';
    });
    html += '</tbody></table>';

    const blob = new Blob(['\ufeff' + html], {
      type: 'application/vnd.ms-excel;charset=utf-8;'
    });
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = 'result.xls';
    a.click();
    URL.revokeObjectURL(a.href);
  },

  // 감사/반출용 모달을 거쳐 내보내기
  exportCsv(){
    if(!state.lastResult || !state.lastResult.columns || !state.lastResult.columns.length){
      alert('내보낼 결과가 없습니다.');
      return;
    }
    const lr = state.lastResult;
    const rowCount = typeof lr.rowCount === 'number' ? lr.rowCount : (lr.rows ? lr.rows.length : 0);
    const columns = lr.columns || [];
    const connId = state.connId;
    const activeConn = state.availableConns.find(c => c.id === connId);
    const connLabel = activeConn ? activeConn.label : (connId || '(미지정)');

    ui.openExportAuditModal({
      rowCount,
      columns,
      connId,
      connLabel,
      sql: state.lastSql || ''
    });
  },


  // 결재 승인 기반 엑셀 내보내기 (반출사유 재입력 모달 스킵)
  exportCsvFromApproval(req){
    if(!state.lastResult || !state.lastResult.columns || !state.lastResult.columns.length){
      alert('내보낼 결과가 없습니다.');
      return;
    }
    const lr = state.lastResult;
    const rowCount = typeof lr.rowCount === 'number' ? lr.rowCount : (lr.rows ? lr.rows.length : 0);
    const columns = lr.columns || [];
    const connId = state.connId;
    const activeConn = state.availableConns.find(c => c.id === connId);
    const connLabel = activeConn ? activeConn.label : (connId || '(미지정)');

    const reason = (req && req.reason) || '결재 기반 엑셀 내보내기';
    const approvalId = (req && (req.id || req.approvalId)) || '';

    try{
      actions._sendExportAuditLog({
        reason,
        approvalId,
        rowCount,
        columns,
        sql: (state.lastSql || (req && req.sql) || ''),
        connId,
        connLabel
      });
    }catch(e){
      console.warn('export audit log (from approval) error', e);
    }

    try{
      actions._doExportExcel();
    }catch(e){
      console.error('doExportExcel from approval failed', e);
      alert('엑셀 파일 생성 중 오류가 발생했습니다.');
    }
  },

  // 감사 로그 전송 (백엔드 연동용, 실패하더라도 내보내기는 계속)
  _sendExportAuditLog(payload){
    try{
      const body = Object.assign({}, payload || {}, {
        exportedAt: new Date().toISOString(),
        // 서버 세션에서 사용자 정보를 채우는 것을 권장.
        // 여기서는 프론트에서 넘길 수 있는 값만 예시로 포함.
        currentUser: (window.DBAM_CURRENT_USER || null)
      });

      if(window.DBAM_AUDIT_EXPORT_ENDPOINT){
        fetch(window.DBAM_AUDIT_EXPORT_ENDPOINT, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify(body)
        }).catch(err=>{
          console.warn('export audit log send error', err);
        });
      }else{
        console.debug('export audit log (demo only):', body);
      }
    }catch(e){
      console.warn('export audit log exception', e);
    }
  },
  exportInsert(){
    const lr = state.lastResult;
    if(!lr || !lr.columns || !lr.columns.length){
      alert('내보낼 결과가 없습니다.');
      return;
    }
    let tableName = 'your_table';
    if(state.lastSql){
      const m = state.lastSql.match(/from\s+([a-zA-Z0-9_."`]+)/i);
      if(m && m[1]){
        tableName = m[1].replace(/["`]/g,'');
      }
    }
    const cols = lr.columns;
    const lines = [];
    lines.push('-- INSERT statements generated from last result');
    lines.push('-- 필요에 따라 테이블 이름을 수정하세요.');
    const rows = lr.rows || [];
    for(let i=0; i<rows.length; i++){
      const row = rows[i] || {};
      const vals = cols.map((c)=>{
        const v = row[c];
        if(v === null || v === undefined) return 'NULL';
        if(typeof v === 'number' || typeof v === 'bigint') return String(v);
        if(typeof v === 'boolean') return v ? 'TRUE' : 'FALSE';
        const s = String(v).replace(/'/g, "''");
        return "'" + s + "'";
      });
      const colList = cols.map(c=> '"' + c + '"').join(', ');
      const valList = vals.join(', ');
      lines.push('INSERT INTO ' + tableName + ' (' + colList + ') VALUES (' + valList + ');');
    }
    const text = lines.join('\n');
    actions._downloadText(text, 'insert_statements.sql');
  },
  copySql(){
    let sql = state.lastSql || '';
    if(!sql){
      sql = ui.getEditor();
    }
    if(!sql){
      alert('복사할 쿼리가 없습니다.');
      return;
    }
    const doSetMeta = (msg)=>{
      try{
        ui.setExecMeta(msg);
      }catch(e){}
    };
    if(navigator.clipboard && navigator.clipboard.writeText){
      navigator.clipboard.writeText(sql)
        .then(()=> doSetMeta('쿼리를 클립보드에 복사했습니다.'))
        .catch(()=>{ actions._fallbackCopy(sql); doSetMeta('쿼리를 클립보드에 복사했습니다.'); });
    }else{
      actions._fallbackCopy(sql);
      doSetMeta('쿼리를 클립보드에 복사했습니다.');
    }
  },
  _fallbackCopy(text){
    const ta = document.createElement('textarea');
    ta.value = text;
    ta.style.position = 'fixed';
    ta.style.left = '-9999px';
    document.body.appendChild(ta);
    ta.focus();
    ta.select();
    try{ document.execCommand('copy'); }catch(e){}
    document.body.removeChild(ta);
  },
  _downloadText(text, fileName){
    const blob = new Blob([text], {type:'text/plain;charset=utf-8;'});
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = fileName;
    document.body.appendChild(a);
    a.click();
    setTimeout(()=>{ URL.revokeObjectURL(a.href); a.remove(); }, 0);
  },
  openSampleSelect(schema, table, connId){ ui.newEditorTab(); if(connId){ ui.setActiveConn(connId); } ui.setEditor(`-- 샘플 조회
SELECT *
FROM ${schema}.${table}
LIMIT 100;`); },
  cancelQuery(){
    if(state.currentAbortController){
      try{
        state.currentAbortController.abort();
        ui.setExecMeta('<span class="warn"><i class="fa-solid fa-circle-stop"></i> 쿼리 정지 요청됨</span>');
      }catch(e){}
      state.currentAbortController = null;
    }else{
      alert('현재 실행 중인 쿼리가 없습니다.');
    }
  }
};

ui.setExecMeta = (html)=>{ document.getElementById('execMeta').innerHTML = html; };


// Tx & print helpers (actions)
actions.commitTx = async function(){
  alert('Commit/Rollback 제어는 아직 서버 연동 전입니다.\n백엔드 API 연동 후 이 함수에서 호출하도록 구현하면 됩니다.');
};

actions.rollbackTx = async function(){
  alert('Commit/Rollback 제어는 아직 서버 연동 전입니다.\n백엔드 API 연동 후 이 함수에서 호출하도록 구현하면 됩니다.');
};

actions.printCurrentSql = function(){
  const sql = cm ? cm.getValue() : (document.getElementById('sqlEditor') ? document.getElementById('sqlEditor').value : '');
  if(!sql || !sql.trim()){
    alert('인쇄할 SQL이 없습니다.');
    return;
  }
  const w = window.open('', '_blank');
  if(!w){
    alert('팝업이 차단되었습니다. 팝업 허용 후 다시 시도하세요.');
    return;
  }
  const esc = function(s){ return String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); };
  w.document.write('<html><head><title>SQL Print</title>');
  w.document.write('<style>body{font-family:monospace;font-size:12px;padding:16px;}pre{white-space:pre-wrap;}</style>');
  w.document.write('</head><body><pre>');
  w.document.write(esc(sql));
  w.document.write('</pre></body></html>');
  w.document.close();
  try{ w.focus(); w.print(); }catch(e){}
};

actions.printCurrentResult = function(){
  const lr = state.lastResult || {};
  const cols = lr.columns || [];
  const rows = lr.rows || [];
  if(!cols.length || !rows.length){
    alert('인쇄할 결과가 없습니다.');
    return;
  }
  const w = window.open('', '_blank');
  if(!w){
    alert('팝업이 차단되었습니다. 팝업 허용 후 다시 시도하세요.');
    return;
  }
  const esc = function(s){ return String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); };
  w.document.write('<html><head><title>Result Print</title>');
  w.document.write('<style>body{font-family:system-ui,sans-serif;font-size:12px;padding:16px;}table{border-collapse:collapse;width:100%;}th,td{border:1px solid #ddd;padding:4px 6px;text-align:left;}th{background:#f3f4f6;font-weight:600;}</style>');
  w.document.write('</head><body><table><thead><tr>');
  cols.forEach(function(c){ w.document.write('<th>'+esc(c)+'</th>'); });
  w.document.write('</tr></thead><tbody>');
  rows.forEach(function(row){
    w.document.write('<tr>');
    cols.forEach(function(c){
      var v = row && typeof row === 'object' ? row[c] : '';
      if(v === null || v === undefined){ v = ''; }
      w.document.write('<td>'+esc(v)+'</td>');
    });
    w.document.write('</tr>');
  });
  w.document.write('</tbody></table></body></html>');
  w.document.close();
  try{ w.focus(); w.print(); }catch(e){}
};



/* ---------------- Demo Layer (fake connection & data) ---------------- */
const demo = {
  connectDemo(){ state.availableConns = [{id:'dev@postgres', label:'PostgreSQL (dev)'}]; state.connProfiles={}; state.connStates = {'dev@postgres': true}; state.connId='dev@postgres'; state.connected=true; ui.refreshConnStatus(); const data = { connections:[{ id:'dev@postgres', label:'PostgreSQL (dev)', profile:'LIMITED', schemas:[{ name:'public', tables:['member','orders','product'], views:['v_sales_daily'], functions:['fn_calc_tax(int)','fn_member_score(text)'], sequences:['seq_orders_id'] }]}] }; tree.render(data); ui.renderConnSelect(); ui.setActiveConn('dev@postgres'); ui.showResult(); },
  connectMulti(){ const data = { connections:[ { id:'dev@postgres', label:'PostgreSQL (dev)', profile:'LIMITED', schemas:[{ name:'public', tables:['member','orders','product'], views:['v_sales_daily'], functions:['fn_calc_tax(int)','fn_member_score(text)'], sequences:['seq_orders_id'] }]}, { id:'qa@postgres', label:'PostgreSQL (qa)', profile:'RO', schemas:[{ name:'public', tables:['member_q','orders_q'], views:['v_orders_today'], functions:['fn_q_sample()'], sequences:['seq_orders_q'] }]}, { id:'stg@mysql', label:'MySQL (staging)', profile:'LIMITED', schemas:[{ name:'shop', tables:['users','items','sales'], views:['v_sales_7d'], functions:['fn_price(varchar)'], sequences:[] }]}, { id:'dev@oracle', label:'Oracle (ops)', profile:'OPS', schemas:[{ name:'APP', tables:['TB_USER','TB_ORDER','TB_PRODUCT'], views:['VW_SALES'], functions:['FN_TAX(NUMBER)'], sequences:['SEQ_ORDER_ID'] }]} ]}; state.availableConns = data.connections.map(c=>({id:c.id, label:c.label})); state.connProfiles = {}; state.connStates = {}; state.connId=null; state.connected=false; tree.render(data); ui.renderConnSelect(); ui.refreshConnStatus(); },
  exec(sql, connId){
    const s = (sql || '').trim();

    // SELECT now()
    if(/select\s+now\(\)/i.test(s)){
      const now = new Date().toISOString();
      return {
        columns: ['now'],
        rows: [{ now }]
      };
    }

    // SELECT 1, SELECT 숫자
    const mNum = s.match(/^select\s+(\d+)\b/i);
    if(mNum){
      const v = Number(mNum[1]);
      return {
        columns: ['?column?'],
        rows: [{ '?column?': v }]
      };
    }

    // 데모 기본 응답
    return {
      columns: ['result'],
      rows: [{ result: 'OK' }]
    };
  }
};

// small helper (not used by demo, kept as reference)
Date.prototype.toISOStringSafe = function(){ try { return this.toISOString(); } catch(e){ return new Date().toISOString(); } };

/* ---------------- Minimal Test Runner ---------------- */
const tests = { list: [], add(name, fn){ this.list.push({name, fn}); }, run(){ const out = []; let pass = 0; this.list.forEach(t=>{ try { t.fn(); out.push(`✔ ${t.name}`); pass++; } catch(err){ out.push(`✖ ${t.name} -> ${err.message}`); } }); const msg = `테스트: ${pass}/${this.list.length} 통과\n` + out.join('\n'); const box = document.getElementById('messages'); if(box){ box.textContent = msg; ui.showResult(); } return {pass, total:this.list.length}; } };

// --- 기존 테스트 유지 ---
tests.add('formatSql: SELECT/FROM 대문자화', ()=>{ ui.setEditor('select 1 from dual'); ui.formatSql(); const s = ui.getEditor(); if(!/SELECT\s+1\s+FROM\s+dual/i.test(s)) throw new Error('대문자화 또는 포맷 실패'); });

tests.add('connectMulti: 가용 커넥션 3개 이상', ()=>{ demo.connectMulti(); if(state.availableConns.length < 3) throw new Error('가용 커넥션 부족'); });

tests.add('openSampleSelect: 탭에 conn 지정 & SQL 템플릿', ()=>{ const targetConn = 'qa@postgres'; actions.openSampleSelect('public','member', targetConn); const tab = state.tabs.find(t=>t.id===state.activeTabId); if(tab.connId !== targetConn) throw new Error('탭 커넥션 설정 실패'); const sql = ui.getEditor(); if(!/FROM public\.member/i.test(sql)) throw new Error('SQL 템플릿 실패'); });

tests.add('grid.render: 2행 렌더링', ()=>{ grid.render(['a','b'], [{a:1,b:2},{a:3,b:4}]); const rows = document.querySelectorAll('#grid tbody tr').length; if(rows !== 2) throw new Error('행 수 불일치:'+rows); });

tests.add('demo.exec: now()', ()=>{ const r = demo.exec('select now()','dev@postgres'); if(!(r.columns && r.columns[0]==='now')) throw new Error('열명(now) 미검출'); });

// --- 신규 테스트: 비연결 기본 접힘, 해제시 접힘+라벨, 테마/키맵, 전역 내보내기, 에디터 컨텍스트 ---
tests.add('tree: 초기 비연결 트리 닫힘', ()=>{ demo.connectMulti(); const uls = document.querySelectorAll('#dbTree li[data-conn-id] > ul'); const allClosed = Array.from(uls).every(u=> getComputedStyle(u).display==='none'); if(!allClosed) throw new Error('초기 접힘 실패'); });

tests.add('tree: 연결해도 자동 전개 금지', ()=>{ demo.connectMulti(); const id = state.availableConns[0].id; ui.setActiveConn(id); const li = tree.getConnLi(id); const sub = li.querySelector(':scope > ul'); if(getComputedStyle(sub).display !== 'none') throw new Error('연결시 자동 전개됨'); });

tests.add('tree: 토글은 화살표로만', ()=>{
  demo.connectMulti();
  const id = state.availableConns[0].id;
  // ensure connected for this conn
  ui.setActiveConn(id);
  const li = tree.getConnLi(id);
  const node = li.querySelector(':scope > .node');
  const tw = node.querySelector('.tw');
  const sub = li.querySelector(':scope > ul');

  // 1) clicking node (not tw) should NOT expand
  node.click();
  if(getComputedStyle(sub).display !== 'none') throw new Error('노드 클릭으로 열리면 안됨');

  // 2) clicking tw should expand
  tw.click();
  if(getComputedStyle(sub).display === 'none') throw new Error('화살표 클릭으로 열리지 않음');

  // 3) disconnect and try arrow -> should stay closed
  state.connStates[id] = false; tree.updateConnBadges();
  // force collapsed and arrow reset handled by updateConnBadges
  if(getComputedStyle(sub).display !== 'none') throw new Error('해제 후에도 열림 유지됨');
  const before = tw.textContent;
  tw.click(); // should do nothing
  if(tw.textContent != before) throw new Error('해제 상태에서 화살표 변경되면 안됨');
});


tests.add('tree: 해제 시 접힘 + 라벨 discon', ()=>{ demo.connectMulti(); const id = state.availableConns[1].id; const li = tree.getConnLi(id); const tag = li.querySelector('.tag'); if(tag.textContent !== 'discon') throw new Error('초기 라벨 discon 아님'); ui.setActiveConn(id); state.connStates[id]=false; tree.updateConnBadges(); const sub = li.querySelector(':scope > ul'); if(getComputedStyle(sub).display!=='none') throw new Error('해제시 접힘 실패'); if(tag.textContent!=='discon') throw new Error('해제시 라벨 변경 실패'); });

tests.add('tree: Alt+클릭은 서브트리 전체 토글', ()=>{
  demo.connectMulti();
  const id = state.availableConns[0].id;
  ui.setActiveConn(id);
  const connLi = tree.getConnLi(id);
  const tw = connLi.querySelector(':scope > .node .tw');
  const schemaUl = connLi.querySelector(':scope > ul');
  if(!schemaUl) throw new Error('schema 목록 없음');
  // Alt+click expand all
  const ev = new MouseEvent('click', {bubbles:true, altKey:true});
  tw.dispatchEvent(ev);
  // expect at least one nested ul displayed
  const inner = connLi.querySelector(':scope ul ul');
  if(inner && getComputedStyle(inner).display==='none') throw new Error('서브트리 확장 실패');
  // Alt+click collapse all
  tw.dispatchEvent(new MouseEvent('click', {bubbles:true, altKey:true}));
  if(getComputedStyle(schemaUl).display!=='none') throw new Error('서브트리 접힘 실패');
});

tests.add('tree: ArrowRight/Left immediate 토글', ()=>{
  demo.connectMulti();
  const id = state.availableConns[0].id;
  ui.setActiveConn(id);
  const li = tree.getConnLi(id);
  const node = li.querySelector(':scope > .node');
  const sub = li.querySelector(':scope > ul');
  // ensure collapsed
  sub.style.display = 'none';
  // ArrowRight should expand immediate
  node.dispatchEvent(new KeyboardEvent('keydown', {key:'ArrowRight', bubbles:true}));
  if(getComputedStyle(sub).display==='none') throw new Error('ArrowRight 확장 실패');
  // ArrowLeft should collapse immediate
  node.dispatchEvent(new KeyboardEvent('keydown', {key:'ArrowLeft', bubbles:true}));
  if(getComputedStyle(sub).display!=='none') throw new Error('ArrowLeft 접힘 실패');
});


tests.add('editor: 키맵 기본 고정', ()=>{ if(window.CodeMirror){ ui.setTheme('default'); ui.setKeymap('vim'); if(cm.getOption('keyMap')!=='default') throw new Error('키맵이 default로 고정되지 않음'); } });
tests.add('globals: window 내보내기', ()=>{ if(!window.ui || !window.demo || !window.actions || !window.tree) throw new Error('전역 내보내기 실패'); });

tests.add('editorCtx: 존재/열고닫기', ()=>{ const el = document.getElementById('editorCtx'); if(!el) throw new Error('에디터 컨텍스트 메뉴 없음'); editorCtx.open(10,10); if(el.classList.contains('hidden')) throw new Error('컨텍스트 메뉴 오픈 실패'); editorCtx.hide(); if(!el.classList.contains('hidden')) throw new Error('컨텍스트 메뉴 닫기 실패'); });


tests.add('sqlSplit: 세미콜론/주석/따옴표 처리', ()=>{
  const s = "SELECT 1; SELECT 'a; b'; /*c;*/ SELECT 3;";
  const parts = sqlSplit.splitStatements(s);
  if(parts.length !== 3) throw new Error('분할 실패:'+parts.length);
  if(parts[1].text.indexOf("a; b")<0) throw new Error('인용부호 내 세미콜론 오인식');
});

tests.add('sqlSplit: 현재문 선택', ()=>{
  if(!window.CodeMirror) return;
  ui.setEditor("SELECT 1;\nSELECT 2;\nSELECT 3;");
  const doc = cm.getDoc();
  doc.setCursor({line:1,ch:5}); // in SELECT 2
  const pick = sqlSplit.selectedOrCurrent(cm);
  if(!/SELECT 2/.test(pick.sql)) throw new Error('현재문 선택 실패');
});

// --- 전역(window)으로 내보내기: inline onclick에서 참조 가능하도록 ---

/* ---------------- Admin / Management Console (조직·사용자·권한·정책·로그·리포트) --------- */

const admin = {
  sections: {
    orgUser: {
      title: '조직도 / 사용자 / 역할 관리',
      desc: '조직 구조, 사용자, 역할을 관리하고 DBAM 역할(운영자/보안/감사자 등)을 매핑하는 영역입니다.',
      items: [
        {
          id: 'org',
          label: '조직도 관리',
          icon: 'fa-sitemap',
          tags: ['조직', '부서', '시스템소유자'],
          spec: '조직 구조 및 시스템 소유자 등록/수정, 조직별 담당자 지정'
        },
        {
          id: 'user',
          label: '사용자 관리',
          icon: 'fa-user',
          tags: ['계정', '상태', 'MFA'],
          spec: '로그인 계정 생성/비활성, 잠금 현황, MFA 상태, 로그인 실패 이력 조회'
        },
        {
          id: 'role',
          label: '역할(권한) 관리',
          icon: 'fa-id-badge',
          tags: ['역할', '메뉴권한', '기능권한'],
          spec: 'DBAM 역할(일반사용자/승인자/운영자/보안/감사자 등) 정의 및 메뉴/기능 권한 매핑'
        },
        {
          id: 'publicAccount',
          label: '공용계정 사용 관리',
          icon: 'fa-users',
          tags: ['공용계정', '사유', '승인'],
          spec: '개인계정이 아닌 공용 DB 계정 사용 시 사유·승인 절차 및 사용자 매핑 관리'
        },
        {
          id: 'regularReview',
          label: '정기 권한 검토',
          icon: 'fa-clipboard-check',
          tags: ['정기점검', '부서장', '시스템담당'],
          spec: '부서장/시스템 담당자가 소속 인원의 권한을 주기적으로 검토·유지/회수/변경 기록'
        }
      ]
    },
    accessLifecycle: {
      title: '권한 신청·변경·회수 (ITSM 연계)',
      desc: 'ITSM/작업요청 티켓과 연계되는 권한 라이프사이클 관리 템플릿입니다.',
      items: [
        {
          id: 'accessRequest',
          label: '권한 신청/변경/회수 요청',
          icon: 'fa-paper-plane',
          tags: ['요청', '승인', '워크플로'],
          spec: '제목·요청 내용·결재자 정보를 입력해 ITSM 티켓 생성 화면 호출 (DBAM에서는 입력창 제공)'
        },
        {
          id: 'dbAccountLifecycle',
          label: 'DB 계정 발급/변경/삭제 요청',
          icon: 'fa-database',
          tags: ['계정발급', '권한변경', '회수'],
          spec: 'DB 계정 신규/권한 변경/삭제 요청 템플릿. 대상 DB·스키마·기간 등 필수 정보 관리'
        },
        {
          id: 'emergencyAccess',
          label: '응급(장애) 권한 요청·사용 이력',
          icon: 'fa-triangle-exclamation',
          tags: ['장애', '한시권한', '로그'],
          spec: '장애 시 한시적 고권한 요청/승인 및 사용 내역(실행 쿼리까지) 별도 트래킹'
        }
      ]
    },
    dbSensitive: {
      title: 'DB / 민감 정보 관리',
      desc: 'DB 접속 허용 범위와 민감정보(개인정보/중요정보)를 등록·관리하는 영역입니다.',
      items: [
        {
          id: 'dbRegistry',
          label: '데이터베이스 관리',
          icon: 'fa-server',
          tags: ['DB목록', '접속정보', '계정'],
          spec: '운영/개발 DB, 스키마, 계정, 접속 방식 등을 등록하고 응용시스템 계정과 매핑'
        },
        {
          id: 'sensitiveCatalog',
          label: '민감정보(테이블/컬럼) 목록',
          icon: 'fa-key',
          tags: ['주민번호', '계좌번호', '중요정보'],
          spec: '개인정보/중요정보가 포함된 테이블·컬럼 목록 관리, 마스킹/권한 정책과 연계'
        },
        {
          id: 'ipAllowList',
          label: 'DB 접속 허용 IP 관리',
          icon: 'fa-network-wired',
          tags: ['IP목록', '망대역', '검증로그'],
          spec: '허용된 접속 IP/망대역 목록 관리 및 접속 시 IP 검증 로그 조회'
        },
        {
          id: 'maskingPolicy',
          label: '민감 컬럼 마스킹 정책',
          icon: 'fa-user-secret',
          tags: ['마스킹', '비노출', '부분표시'],
          spec: '주민번호/계좌번호 등 민감정보 기본 마스킹, 예외/다운로드 시 정책 관리'
        }
      ]
    },
    scopePolicy: {
      title: '접근 범위·사전 차단 정책',
      desc: '사용자/역할별로 허용된 객체 범위와 사전 차단 규칙을 관리합니다.',
      items: [
        {
          id: 'objectScope',
          label: 'DB/스키마/테이블/컬럼 범위',
          icon: 'fa-table',
          tags: ['접근범위', '오브젝트', '세분화'],
          spec: '사용자/역할 단위로 접근 가능한 DB/스키마/테이블/컬럼 범위를 정의'
        },
        {
          id: 'preBlock',
          label: '허용 범위 밖 SQL 사전 차단',
          icon: 'fa-ban',
          tags: ['사전차단', '화이트리스트'],
          spec: '허용된 범위를 벗어나는 SQL은 실행 전에 차단하고 사유·로그 기록'
        },
        {
          id: 'downloadThreshold',
          label: '대량 조회/반출 임계값 정책',
          icon: 'fa-download',
          tags: ['대량조회', '다운로드', '임계값'],
          spec: '행 수/용량 기준 임계값 설정, 초과 시 추가 승인 또는 차단 정책 관리'
        },
        {
          id: 'timeLocationPolicy',
          label: '접속 위치/시간대 정책',
          icon: 'fa-clock',
          tags: ['야간', '휴일', '외부망'],
          spec: 'IP/망대역/시간대(업무시간/야간/휴일) 기반 접속 허용·제한 정책 정의'
        }
      ]
    },
    authPolicy: {
      title: '계정·비밀번호·MFA 정책',
      desc: '로그인 실패 제한, 잠금, 비밀번호 정책, MFA 적용 범위를 관리합니다.',
      items: [
        {
          id: 'loginLock',
          label: '로그인 실패 횟수·계정 잠금',
          icon: 'fa-lock',
          tags: ['실패횟수', '잠금', '해제'],
          spec: '로그인 실패 허용 횟수, 자동 잠금/해제 기준 및 잠금 이력 관리'
        },
        {
          id: 'passwordPolicy',
          label: '비밀번호 정책 관리',
          icon: 'fa-key',
          tags: ['길이', '복잡도', '변경주기', '재사용금지'],
          spec: '비밀번호 최소 길이, 복잡도, 주기적 변경, 재사용 금지 횟수 등 정책 설정'
        },
        {
          id: 'passwordResetLog',
          label: '비밀번호 초기화/임시 비밀번호 로그',
          icon: 'fa-scroll',
          tags: ['초기화', '임시비밀번호', '감사'],
          spec: '비밀번호 초기화 및 임시 비밀번호 발급 이력 조회'
        },
        {
          id: 'mfaPolicy',
          label: 'MFA 적용 정책 (관리자/특수 권한)',
          icon: 'fa-mobile-screen-button',
          tags: ['MFA', 'OTP', '고권한'],
          spec: '관리자·특수 권한 사용 시 MFA/OTP 의무 적용 범위 관리'
        }
      ]
    },
    sharedEmergency: {
      title: '공용·응급 계정 관리',
      desc: '공용계정 및 응급 권한 사용 시 사유/승인/이력 관리입니다.',
      items: [
        {
          id: 'sharedAccountReason',
          label: '공용계정 사용 사유·승인',
          icon: 'fa-users-gear',
          tags: ['공용계정', '사유', '승인'],
          spec: '공용 계정 사용 요청·승인 절차 및 사용 목적 관리'
        },
        {
          id: 'emergencyUseLog',
          label: '응급 권한 사용 내역',
          icon: 'fa-notes-medical',
          tags: ['장애', '임시권한', '쿼리기록'],
          spec: '응급 권한 사용 시 접속/쿼리/다운로드 기록을 별도 플래그로 관리'
        }
      ]
    },
    logAudit: {
      title: '로그 조회·감사 뷰',
      desc: '로그인/세션/DB 접속/SQL/다운로드/정책 변경 등 전체 로그를 조회하는 화면입니다.',
      items: [
        {
          id: 'activityLog',
          label: '사용자 활동 로그',
          icon: 'fa-person-walking',
          tags: ['로그인', '세션', '메뉴사용'],
          spec: '사용자가 로그인 후 수행한 주요 활동 로그(메뉴/기능/쿼리 요약) 조회'
        },
        {
          id: 'dbAccessLog',
          label: 'DB 접속·SQL 실행·다운로드 로그',
          icon: 'fa-file-lines',
          tags: ['DB접속', 'SQL', '다운로드'],
          spec: 'DB 접속/SQL 실행/다운로드 등 중요한 이벤트 로그를 필터링·검색'
        },
        {
          id: 'policyChangeLog',
          label: '정책 변경 이력',
          icon: 'fa-sliders',
          tags: ['정책', '변경', '감사'],
          spec: '접속/권한/마스킹 등 보안 정책 변경 내역 및 변경자 정보 확인'
        },
        {
          id: 'auditView',
          label: '보안담당/감사자 전용 뷰',
          icon: 'fa-magnifying-glass',
          tags: ['감사', '검색', '필터'],
          spec: '사용자, DB, 기간, 쿼리 등으로 상세 검색 가능한 감사 전용 로그 조회 화면'
        }
      ]
    },
    anomalyReport: {
      title: '이상행위 탐지·리포트',
      desc: '이상행위 탐지 프리셋과 월간/분기별 리포트 생성을 위한 영역입니다.',
      items: [
        {
          id: 'anomalyPreset',
          label: '이상행위 탐지 프리셋',
          icon: 'fa-wave-square',
          tags: ['대량다운로드', '야간접속', '반복실패'],
          spec: '대량 다운로드, 야간/휴일 접속, 반복 로그인 실패, 위험 쿼리 실행 등 탐지 조건 프리셋 관리'
        },
        {
          id: 'riskQueryFlag',
          label: '위험 쿼리 실행 세션 표시',
          icon: 'fa-bolt',
          tags: ['위험쿼리', '세션', '알림'],
          spec: '위험 쿼리 실행 세션에 별도 아이콘/알림을 제공하여 감사자 뷰와 연계'
        },
        {
          id: 'periodicReport',
          label: '월간/분기별 DB 접근 리포트',
          icon: 'fa-chart-column',
          tags: ['월간리포트', '분기점검', '코멘트'],
          spec: '월간/분기별 DB 접근 로그 요약 리포트를 자동 생성하고 점검 결과/조치 내역 코멘트 입력'
        }
      ]
    }
  },
  current: null,
  open(section){
    const ov = document.getElementById('adminOverlay');
    if(!ov) return;
    ov.classList.add('show');
    ov.setAttribute('aria-hidden','false');
    this.show(section || 'orgUser');
  },
  close(){
    const ov = document.getElementById('adminOverlay');
    if(!ov) return;
    ov.classList.remove('show');
    ov.setAttribute('aria-hidden','true');
  },
  show(section){
    this.current = section;
    const meta = this.sections[section] || this.sections.orgUser;
    const titleEl = document.getElementById('adminTitle');
    const descEl  = document.getElementById('adminDesc');
    const bodyEl  = document.getElementById('adminBody');
    if(!titleEl || !descEl || !bodyEl) return;

    titleEl.innerHTML = '<i class="fa-solid fa-shield-halved"></i> ' + meta.title;
    descEl.textContent = meta.desc;

    const buttons = document.querySelectorAll('.admin-nav button');
    buttons.forEach(btn=>{
      if(btn.dataset.section === section){
        btn.classList.add('active');
      }else{
        btn.classList.remove('active');
      }
    });

    bodyEl.innerHTML = '';
    const grid = document.createElement('div');
    grid.className = 'admin-grid';

    (meta.items || []).forEach(it=>{
      const card = document.createElement('div');
      card.className = 'admin-card';
      const iconClass = it.icon || 'fa-circle-dot';
      card.innerHTML = '<h4><i class="fa-solid ' + iconClass + '"></i> ' + it.label + '</h4>' +
                       '<p>' + (it.spec || '') + '</p>';
      if(it.tags && it.tags.length){
        const tagsWrap = document.createElement('div');
        tagsWrap.className = 'admin-tags';
        it.tags.forEach(t=>{
          const span = document.createElement('span');
          span.className = 'admin-tag';
          span.textContent = t;
          tagsWrap.appendChild(span);
        });
        card.appendChild(tagsWrap);
      }
      const footer = document.createElement('div');
      footer.className = 'admin-footer';
      footer.textContent = '※ 상세 화면/연동은 서버 구현 단계에서 연결 예정';
      card.appendChild(footer);

      grid.appendChild(card);
    });

    bodyEl.appendChild(grid);
  }
};


// 관리 콘솔 섹션 확장 (번호 4~19 반영)
(function extendAdminSections() {
  if (!window.admin || !admin.sections) return;

  const sections = admin.sections;

  // 1) 인증/정책 쪽 (4번, 11번)
  if (sections.authPolicy && Array.isArray(sections.authPolicy.items)) {
    sections.authPolicy.items.push(
      {
        id: 'sessionTimeout',
        label: '무활동 자동 로그아웃·동시 세션 제한',
        icon: 'fa-hourglass-half',
        tags: ['세션타임아웃', '자동로그아웃', '동시세션'],
        spec: '무활동 시간 기준 자동 로그아웃과 사용자별 동시 세션 허용 개수를 설정·조회'
      },
      {
        id: 'systemEnvConfig',
        label: '시스템 환경 설정',
        icon: 'fa-sliders',
        tags: ['공통코드', '로그인정책', '기본설정', '리소스다운로드', '감사옵션'],
        spec: '코드, 로그인 정책, 사용자 기본설정, 리소스 다운로드, 감사 옵션 등 DBAM 공통 환경을 관리'
      }
    );
  }

  // 2) DB/민감정보 쪽 (6번, 7·15·16번, 13번)
  if (sections.dbSensitive && Array.isArray(sections.dbSensitive.items)) {
    // 기존 dbRegistry spec 보강
    sections.dbSensitive.items = sections.dbSensitive.items.map(function (item) {
      if (item.id === 'dbRegistry') {
        return Object.assign({}, item, {
          spec: '운영/개발 등 환경 구분별 DB 인스턴스의 스키마, 계정, 접속 정보·접속 방식을 등록하고 ' +
                '응용시스템 계정과 매핑하며 연결 테스트를 지원'
        });
      }
      return item;
    });

    sections.dbSensitive.items.push(
      {
        id: 'dbResourceMonitor',
        label: 'DB 파라미터·리소스·상태 모니터링',
        icon: 'fa-gauge-high',
        tags: ['DB파라미터', '리소스사용량', '상태'],
        spec: 'DB 파라미터, 리소스 사용량, 상태를 모니터링하는 화면'
      },
      {
        id: 'dbDashboard',
        label: '전체 데이터베이스 관리 대시보드',
        icon: 'fa-table-cells-large',
        tags: ['전체DB현황', '용량', '접속', '요약'],
        spec: '등록된 전체 DB 인스턴스의 상태, 용량, 접속, 현황을 요약해 보여주는 대시보드'
      }
    );
  }

  // 3) 접근 범위·사전 차단 정책 쪽 (9번, 14번, 18번, 19번)
  if (sections.scopePolicy && Array.isArray(sections.scopePolicy.items)) {
    sections.scopePolicy.items.push(
      {
        id: 'queryApproval',
        label: '쿼리 결재 관리',
        icon: 'fa-stamp',
        tags: ['위험쿼리', '대량다운로드', '승인요청', '결재이력'],
        spec: '위험 쿼리·대량 다운로드에 대한 승인 요청 및 결재 이력을 관리'
      },
      {
        id: 'exportPolicy',
        label: 'Export Data 정책',
        icon: 'fa-file-export',
        tags: ['데이터내보내기', '반출', '승인정책'],
        spec: '데이터 내보내기 허용 범위, 대상, 형식, 승인 필요 여부를 설정'
      },
      {
        id: 'queryTimeout',
        label: '쿼리 타임아웃 설정',
        icon: 'fa-clock-rotate-left',
        tags: ['쿼리타임아웃', '최대실행시간'],
        spec: '쿼리 최대 실행 시간을 설정하고 초과 시 자동 중지되도록 관리'
      },
      {
        id: 'transactionControl',
        label: '트랜잭션 제어 정책',
        icon: 'fa-exchange-alt',
        tags: ['Auto-commit', 'Commit', 'Rollback'],
        spec: 'Auto-commit 사용 여부와 Commit/Rollback 제어 방식을 정책으로 관리'
      }
    );
  }

  // 4) 로그·감사·리포트 쪽 (5번, 8번, 10번, 12번)
  if (sections.logAudit && Array.isArray(sections.logAudit.items)) {
    sections.logAudit.items.push(
      {
        id: 'dbTxnLog',
        label: '트랜잭션/리두 로그 요약',
        icon: 'fa-database',
        tags: ['트랜잭션로그', '리두로그', '요약조회'],
        spec: 'DB별 트랜잭션 로그와 리두 로그를 요약 조회'
      },
      {
        id: 'sessionManage',
        label: '세션 관리',
        icon: 'fa-users-gear',
        tags: ['세션목록', '세션관리', 'DBA전용'],
        spec: 'DBA·관리자가 DB별 세션 목록을 조회하고 세션 상태를 관리'
      },
      {
        id: 'externalArchive',
        label: '주요 데이터 외부 저장 설정',
        icon: 'fa-vault',
        tags: ['로그이중보관', '외부저장소'],
        spec: '중요 로그·설정 데이터를 외부 안전 저장소로 이중 보관하는 설정을 관리'
      },
      {
        id: 'systemInfo',
        label: 'DBAM 시스템 정보',
        icon: 'fa-circle-info',
        tags: ['버전', '구성요소', '라이선스', '환경정보'],
        spec: 'DBAM 시스템 버전, 구성요소, 라이선스, 환경 정보를 제공'
      }
    );
  }
})();




/* ---------------- Connection Settings modal controller ---------------- */
const connSettings = {
  open(connId) {
    const backdrop = document.getElementById('connSettingsBackdrop');
    const form = document.getElementById('connSettingsForm');
    if (!backdrop || !form) {
      alert('커넥션 설정 모달 DOM을 찾지 못했습니다.');
      return;
    }

    // 초기화
    form.reset();
    const idInput   = document.getElementById('connSettingsConnId');
    const nameInput = document.getElementById('connSettingsName');
    const envSelect = document.getElementById('connSettingsEnv');

    if (idInput) {
      idInput.value = connId || '';
    }

    // 기존 연결 정보가 있으면 이름/환경 정도만 채워줌 (접속정보는 서버 연동 후)
    let label = connId || '';
    let envValue = '';
    try {
      const conns = (state && state.availableConns) ? state.availableConns : [];
      const found = conns.find(c => c.id === connId);
      if (found) {
        label = found.label || found.id || label;
        if (nameInput && !nameInput.value) {
          nameInput.value = label;
        }
        if (typeof found.env !== 'undefined' && found.env !== null) {
          envValue = found.env;
        }
      } else if (nameInput && !nameInput.value) {
        nameInput.value = label;
      }

      // state.connEnvs 우선
      if (state && state.connEnvs && connId && state.connEnvs[connId]) {
        envValue = state.connEnvs[connId] || '';
      }

      // 트리 노드 data-env 보조
      if (!envValue && typeof tree !== 'undefined' && tree && typeof tree.getConnLi === 'function' && connId) {
        const li = tree.getConnLi(connId);
        if (li && li.dataset && li.dataset.env) {
          envValue = li.dataset.env;
        }
      }

      if (envSelect) {
        envSelect.value = envValue || '';
      }
    } catch (e) {
      // state가 없거나 구조가 달라도 치명적이지 않으므로 무시
    }

    backdrop.classList.remove('hidden');
    backdrop.classList.add('show');
    backdrop.setAttribute('aria-hidden', 'false');
  },

  openNew() {
    this.open(null);
  },

  close() {
    const backdrop = document.getElementById('connSettingsBackdrop');
    if (!backdrop) return;
    backdrop.classList.remove('show');
    backdrop.classList.add('hidden');
    backdrop.setAttribute('aria-hidden', 'true');
  },

  save() {
    const form = document.getElementById('connSettingsForm');
    const nameInput = document.getElementById('connSettingsName');
    const idInput   = document.getElementById('connSettingsConnId');
    const envSelect = document.getElementById('connSettingsEnv');

    if (!form) {
      alert('커넥션 설정 폼을 찾을 수 없습니다.');
      return;
    }

    const label = nameInput ? nameInput.value.trim() : '';
    if (!label) {
      alert('연결 이름을 입력하세요.');
      if (nameInput) nameInput.focus();
      return;
    }

    const connId = (idInput && idInput.value) ? idInput.value.trim() : '';
    const envValue = envSelect ? (envSelect.value || '').trim() : '';
    const conn = {
      id: connId,
      label: label,
      profile: null,
      env: envValue
    };

    let updated = false;

    // 기존 DB 노드가 있으면 해당 노드/상태를 수정
    if (connId) {
      // state.availableConns 갱신
      try {
        if (typeof state !== 'undefined' && state && Array.isArray(state.availableConns)) {
          const list = state.availableConns;
          for (let i = 0; i < list.length; i++) {
            const c = list[i];
            if (c && c.id === connId) {
              list[i] = {
                id: c.id,
                label: label,
                profile: c.profile || null,
                env: envValue || c.env || null
              };
              updated = true;
              break;
            }
          }
          state.availableConns = list;
        }
      } catch (e) {
        console.warn('connSettings.save: availableConns update error', e);
      }

      // 트리 노드 라벨 갱신
      try {
        const li = document.querySelector('#dbTree li[data-conn-id="' + connId + '"]');
        if (li) {
          li.dataset.label = label;
          li.dataset.env = envValue || '';
          const nodeEl = li.querySelector('.node');
          if (nodeEl) {
            const spans = nodeEl.querySelectorAll('span');
            if (spans && spans.length > 0) {
              spans[spans.length - 1].textContent = label;
            }
          }
          updated = true;
        }
      } catch (e) {
        console.warn('connSettings.save: tree node update error', e);
      }

      // 연결 선택 박스 / 배지 갱신
      if (updated) {
        try {
          if (typeof ui !== 'undefined' && ui) {
            if (typeof ui.renderConnSelect === 'function') {
              ui.renderConnSelect();
            } else if (typeof ui.syncConnSelect === 'function') {
              ui.syncConnSelect();
            }
            if (typeof ui.updateConnStatusChip === 'function') {
              ui.updateConnStatusChip();
            }
          }
        } catch (e) {
          console.warn('connSettings.save: ui sync error', e);
        }

        try {
          if (typeof tree !== 'undefined' && tree && typeof tree.updateConnBadges === 'function') {
            tree.updateConnBadges();
          }
        } catch (e) {
          console.warn('connSettings.save: updateConnBadges error', e);
        }

        // 환경 구분값 저장 및 탭 밑줄 색 반영
        try {
          if (typeof state !== 'undefined' && state) {
            if (!state.connEnvs) {
              state.connEnvs = {};
            }
            if (connId) {
              state.connEnvs[connId] = envValue || '';
              if (state.connStates && state.connStates[connId] && typeof applyTabUnderlineForConn === 'function') {
                applyTabUnderlineForConn(connId);
              }
              if (state.connStates && state.connStates[connId] && typeof updateEnvBannerForConn === 'function') {
                try{
                  var activeTab = (state.tabs || []).find(function(t){ return t && t.id === state.activeTabId; });
                  var activeConnId = activeTab ? (activeTab.lastConnId || activeTab.connId || null) : null;
                  if (activeConnId === connId) {
                    updateEnvBannerForConn(connId);
                  }
                }catch(e){
                  console.warn('connSettings.save: updateEnvBannerForConn error', e);
                }
              }
            }
          }
        } catch (e) {
          console.warn('connSettings.save: connEnvs update error', e);
        }
      }
    }

    // connId가 없거나(신규) / 위 단계에서 수정 못 한 경우 → 새 DB 노드 추가
    if (!connId || !updated) {
      try {
        if (typeof dbFolderUi !== 'undefined' && dbFolderUi && typeof dbFolderUi.addDbNode === 'function') {
          dbFolderUi.addDbNode(conn);
        } else {
          console.warn('dbFolderUi.addDbNode 가 없어 DB 노드를 트리에 추가하지 못했습니다.');
        }
      } catch (e) {
        console.warn('connSettings.save addDbNode error', e);
      }
    }

    // 모달 닫기
    this.close();
  }
};




const codeActions = {
  _getDoc(){
    try{
      if(typeof cm !== 'undefined' && cm && cm.getDoc){
        return cm.getDoc();
      }
    }catch(e){}
    return null;
  },
  _getSelectionText(doc){
    try{
      if(!doc) return '';
      const sel = doc.getSelection();
      if(sel && sel.length) return sel;
      const cur = doc.getCursor();
      const line = doc.getLine(cur.line) || '';
      let start = cur.ch;
      let end = cur.ch;
      while(start > 0 && /[\w\d_.]/.test(line.charAt(start-1))) start--;
      while(end < line.length && /[\w\d_.]/.test(line.charAt(end))) end++;
      if(end > start){
        return doc.getRange({ line: cur.line, ch: start }, { line: cur.line, ch: end });
      }
      return '';
    }catch(e){
      console.warn('codeActions._getSelectionText error', e);
      return '';
    }
  },
  toInList(){
    try{
      const doc = this._getDoc();
      if(!doc) return;
      let text = doc.getSelection();
      if(!text){
        text = this._getSelectionText(doc);
      }
      if(!text || !text.trim()){
        alert('IN 리스트로 변환할 값을 먼저 선택하세요.');
        return;
      }
      const raw = text.split(/[\n,\t,]+/).map(s => s.trim()).filter(Boolean);
      if(!raw.length){
        alert('선택된 값이 없습니다.');
        return;
      }
      const uniq = [];
      raw.forEach(v => {
        if(uniq.indexOf(v) === -1){
          uniq.push(v);
        }
      });
      const parts = uniq.map(v => {
        let val = v;
        if((val.startsWith("'") && val.endsWith("'")) || (val.startsWith('"') && val.endsWith('"'))){
          val = val.slice(1, -1);
        }
        const isNum = /^-?\d+(\.\d+)?$/.test(val);
        if(isNum) return val;
        return "'" + val.replace(/'/g, "''") + "'";
      });
      const result = 'IN (' + parts.join(', ') + ')';
      if(doc.somethingSelected && doc.somethingSelected()){
        const from = doc.getCursor('from');
        const to = doc.getCursor('to');
        doc.replaceRange(result, from, to);
      }else{
        const cur = doc.getCursor();
        doc.replaceRange(result, cur);
      }
    }catch(e){
      console.warn('codeActions.toInList error', e);
    }
  },
  toggleComment(){
  try{
    const doc = this._getDoc();
    if(!doc) return;
    const from = doc.getCursor('from');
    const to = doc.getCursor('to');
    const startLine = from.line;
    const endLine = to.line;

    const applyToggle = () => {
      for(let line = startLine; line <= endLine; line++){
        const text = doc.getLine(line);
        if(!text || !text.trim()) continue;
        const leading = (text.match(/^\s*/) || [''])[0];
        let rest = text.slice(leading.length);
        if(rest.startsWith('-- ')){
          rest = rest.slice(3);
        }else if(rest.startsWith('--')){
          rest = rest.slice(2);
        }else{
          rest = '-- ' + rest;
        }
        doc.replaceRange(leading + rest, { line, ch: 0 }, { line, ch: text.length });
      }
      // 주석 토글 후, 전체 줄(0열~끝) 다시 선택해서 앞의 '--'까지 선택되도록 유지
      try{
        const lastLineText = doc.getLine(endLine) || '';
        doc.setSelection(
          { line: startLine, ch: 0 },
          { line: endLine, ch: lastLineText.length }
        );
      }catch(_e2){}
    };

    let cmEditor = null;
    try{
      if(typeof cm !== 'undefined' && cm && cm.getDoc){
        cmEditor = cm;
      }
    }catch(_e){}

    if(cmEditor && typeof cmEditor.operation === 'function'){
      cmEditor.operation(applyToggle);
    }else{
      applyToggle();
    }
  }catch(e){
    console.warn('codeActions.toggleComment error', e);
  }
},


  runSelection(){
    try{
      if(typeof actions !== 'undefined' && actions && typeof actions.runCurrent === 'function'){
        actions.runCurrent();
      }
    }catch(e){
      console.warn('codeActions.runSelection error', e);
    }
  },
  openMenu(editorInstance){
    try{
      if(typeof editorCtx === 'undefined' || !editorCtx || typeof editorCtx.open !== 'function'){
        return;
      }
      const cmEditor = editorInstance || (typeof cm !== 'undefined' ? cm : null);
      if(!cmEditor || !cmEditor.charCoords){
        editorCtx.open(window.innerWidth / 2, window.innerHeight / 2);
        return;
      }
      const doc = cmEditor.getDoc ? cmEditor.getDoc() : null;
      const cursor = doc ? doc.getCursor() : null;
      const coords = cursor ? cmEditor.charCoords(cursor, 'page') : { left: window.innerWidth / 2, bottom: window.innerHeight / 2 };
      const x = coords.left;
      const y = coords.bottom + 4;
      editorCtx.open(x, y);
    }catch(e){
      console.warn('codeActions.openMenu error', e);
    }
  }
};

  Object.assign(window, { ui, tree, actions, demo, tests, ctxMenu, editorCtx, bottomTabs, admin });

// bootstrap
window.addEventListener('DOMContentLoaded', ()=>{
  try{
    ui.init();
    bottomTabs.init();
    bottomTabs.activate('result');

    if (typeof dbFolderUi !== 'undefined' && typeof dbFolderUi.initToolbar === 'function') {
      dbFolderUi.initToolbar();
    }

    // 데모 모드(USE_DEMO=true)에서는 기본 데모 커넥션/트리 한 번 그려줌
    if (typeof USE_DEMO !== 'undefined' && USE_DEMO) {
      if (!state.availableConns || !state.availableConns.length) {
        if (typeof demo !== 'undefined' && typeof demo.connectMulti === 'function') {
          demo.connectMulti();
        }
      }
    }

    // 테스트는 개발 모드에서만 수동 실행
    if (window && window.location) {
      const q = window.location.search || '';
      const h = window.location.hash || '';
      if ((q+h).indexOf('dbamTest=1') >= 0) {
        tests.run();
      }
    }
    if (typeof initAutoSaveTimer === 'function') {
      initAutoSaveTimer();
    }

    // ESC 키로 모달 닫기 (전체 모달 + 관리 콘솔, 최상단부터 1개씩)
    document.addEventListener('keydown', (e)=>{
      const key = e.key || e.keyCode;
      if (key === 'Escape' || key === 'Esc' || key === 27) {

        const candidates = [];

        const pushIfVisible = (id, closer) => {
          const el = document.getElementById(id);
          if (!el) return;
          if (!el.classList.contains('show')) return;
          candidates.push({ el, closer, id });
        };

        // 커넥션 설정 모달
        pushIfVisible('connSettingsBackdrop', () => {
          if (typeof connSettings !== 'undefined' && connSettings && typeof connSettings.close === 'function') {
            connSettings.close();
          }
          // ESC로 모달을 닫을 때 DB 추가 버튼 포커스(검정 테두리) 제거
          const addDbBtn = document.getElementById('dbtreeAddDbBtn');
          if (addDbBtn) {
            addDbBtn.blur();
          }
        });

        // 접속 사유 모달
        pushIfVisible('connReasonBackdrop', () => {
          if (typeof ui !== 'undefined' && ui && typeof ui.closeConnReasonModal === 'function') {
            ui.closeConnReasonModal();
          }
        });

        // 위험 쿼리 승인 요청 모달
        pushIfVisible('approvalRequestBackdrop', () => {
          if (typeof approvalCenter !== 'undefined' && approvalCenter && typeof approvalCenter.closeRequestModal === 'function') {
            approvalCenter.closeRequestModal();
          }
        });

        // 위험 쿼리 승인 상세 모달
        pushIfVisible('approvalDetailBackdrop', () => {
          if (typeof approvalCenter !== 'undefined' && approvalCenter && typeof approvalCenter.closeDetailModal === 'function') {
            approvalCenter.closeDetailModal();
          }
        });

        // Export 감사/승인 모달
        pushIfVisible('exportAuditBackdrop', () => {
          if (typeof ui !== 'undefined' && ui && typeof ui.closeExportAuditModal === 'function') {
            ui.closeExportAuditModal();
          } else if (typeof closeExportAuditModal === 'function') {
            closeExportAuditModal();
          }
        });

        // 내 정보 모달
        pushIfVisible('myInfoBackdrop', () => {
          if (typeof ui !== 'undefined' && ui && typeof ui.closeMyInfoModal === 'function') {
            ui.closeMyInfoModal();
          } else if (typeof closeMyInfoModal === 'function') {
            closeMyInfoModal();
          }
        });

        // 내 설정 모달
        pushIfVisible('mySettingsBackdrop', () => {
          if (typeof closeMySettings === 'function') {
            closeMySettings();
          }
        });

        // 부재중 / 대결자 설정 모달 (구 버전 호환)
        pushIfVisible('delegateSettingsBackdrop', () => {
          if (typeof closeDelegateSettingsModal === 'function') {
            closeDelegateSettingsModal();
          }
        });

        // 비밀번호 변경 모달
        pushIfVisible('passwordChangeBackdrop', () => {
          if (typeof closePasswordChangeModal === 'function') {
            closePasswordChangeModal();
          }
        });

        // 개인 SQL 불러오기 모달
        pushIfVisible('personalSqlLoadBackdrop', () => {
          if (typeof ui !== 'undefined' && ui && typeof ui.closePersonalSqlLoad === 'function') {
            ui.closePersonalSqlLoad();
          }
        });

        // 개인 SQL 저장 모달
        pushIfVisible('personalSqlSaveBackdrop', () => {
          if (typeof ui !== 'undefined' && ui && typeof ui.closePersonalSqlSave === 'function') {
            ui.closePersonalSqlSave();
          }
        });

        // 최근 쿼리 히스토리 사이드바
        pushIfVisible('queryHistorySidebar', () => {
          if (typeof queryHistorySidebar !== 'undefined' && queryHistorySidebar && typeof queryHistorySidebar.close === 'function') {
            queryHistorySidebar.close();
          }
        });

        // 쿼리 스냅샷 모달
        pushIfVisible('snapshotBackdrop', () => {
          if (typeof snapshots !== 'undefined' && snapshots && typeof snapshots.closeModal === 'function') {
            snapshots.closeModal();
          }
        });

        // 테이블 편집 모달
        pushIfVisible('tableEditBackdrop', () => {
          if (typeof tableEditor !== 'undefined' && tableEditor && typeof tableEditor.close === 'function') {
            tableEditor.close();
          }
        });

        // 대결자 선택 (조직도) 모달
        pushIfVisible('delegateOrgBackdrop', () => {
          if (window.delegatePicker && typeof window.delegatePicker.close === 'function') {
            window.delegatePicker.close();
          } else {
            const el = document.getElementById('delegateOrgBackdrop');
            if (el) {
              el.classList.remove('show');
              el.classList.add('hidden');
              el.setAttribute('aria-hidden','true');
            }
          }
        });

        // 부재중 & 대결자 관리 모달 (프로필에서 여는 새 모달)
        try {
          const absenceBackdrop = document.getElementById('absenceModalBackdrop');
          if (absenceBackdrop && absenceBackdrop.classList.contains('open')) {
            candidates.push({
              el: absenceBackdrop,
              closer: () => {
                if (typeof closeAbsenceModal === 'function') {
                  closeAbsenceModal();
                }
              },
              id: 'absenceModalBackdrop'
            });
          }
        } catch (err) {
          console.warn('ESC absenceModalBackdrop candidate error', err);
        }

        // 관리 콘솔 오버레이
        (function(){
          const ov = document.getElementById('adminOverlay');
          if (!ov || !ov.classList.contains('show')) return;
          candidates.push({
            el: ov,
            closer: () => {
              if (typeof admin !== 'undefined' && admin && typeof admin.close === 'function') {
                try { admin.close(); } catch(err) { console.warn('ESC close adminOverlay error', err); }
              } else {
                ov.classList.remove('show');
                ov.setAttribute('aria-hidden','true');
              }
            },
            id: 'adminOverlay'
          });
        })();

        if (!candidates.length) {
          return;
        }

        // DOM 상에서 가장 나중에 위치한 요소(시각적으로 가장 위에 있는 요소)를 1개만 닫는다.
        let top = candidates[0];
        for (let i = 1; i < candidates.length; i++) {
          const current = candidates[i];
          if (!current.el || current.el === top.el) continue;
          const cmp = top.el.compareDocumentPosition(current.el);
          if (cmp & Node.DOCUMENT_POSITION_FOLLOWING) {
            top = current;
          }
        }

        try {
          if (typeof top.closer === 'function') {
            top.closer();
          }
        } catch (err) {
          console.warn('ESC close topmost error', err);
        }
      }
    });  }catch(e){
    console.error(e);
  }
});
</script>


  <!-- 관리 / 보안 콘솔 (조직/사용자/권한/정책/로그/리포트) -->
  <div id="adminOverlay" class="admin-overlay" role="dialog" aria-modal="true" aria-hidden="true">
    <div class="admin-shell">
      <aside class="admin-sidebar">
        <h3><i class="fa-solid fa-shield-halved"></i> 관리 콘솔</h3>
        <div class="admin-nav">
          <div class="admin-nav-section">
            <div class="admin-nav-section-title">조직·사용자·역할</div>
            <button type="button" data-section="orgUser" onclick="admin.show('orgUser')">조직도 / 사용자 / 역할</button>
            <button type="button" data-section="accessLifecycle" onclick="admin.show('accessLifecycle')">권한 신청·변경·회수</button>
          </div>
          <div class="admin-nav-section">
            <div class="admin-nav-section-title">DB·민감정보</div>
            <button type="button" data-section="dbSensitive" onclick="admin.show('dbSensitive')">DB / 민감정보 관리</button>
            <button type="button" data-section="scopePolicy" onclick="admin.show('scopePolicy')">접근 범위·사전 차단</button>
          </div>
          <div class="admin-nav-section">
            <div class="admin-nav-section-title">계정·정책</div>
            <button type="button" data-section="authPolicy" onclick="admin.show('authPolicy')">계정·비밀번호·MFA 정책</button>
            <button type="button" data-section="sharedEmergency" onclick="admin.show('sharedEmergency')">공용/응급 계정 관리</button>
          </div>
          <div class="admin-nav-section">
            <div class="admin-nav-section-title">로그·감사·리포트</div>
            <button type="button" data-section="logAudit" onclick="admin.show('logAudit')">로그·감사 뷰</button>
            <button type="button" data-section="anomalyReport" onclick="admin.show('anomalyReport')">이상행위·리포트</button>
          </div>
        </div>
      </aside>
      <section class="admin-content">
        <header class="admin-header">
          <h2 id="adminTitle"><i class="fa-solid fa-house-lock"></i> 관리 콘솔 개요</h2>
          <button type="button" class="admin-close" onclick="admin.close()"><i class="fa-solid fa-xmark"></i></button>
        </header>
        <div id="adminDesc" class="admin-footer" style="text-align:left;margin-top:4px;">
          DBAM 콘솔에서 ISMS/감사 요구사항을 한 눈에 관리하는 화면입니다. 좌측에서 영역을 선택하면 관련 기능 카드가 표시됩니다.
        </div>
        <div id="adminBody" class="admin-body">
          <!-- JS에서 카드 렌더링 -->
        </div>
      </section>
    </div>
  </div>

  
  <!-- 내 정보 모달 -->
  <div id="myInfoBackdrop" class="export-modal-backdrop" role="dialog" aria-modal="true" aria-hidden="true">
    <div class="export-modal">
  <div class="shell">
    <header>
      <div class="title-area">
        <h1>내 정보<span class="title-badge">DB 접근제어 포털 · 사용자 정보</span></h1>
        <div class="title-sub">
          현재 로그인된 사용자 기준으로, 프로필 · 권한 · 접근 가능 DB · 신청 현황 · 보안 로그 요약을 보여줍니다.
        </div>
      </div>
      <div class="pill-meta">
        <span><span class="pill-dot" style="background:#22c55e;"></span>세션 유효</span>
        <span><span class="pill-dot" style="background:#38bdf8;"></span>샘플 데이터 · UI 전용</span>
      </div>
    </header>

    <main>
      <!-- LEFT COLUMN -->
      <section>
        <!-- 기본 프로필 -->
        <div class="card">
          <div class="card-header">
            <div>
              <div class="card-title">
                <span class="card-title-icon">ID</span>
                기본 프로필 / 로그인 정보
              </div>
              <div class="card-desc">
                사내 인사정보와 연동된 기본 정보, 최근 로그인 이력을 요약합니다.
              </div>
            </div>
            
          </div>
          <div class="profile-grid">
            <div class="avatar-block">
              <div class="avatar-ring">H</div>
              <div class="avatar-label">샘플 사용자</div>
            </div>
            <div>
              <dl class="profile-fields">
                <dt>이름</dt><dd>홍길동</dd>
                <dt>사번 / ID</dt><dd>00012345 / hgildong</dd>
                <dt>부서 / 직책</dt><dd>IT운영팀 / 대리</dd>
                <dt>현재 세션 시작</dt><dd>2025-11-27 14:12 (KST)</dd>
                <dt>마지막 로그인</dt><dd>2025-11-27 09:02 · 10.10.20.35 · Chrome on Windows</dd>
              </dl>
              <div class="hint">※ 위 정보는 샘플입니다. 실제 시스템에서는 사내 인사정보와 연동해 자동으로 표시됩니다.</div>
            </div>
          </div>
        </div>

        <!-- 역할/권한 요약 -->
        <div class="card" style="margin-top:10px;">
          <div class="card-header">
            <div>
              <div class="card-title">
                <span class="card-title-icon sec">RB</span>
                역할 · 승인 권한 요약
              </div>
              <div class="card-desc">
                DBAM 내에서 부여된 역할, 위험쿼리 승인 권한, 보안 정책 적용 범위를 요약합니다.
              </div>
            </div>
            <div class="card-toolbar">
              <span class="tag-soft accent">운영 DB 일부 쓰기 가능</span>
            </div>
          </div>
          <ul class="roles-list">
            <li>
              <div class="roles-label">DBAM 역할</div>
              <div class="roles-badges">
                <span class="badge">개발자</span>
                <span class="badge">운영자(부분)</span>
              </div>
            </li>
            <li>
              <div class="roles-label">승인 권한</div>
              <div class="roles-badges">
                <span class="badge">개발-위험쿼리 승인 가능</span>
                <span class="badge">운영-카드계 읽기 승인 가능</span>
              </div>
            </li>
            <li>
              <div class="roles-label">보안 정책</div>
              <div class="roles-badges">
                <span class="badge">민감컬럼 마스킹 적용 대상</span>
                <span class="badge">운영 DB 쓰기 시 사전승인 필수</span>
                <span class="badge">엑셀 다운로드 50,000행 제한</span>
              </div>
            </li>
          </ul>
          <div class="hint">※ 실제 권한/정책은 사내 계정·역할 매핑에 따라 자동 반영되며, 변경 시 감사 로그에 기록됩니다.</div>
        </div>

        <!-- 보안 로그 요약 -->
        <div class="card" style="margin-top:10px;">
          <div class="card-header">
            <div>
              <div class="card-title">
                <span class="card-title-icon warn">LG</span>
                보안 로그 요약
              </div>
              <div class="card-desc">
                최근 로그인 / DB 접속 / 대량 다운로드 이력을 간단히 보여줍니다.
              </div>
            </div>
            <div class="card-toolbar">
              <span class="tag-soft warn">이상 징후 확인용</span>
            </div>
          </div>
          <div class="section-grid">
            <div>
              <div class="card-desc" style="margin-bottom:2px;">최근 로그인 (상위 5건)</div>
              <ul class="log-list">
                <li class="log-item">
                  <div class="log-main">
                    <span>2025-11-27 09:02</span>
                    <span>성공</span>
                  </div>
                  <div class="log-meta">10.10.20.35 · Chrome on Windows</div>
                </li>
                <li class="log-item">
                  <div class="log-main">
                    <span>2025-11-26 18:11</span>
                    <span>성공</span>
                  </div>
                  <div class="log-meta">10.10.20.12 · Edge on Windows</div>
                </li>
                <li class="log-item">
                  <div class="log-main">
                    <span>2025-11-26 08:57</span>
                    <span>실패 (비밀번호 오류)</span>
                  </div>
                  <div class="log-meta">10.10.20.12 · Chrome on Windows</div>
                </li>
              </ul>
            </div>
            <div>
              <div class="card-desc" style="margin-bottom:2px;">최근 DB 접속 / 다운로드 (상위 5건)</div>
              <ul class="log-list">
                <li class="log-item">
                  <div class="log-main">
                    <span>2025-11-27 14:18 · 개발-카드계 PostgreSQL</span>
                  </div>
                  <div class="log-meta">조회 쿼리 12건 실행 · 위험쿼리 없음</div>
                </li>
                <li class="log-item">
                  <div class="log-main">
                    <span>2025-11-27 11:02 · 운영-카드계 Oracle</span>
                  </div>
                  <div class="log-meta">마스킹 컬럼 포함 조회 · 승인번호 #OPS-20251127-034</div>
                </li>
                <li class="log-item">
                  <div class="log-main">
                    <span>2025-11-26 16:40 · 개발-공통 PostgreSQL</span>
                  </div>
                  <div class="log-meta">엑셀 다운로드 32,540행 · 사유: 배치 오류 원인 분석</div>
                </li>
              </ul>
            </div>
          </div>
          <div class="foot-hint">※ 상세 로그는 상단 메뉴의 "트랜잭션/쿼리 로그" 화면에서 확인할 수 있습니다.</div>
        </div>
      </section>

      <!-- RIGHT COLUMN -->
      <section>
        <!-- 내가 접근할 수 있는 데이터베이스 -->
        <div class="card">
          <div class="card-header">
            <div>
              <div class="card-title">
                <span class="card-title-icon sec">DB</span>
                내가 접근할 수 있는 데이터베이스
              </div>
              <div class="card-desc">
                현재 권한 기준으로 접속 가능한 DB 목록을 환경·시스템별로 보여줍니다.
              </div>
            </div>
            <div class="card-toolbar">
              <span class="tag-soft">총 <strong>샘플 6건</strong></span>
            </div>
          </div>
          <div class="db-access-toolbar">
            <div class="segmented">
              <button type="button" data-env="ALL" class="is-active">전체</button>
              <button type="button" data-env="DEV">개발</button>
              <button type="button" data-env="PROD">운영</button>
            </div>
            <input type="search" id="dbSearchInput" placeholder="시스템명 / DB명 / 프로필 검색" />
          </div>
          <div class="table-wrap">
            <table id="dbAccessTable">
              <thead>
                <tr>
                  <th style="width:74px;">환경</th>
                  <th>시스템</th>
                  <th>DB 유형</th>
                  <th>접속 프로필</th>
                  <th>내 권한</th>
                  <th style="width:110px;">권한 유효기간</th>
                </tr>
              </thead>
              <tbody>
                <tr data-env="DEV">
                  <td><span class="env-pill"><span class="pill-dot" style="background:#22c55e;"></span>개발</span></td>
                  <td>카드-정산 (DEV)</td>
                  <td>PostgreSQL</td>
                  <td>CARD-SETTLE-DEV</td>
                  <td><span class="role-pill">읽기/쓰기 (DML)</span></td>
                  <td>별도 만료 없음</td>
                </tr>
                <tr data-env="DEV">
                  <td><span class="env-pill"><span class="pill-dot" style="background:#22c55e;"></span>개발</span></td>
                  <td>보험-보유계약 (DEV)</td>
                  <td>Oracle</td>
                  <td>LIFE-POLICY-DEV</td>
                  <td><span class="role-pill">읽기 전용</span></td>
                  <td>별도 만료 없음</td>
                </tr>
                <tr data-env="DEV">
                  <td><span class="env-pill"><span class="pill-dot" style="background:#22c55e;"></span>개발</span></td>
                  <td>공통-코드 (DEV)</td>
                  <td>PostgreSQL</td>
                  <td>COMMON-CODE-DEV</td>
                  <td><span class="role-pill">읽기/쓰기 (DML)</span></td>
                  <td>별도 만료 없음</td>
                </tr>
                <tr data-env="PROD">
                  <td><span class="env-pill prod"><span class="pill-dot" style="background:#f97373;"></span>운영</span></td>
                  <td>카드-정산 (PROD)</td>
                  <td>Oracle</td>
                  <td>CARD-SETTLE-PROD</td>
                  <td><span class="role-pill">읽기 전용</span></td>
                  <td>2026-12-31</td>
                </tr>
                <tr data-env="PROD">
                  <td><span class="env-pill prod"><span class="pill-dot" style="background:#f97373;"></span>운영</span></td>
                  <td>보험-보유계약 (PROD)</td>
                  <td>Oracle</td>
                  <td>LIFE-POLICY-PROD</td>
                  <td><span class="role-pill">읽기 전용</span></td>
                  <td>2025-12-31</td>
                </tr>
                <tr data-env="PROD">
                  <td><span class="env-pill prod"><span class="pill-dot" style="background:#f97373;"></span>운영</span></td>
                  <td>공통-코드 (PROD)</td>
                  <td>PostgreSQL</td>
                  <td>COMMON-CODE-PROD</td>
                  <td><span class="role-pill">읽기 전용</span></td>
                  <td>별도 만료 없음</td>
                </tr>
              </tbody>
            </table>
          </div>
          <div class="foot-hint">※ 실제 화면에서는 ITSM/권한 시스템과 연계해, 본인에게 부여된 DB 접근 권한만 표시됩니다.</div>
        </div>

        <!-- 신청/승인 현황 -->
        <div class="card" style="margin-top:10px;">
          <div class="card-header">
            <div>
              <div class="card-title">
                <span class="card-title-icon">AP</span>
                위험 쿼리 승인 신청 현황
              </div>
              <div class="card-desc">
                최근에 본인이 신청한 위험 쿼리 승인 요청의 상태를 간단히 보여줍니다.
              </div>

            </div>
            <div class="card-toolbar">
              <span class="tag-soft">최근 7일 기준</span>
            </div>
          </div>
          <div class="section-grid">
            <div>
              <div class="card-desc" style="margin-bottom:2px;">위험 쿼리 승인 요청</div>
              <table class="mini-table">
                <thead>
                  <tr>
                    <th style="width:90px;">신청 일시</th>
                    <th>대상</th>
                    <th style="width:70px;">상태</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td>11-27 14:05</td>
                    <td>운영-카드계 · 대량 UPDATE (사유: 정산 오류 수정)</td>
                    <td><span class="status-pill wait">승인 대기</span></td>
                  </tr>
                  <tr>
                    <td>11-26 13:22</td>
                    <td>DEV-공통 코드 일괄 UPDATE</td>
                    <td><span class="status-pill ok">승인 완료</span></td>
                  </tr>
                </tbody>
              </table>
            </div>
          </div>
          <div class="foot-hint">※ 자세한 내용은 "권한 신청 내역" / "쿼리 승인 요청 내역" 화면에서 조회할 수 있습니다.</div>
        </div>
      </section>
    </main>
  </div>

  

      <div class="myinfo-footer">
        <button type="button" onclick="if(window.ui&&typeof ui.closeMyInfoModal==='function'){ui.closeMyInfoModal();}">닫기</button>
      </div>
    </div>
  </div>

<!-- Excel 내보내기 감사/반출 통제 모달 -->
  <div id="exportAuditBackdrop" class="export-modal-backdrop" role="dialog" aria-modal="true" aria-hidden="true">
    <div class="export-modal">
      <h3><i class="fa-solid fa-file-export"></i> Excel 내보내기</h3>
      <div id="exportAuditMeta" class="meta"></div>
      <div id="exportAuditWarning" class="danger" style="display:none;"></div>
      <div class="field">
        <label for="exportReason">반출 사유 <span style="color:#d00">*</span></label>
        <textarea id="exportReason" placeholder="예: 월간 경영 리포트 작성용 집계"></textarea>
      </div>
      <div class="field" id="exportApprovalField" style="display:none;">
        <label for="exportApprovalId">관리자 승인 ID (대용량/예외 반출 시) <span style="color:#d00">*</span></label>
        <input id="exportApprovalId" type="text" style="width:100%;font-size:12px;padding:4px 6px;" />
      </div>
      <div class="btn-row">
        <button type="button" onclick="ui.closeExportAuditModal()">취소</button>
        <button type="button" onclick="ui.confirmExportAudit()" style="background:#2c7be5;color:#fff;border:none;border-radius:4px;">
          내보내기
        </button>
      </div>
    </div>
  </div>

  <!-- 쿼리 스냅샷 공유 모달 -->
  <div id="snapshotBackdrop" class="export-modal-backdrop" role="dialog" aria-modal="true" aria-hidden="true">
    <div class="export-modal">
      <h3><i class="fa-solid fa-link"></i> 쿼리 스냅샷 공유</h3>
      <div class="field">
        <label for="snapshotId">스냅샷 ID</label>
        <input id="snapshotId" type="text" readonly style="width:100%;font-size:12px;padding:4px 6px;background:#f9fafb;" />
      </div>
      <div class="field">
        <label for="snapshotJson">공유용 JSON</label>
        <textarea id="snapshotJson" readonly placeholder="스냅샷 JSON이 여기 표시됩니다."></textarea>
        <div class="muted" style="font-size:11px;margin-top:4px;">
          이 문자열을 메신저/메일로 전달하면 상대방이 붙여넣기로 동일한 스냅샷을 불러올 수 있습니다.
        </div>
      </div>
      <div class="btn-row">
        <button type="button" onclick="snapshots.closeModal()">닫기</button>
        <button type="button" onclick="snapshots.copyJson()" style="background:#00857C;color:#fff;border:none;border-radius:4px;">
          JSON 복사
        </button>
      </div>
    </div>
  </div>

  
  <!-- DB 커넥션 설정 모달 -->
  <div id="connSettingsBackdrop"
       class="export-modal-backdrop hidden"
       role="dialog"
       aria-modal="true"
       aria-hidden="true">
    <div class="export-modal conn-settings-modal">
      <div class="export-modal-header">
        <h2>
          <i class="fa-solid fa-gear"></i>
          <span style="margin-left:4px;">커넥션 설정</span>
        </h2>
        <button type="button"
                class="btn-icon conn-settings-close-btn"
                onclick="connSettings.close()"
                aria-label="닫기">
          <i class="fa-solid fa-xmark"></i>
        </button>
      </div>

      <div class="export-modal-body conn-settings-body">
        <form id="connSettingsForm">
          <input type="hidden" name="connId" id="connSettingsConnId" />

          <div class="conn-settings-grid">
            <!-- 좌측: 연결 기본 정보 -->
            <div>
              <div class="conn-settings-group">
                <label for="connSettingsName">연결 이름</label>
                <input type="text"
                       id="connSettingsName"
                       name="name"
                       class="conn-settings-input"
                       placeholder="예: 교보-카드 DEV" />
              </div>

              <div class="conn-settings-row" style="margin-top:6px;">
                <div class="conn-settings-group">
                  <label for="connSettingsEnv">환경 구분</label>
                  <select id="connSettingsEnv"
                          name="env"
                          class="conn-settings-select">
                    <option value="">선택</option>
                    <option value="DEV">개발</option>
                    <option value="PROD">운영</option>
                  </select>
                </div>
              </div>

              <div class="conn-settings-group" style="margin-top:6px;">
                <label for="connSettingsDesc">설명 (선택)</label>
                <textarea id="connSettingsDesc"
                          name="description"
                          class="conn-settings-input"
                          rows="2"
                          placeholder="연결/DB에 대한 간단한 설명을 입력하세요."></textarea>
              </div>
            </div>

            <!-- 우측: DB 접속 정보(계정 정보 제외) -->
            <div>
              <div class="conn-settings-row">
                <div class="conn-settings-group">
                  <label for="connSettingsDbType">DB 유형</label>
                  <select id="connSettingsDbType"
                          name="dbType"
                          class="conn-settings-select">
                    <option value="">선택</option>
                    <option value="POSTGRES">PostgreSQL</option>
                    <option value="ORACLE">Oracle</option>
                    <option value="MYSQL">MySQL/MariaDB</option>
                    <option value="MSSQL">MS SQL Server</option>
                    <option value="ETC">기타</option>
                  </select>
                </div>
                <div class="conn-settings-group">
                  <label for="connSettingsHost">Host</label>
                  <input type="text"
                         id="connSettingsHost"
                         name="host"
                         class="conn-settings-input"
                         placeholder="예: db-server01" />
                </div>
              </div>

              <div class="conn-settings-row" style="margin-top:6px;">
                <div class="conn-settings-group">
                  <label for="connSettingsPort">Port</label>
                  <input type="number"
                         id="connSettingsPort"
                         name="port"
                         class="conn-settings-input"
                         placeholder="예: 5432" />
                </div>
                <div class="conn-settings-group">
                  <label for="connSettingsDbName">DB / SID / Service</label>
                  <input type="text"
                         id="connSettingsDbName"
                         name="dbName"
                         class="conn-settings-input"
                         placeholder="예: coredb 또는 ORCL" />
                </div>
              </div>

              <div class="conn-settings-group" style="margin-top:6px;">
                <label for="connSettingsSchema">기본 스키마 (선택)</label>
                <input type="text"
                       id="connSettingsSchema"
                       name="schema"
                       class="conn-settings-input"
                       placeholder="예: public 또는 APP_USER" />
              </div>
            </div>
          </div>

          <div class="conn-settings-group" style="margin-top:8px;">
            <label for="connSettingsJdbcUrl">JDBC URL (참고용)</label>
            <input type="text"
                   id="connSettingsJdbcUrl"
                   name="jdbcUrl"
                   class="conn-settings-input"
                   readonly
                   placeholder="선택한 DB 유형/Host/Port/DB 기준으로 자동 생성 예정" />
          </div>
        </form>

        <div class="conn-settings-footer">
          <div class="conn-settings-footer-left">
            ※ 커넥션 설정에서는 ID/PW/MFA를 저장하지 않으며, 실제 연결 시에만 별도 입력받습니다.
          </div>
          <div class="conn-settings-footer-right">
            <button type="button"
                    class="btn"
                    onclick="connSettings.close()">
              닫기
            </button>
            <button type="button"
                    class="btn primary"
                    onclick="connSettings.save()">
              저장
            </button>
          </div>
        </div>
      </div>
    </div>
  </div>

<!-- DB 연결 정보 / 접속 사유 모달 -->
  <div id="connReasonBackdrop" class="export-modal-backdrop" role="dialog" aria-modal="true" aria-hidden="true">
    <div class="export-modal">
      <h3><i class="fa-solid fa-plug"></i> DB 연결 정보 / 접속 사유</h3>
      <div id="connReasonMeta" class="meta"></div>

      <div class="field">
        <label for="connUserInput">DB 사용자 ID <span style="color:#d00">*</span></label>
        <input id="connUserInput"
               type="text"
               style="width:100%;font-size:12px;padding:4px 6px;"
               autocomplete="username" />
      </div>
      <div class="field">
        <label for="connPasswordInput">비밀번호 <span style="color:#d00">*</span></label>
        <input id="connPasswordInput"
               type="password"
               style="width:100%;font-size:12px;padding:4px 6px;"
               autocomplete="current-password" />
      </div>
      <div class="field">
        <label for="connMfaInput">인증 코드 (MFA)</label>
        <div class="conn-settings-row">
          <button type="button"
                  class="btn"
                  id="connMfaSendBtn"
                  onclick="ui.sendConnMfaCode()">
            인증코드 발송
          </button>
          <input id="connMfaInput"
                 type="text"
                 class="conn-settings-input hidden"
                 style="font-size:12px;padding:4px 6px;"
                 autocomplete="one-time-code"
                 placeholder="발송된 일회용 인증 코드를 입력하세요." />
        </div>
      </div>

      <div class="field">
        <label for="connReasonInput">접속 사유 <span style="color:#d00">*</span></label>
        <textarea id="connReasonInput" placeholder="접속 사유를 입력하세요."></textarea>
      </div>
      <div class="field">
        <label for="connTicketInput">ITSM/작업요청 번호 (선택)</label>
        <input id="connTicketInput" type="text" style="width:100%;font-size:12px;padding:4px 6px;" />
      </div>
      <div class="btn-row">
        <button type="button" onclick="ui.cancelConnReason()">취소</button>
        <button type="button" onclick="ui.testConnReason()" style="border:1px solid #00857C;color:#00857C;background:#fff;border-radius:4px;">
          연결 테스트
        </button>
        <button type="button" onclick="ui.confirmConnReason()" style="background:#00857C;color:#fff;border:none;border-radius:4px;">
          연결
        </button>
      </div>
    </div>
  </div>


  
  
  
  <!-- 최근 쿼리 히스토리 사이드바 (현재 DB 기준) -->
  <div id="queryHistorySidebar" class="hidden" aria-hidden="true">
    <header>
      <div class="title-wrap">
        <h3><i class="fa-solid fa-clock-rotate-left"></i> 최근 쿼리 (현재 DB)</h3>
        <div id="qhSidebarMeta" class="muted"></div>
      </div>
      <button type="button" class="btn-icon" onclick="queryHistorySidebar.close()" aria-label="닫기">
        <i class="fa-solid fa-xmark"></i>
      </button>
    </header>
    <div class="body" id="qhSidebarBody">
      <div class="empty">현재 연결 기준 최근 실행 내역이 없습니다.</div>
    </div>
  </div>
<!-- 개인 SQL 서버 저장소 - 저장 모달 -->
  <div id="personalSqlSaveBackdrop" class="export-modal-backdrop hidden" role="dialog" aria-modal="true" aria-hidden="true">
    <div class="export-modal" style="max-width:820px;">
      <div class="export-modal-header">
        <h2>현재 탭 SQL 저장</h2>
        <button type="button" class="btn-icon" onclick="ui.closePersonalSqlSave()" aria-label="닫기">
          <i class="fa-solid fa-xmark"></i>
        </button>
      </div>
      <div class="export-modal-body">
        <div class="export-modal-grid">
          <div class="export-group">
            <label>저장 위치</label>
            <div class="export-input" style="background:#f9fafb;display:flex;gap:12px;align-items:center;">
              <label style="display:flex;align-items:center;gap:4px;">
                <input type="radio" name="psSaveTarget" value="server" checked>
                <span>서버 개인 저장소</span>
              </label>
              <label style="display:flex;align-items:center;gap:4px;">
                <input type="radio" name="psSaveTarget" value="file">
                <span>파일로 저장 (다운로드)</span>
              </label>
            </div>
          </div>
          <div class="export-group">
            <label for="psSaveTitle">저장 이름</label>
            <input type="text" id="psSaveTitle" class="export-input" placeholder="예: 2025-11-24 카드 마스터 점검 쿼리">
          </div>
          <div class="export-group">
            <label for="psSaveDesc">설명 (선택)</label>
            <textarea id="psSaveDesc" class="export-input" rows="2" placeholder="간단한 설명을 입력하세요."></textarea>
          </div>
          <div class="export-group">
            <label>대상 탭</label>
            <div id="psSaveInfo" class="export-input" style="background:#f3f4f6;"></div>
          </div>
          <div class="export-group">
            <label>SQL 미리보기 (상위 일부)</label>
            <pre id="psSavePreview" class="export-input" style="min-height:120px;max-height:200px;overflow:auto;white-space:pre-wrap;"></pre>
          </div>
          <p class="muted" style="margin-top:4px;">
            ※ 서버 개인 저장소 연동 전으로, '서버 개인 저장소' 저장은 UI까지만 구현된 상태입니다. (실제 저장은 백엔드 연동 후 적용)
          </p>
        </div>
      </div>
      <div style="border-top:1px solid #e5e7eb; padding:8px 12px; display:flex; justify-content:flex-end; gap:8px;">
        <button type="button" class="btn" onclick="ui.closePersonalSqlSave()">닫기</button>
        <button type="button" class="btn primary" onclick="ui.confirmPersonalSqlSave()">저장</button>
      </div>
    </div>
  </div>

  <!-- 개인 SQL 서버 저장소 - 불러오기 모달 -->
  <div id="personalSqlLoadBackdrop" class="export-modal-backdrop hidden" role="dialog" aria-modal="true" aria-hidden="true">
    <div class="export-modal" style="max-width:720px;">
      <div class="export-modal-header">
        <h2>개인 SQL 저장소 - SQL 불러오기</h2>
        <button type="button" class="btn-icon" onclick="ui.closePersonalSqlLoad()" aria-label="닫기">
          <i class="fa-solid fa-xmark"></i>
        </button>
      </div>
      <div class="export-modal-body">
        <p class="muted" style="margin-bottom:8px;">
          서버 개인 저장소에 저장된 SQL 목록이 이 영역에 표시될 예정입니다. (현재는 더미 UI 상태)
        </p>
        <div style="border:1px solid #e5e7eb;border-radius:8px;overflow:hidden;max-height:260px;">
          <table style="width:100%;border-collapse:collapse;font-size:12px;">
            <thead style="background:#f9fafb;">
              <tr>
                <th style="border-bottom:1px solid #e5e7eb;padding:6px 8px;text-align:left;width:40px;">선택</th>
                <th style="border-bottom:1px solid #e5e7eb;padding:6px 8px;text-align:left;">이름</th>
                <th style="border-bottom:1px solid #e5e7eb;padding:6px 8px;text-align:left;width:180px;">저장일시</th>
                <th style="border-bottom:1px solid #e5e7eb;padding:6px 8px;text-align:left;width:200px;">비고</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td style="border-top:1px solid #e5e7eb;padding:6px 8px;text-align:center;">
                  <input type="radio" name="psLoadSelect" disabled>
                </td>
                <td style="border-top:1px solid #e5e7eb;padding:6px 8px;color:#9ca3af;">
                  (서버 연동 후 목록이 표시됩니다)
                </td>
                <td style="border-top:1px solid #e5e7eb;padding:6px 8px;color:#9ca3af;">-</td>
                <td style="border-top:1px solid #e5e7eb;padding:6px 8px;color:#9ca3af;">UI만 우선 구현</td>
              </tr>
            </tbody>
          </table>
        </div>
      </div>
      <div style="border-top:1px solid #e5e7eb; padding:8px 12px; display:flex; justify-content:flex-end; gap:8px;">
        <button type="button" class="btn primary" onclick="ui.applyPersonalSqlLoad()">선택 SQL 불러오기</button>
      </div>
    </div>
  </div>


  <!-- 단축키 / 스니펫 안내 모달 -->
  <div id="shortcutHelpBackdrop"
       class="export-modal-backdrop hidden"
       role="dialog"
       aria-modal="true"
       aria-hidden="true">
    <div class="export-modal" style="max-width:980px;width:980px;">
      <div class="export-modal-header">
        <h2>
          <i class="fa-solid fa-circle-question"></i>
          <span style="margin-left:4px;">단축키 / 스니펫 안내</span>
        </h2>
        <button type="button"
                class="btn-icon"
                onclick="ui.closeShortcutHelpModal()"
                aria-label="닫기">
          <i class="fa-solid fa-xmark"></i>
        </button>
      </div>

      <div class="export-modal-body">
        <p class="muted" style="margin-bottom:8px;">
          SQL 에디터에서 자주 사용하는 단축키와 스니펫 요약입니다.
        </p>

        <div style="display:flex;gap:16px;flex-wrap:wrap;">
          <!-- 단축키 영역 -->
          <div style="flex:1 1 260px;min-width:260px;">
            <h3 style="font-size:13px;margin-bottom:4px;">단축키</h3>
            <table style="width:100%;border-collapse:collapse;font-size:12px;">
              <tbody>
                <tr>
                  <td style="padding:4px 6px;width:150px;font-family:monospace;">Ctrl + Enter</td>
                  <td style="padding:4px 6px;">선택/커서 기준 쿼리 실행</td>
                </tr>
                <tr>
                  <td style="padding:4px 6px;font-family:monospace;">Ctrl + Shift + Enter</td>
                  <td style="padding:4px 6px;">전체 스크립트 실행</td>
                </tr>
                <tr>
                  <td style="padding:4px 6px;font-family:monospace;">Ctrl + Shift + F</td>
                  <td style="padding:4px 6px;">SQL 서식 정리</td>
                </tr>
                <tr>
                  <td style="padding:4px 6px;font-family:monospace;">Ctrl + Space</td>
                  <td style="padding:4px 6px;">자동완성 (테이블 / 컬럼)</td>
                </tr>
                <tr>
                  <td style="padding:4px 6px;font-family:monospace;">Esc</td>
                  <td style="padding:4px 6px;">컨텍스트 메뉴 / 모달 닫기</td>
                </tr>
                <tr>
                  <td style="padding:4px 6px;font-family:monospace;">Alt + Drag</td>
                  <td style="padding:4px 6px;">여러 줄 열 선택 / 멀티 커서 편집</td>
                </tr>
                <tr>
                  <td style="padding:4px 6px;font-family:monospace;">Ctrl + /</td>
                  <td style="padding:4px 6px;">선택 영역 주석/해제</td>
                </tr>
                <tr>
                  <td style="padding:4px 6px;font-family:monospace;">Ctrl + .</td>
                  <td style="padding:4px 6px;">코드 액션 메뉴 열기 (IN 리스트 변환 / 주석 / 선택 실행)</td>
                </tr>
              </tbody>
            </table>
          </div>

          <!-- 스니펫 영역 -->
          <div style="flex:1 1 220px;min-width:220px;">
            <h3 style="font-size:13px;margin-bottom:4px;">스니펫 예시</h3>
            <table style="width:100%;border-collapse:collapse;font-size:12px;">
              <tbody>
                <tr>
                  <td style="padding:4px 6px;width:120px;font-family:monospace;">sel + Tab</td>
                  <td style="padding:4px 6px;white-space:nowrap;">SELECT * FROM ...;</td>
                </tr>
                <tr>
                  <td style="padding:4px 6px;font-family:monospace;">sel1 + Tab</td>
                  <td style="padding:4px 6px;white-space:nowrap;">SELECT 1 FROM ...;</td>
                </tr>
                <tr>
                  <td style="padding:4px 6px;font-family:monospace;">ins + Tab</td>
                  <td style="padding:4px 6px;white-space:nowrap;">INSERT INTO ... VALUES ...;</td>
                </tr>
                <tr>
                  <td style="padding:4px 6px;font-family:monospace;">upd + Tab</td>
                  <td style="padding:4px 6px;white-space:nowrap;">UPDATE ... SET ... WHERE ...;</td>
                </tr>
                <tr>
                  <td style="padding:4px 6px;font-family:monospace;">del + Tab</td>
                  <td style="padding:4px 6px;white-space:nowrap;">DELETE FROM ... WHERE ...;</td>
                </tr>
              </tbody>
            </table>
            <p class="muted" style="margin-top:4px;">
              에디터에서 단축 키워드를 입력한 뒤 <span style="font-family:monospace;">Tab</span> 키를 누르면
              스니펫이 확장됩니다.
            </p>
          </div>
        </div>
      </div>

      <div style="border-top:1px solid #e5e7eb; padding:8px 12px; display:flex; justify-content:flex-end; gap:8px;">
        <button type="button" class="btn" onclick="ui.closeShortcutHelpModal()">닫기</button>
      </div>
    </div>
  </div>


  
  <!-- 즐겨찾기 / 템플릿 저장 모달 (프로토타입) -->
  <div id="favSaveBackdrop"
       class="export-modal-backdrop hidden"
       role="dialog"
       aria-modal="true"
       aria-hidden="true">
    <div class="export-modal" style="max-width:640px;">
      <div class="export-modal-header">
        <h2>
          <i class="fa-solid fa-star"></i>
          <span style="margin-left:4px;">즐겨찾기 / 템플릿 저장</span>
        </h2>
        <button type="button"
                class="btn-icon"
                onclick="ui.closeFavSaveModal()"
                aria-label="닫기">
          <i class="fa-solid fa-xmark"></i>
        </button>
      </div>

      <div class="export-modal-body">
        <p class="muted" style="margin-bottom:8px;">
          현재 활성 SQL 탭의 내용을 개인 즐겨찾기 또는 조직 공용 템플릿으로 저장합니다. (서버 연동 전, 프로토타입)
        </p>

        <div style="display:flex; flex-direction:column; gap:8px;">
          <div>
            <label style="font-weight:bold; margin-right:8px;">저장 대상</label>
            <label style="margin-right:12px;">
              <input type="radio" name="favSaveType" value="PERSONAL" checked>
              개인 즐겨찾기
            </label>
            <label>
              <input type="radio" name="favSaveType" value="ORG">
              조직 공용 템플릿
            </label>
          </div>

          <div>
            <label style="display:block; font-weight:bold; margin-bottom:2px;">
              제목
            </label>
            <input type="text" id="favSaveName" style="width:100%;" maxlength="100" />
          </div>

          <div>
            <label style="display:block; font-weight:bold; margin-bottom:2px;">
              설명
            </label>
            <textarea id="favSaveDesc" rows="2" style="width:100%;"></textarea>
          </div>

          <div style="display:flex; flex-wrap:wrap; gap:12px;">
            <div style="flex:1 1 140px;">
              <label style="display:block; font-weight:bold; margin-bottom:2px;">카테고리</label>
              <select id="favSaveCategory" style="width:100%;">
                <option value="MONITOR">모니터링</option>
                <option value="HISTORY">이력</option>
                <option value="BATCH">배치</option>
                <option value="ETC" selected>기타</option>
              </select>
            </div>
            <div style="flex:1 1 140px;">
              <label style="display:block; font-weight:bold; margin-bottom:2px;">업무명</label>
              <select id="favSaveBiz" style="width:100%;">
                <option value="MSG">메신저</option>
                <option value="PORTAL">포탈</option>
                <option value="COMMON" selected>공통</option>
                <option value="ETC">기타</option>
              </select>
            </div>
          </div>

          <div style="display:flex; flex-wrap:wrap; gap:12px;">
            <div style="flex:1 1 140px;" data-favsave-orgonly="true">
              <label style="display:block; font-weight:bold; margin-bottom:2px;">대상 시스템</label>
              <select id="favSaveTargetSys" style="width:100%;">
                <option value="">선택</option>
                <option value="DEV">DEV</option>
                <option value="STG">STG</option>
                <option value="PRD">PRD</option>
              </select>
            </div>
            <div style="flex:1 1 160px;" data-favsave-orgonly="true">
              <label style="display:block; font-weight:bold; margin-bottom:2px;">대상 DB</label>
              <input type="text" id="favSaveTargetDb" style="width:100%;" />
            </div>
          </div>

          <div>
            <label style="display:block; font-weight:bold; margin-bottom:2px;">태그 (쉼표로 구분)</label>
            <input type="text" id="favSaveTags" style="width:100%;" placeholder="monitor,session,lock" />
          </div>

          <div>
            <label style="display:block; font-weight:bold; margin-bottom:2px;">저장될 SQL 미리보기</label>
            <textarea id="favSaveSqlPreview" rows="6" style="width:100%;"></textarea>
          </div>
        </div>
      </div>

      <div style="border-top:1px solid #e5e7eb; padding:8px 12px; display:flex; justify-content:flex-end; gap:8px;">
        <button type="button" class="btn" onclick="ui.closeFavSaveModal()">취소</button>
        <button type="button" class="btn primary" onclick="ui.applyFavSaveModal()">저장</button>
      </div>
    </div>
  </div>


<!-- 테이블 편집 모달 (DBeaver 스타일 간단 버전) -->
  <div id="tableEditBackdrop"
       class="export-modal-backdrop hidden"
       role="dialog"
       aria-modal="true"
       aria-hidden="true">
    <div class="export-modal table-edit-modal">
      <div class="export-modal-header">
        <h2>
          <i class="fa-solid fa-table"></i>
          <span style="margin-left:4px;">테이블 편집</span>
        </h2>
        <button type="button"
                class="btn-icon table-edit-close-btn"
                onclick="tableEditor.close()"
                aria-label="닫기">
          <i class="fa-solid fa-xmark"></i>
        </button>
      </div>

      <div class="export-modal-body table-edit-body">
        <!-- 상단 테이블 정보 -->
        <div class="te-header">
          <div class="te-table-name" id="teTableTitle">SCHEMA.TABLE</div>
          <div class="te-table-meta" id="teTableMeta"></div>
        </div>

        <!-- 1단 탭: Properties / Data / ER Diagram -->
        <div class="te-tabs" role="tablist">
          <button type="button"
                  class="te-tab-btn active"
                  data-main-tab="props"
                  onclick="tableEditor.activateMainTab('props')">
            Properties
          </button>
          <button type="button"
                  class="te-tab-btn"
                  data-main-tab="data"
                  onclick="tableEditor.activateMainTab('data')">
            Data
          </button>
          <button type="button"
                  class="te-tab-btn"
                  data-main-tab="erd"
                  onclick="tableEditor.activateMainTab('erd')">
            ER Diagram
          </button>
        </div>

        <div class="te-main-panes">
          <!-- Properties 탭 -->
          <div id="tePaneProps" class="te-pane active" data-main-pane="props">
            <!-- 2단 서브탭 -->
            <div class="te-subtabs" role="tablist">
              <button type="button" class="te-subtab-btn active"
                      data-sub-tab="columns"
                      onclick="tableEditor.activateSubTab('columns')">
                Columns
              </button>
              <button type="button" class="te-subtab-btn"
                      data-sub-tab="constraints"
                      onclick="tableEditor.activateSubTab('constraints')">
                Constraints
              </button>
              <button type="button" class="te-subtab-btn"
                      data-sub-tab="fks"
                      onclick="tableEditor.activateSubTab('fks')">
                Foreign Keys
              </button>
              <button type="button" class="te-subtab-btn"
                      data-sub-tab="indexes"
                      onclick="tableEditor.activateSubTab('indexes')">
                Indexes
              </button>
              <button type="button" class="te-subtab-btn"
                      data-sub-tab="deps"
                      onclick="tableEditor.activateSubTab('deps')">
                Dependencies
              </button>
              <button type="button" class="te-subtab-btn"
                      data-sub-tab="refs"
                      onclick="tableEditor.activateSubTab('refs')">
                References
              </button>
              <button type="button" class="te-subtab-btn"
                      data-sub-tab="parts"
                      onclick="tableEditor.activateSubTab('parts')">
                Partitions
              </button>
              <button type="button" class="te-subtab-btn"
                      data-sub-tab="triggers"
                      onclick="tableEditor.activateSubTab('triggers')">
                Triggers
              </button>
              <button type="button" class="te-subtab-btn"
                      data-sub-tab="rules"
                      onclick="tableEditor.activateSubTab('rules')">
                Rules
              </button>
              <button type="button" class="te-subtab-btn"
                      data-sub-tab="stats"
                      onclick="tableEditor.activateSubTab('stats')">
                Statistics
              </button>
              <button type="button" class="te-subtab-btn"
                      data-sub-tab="perms"
                      onclick="tableEditor.activateSubTab('perms')">
                Permissions
              </button>
              <button type="button" class="te-subtab-btn"
                      data-sub-tab="ddl"
                      onclick="tableEditor.activateSubTab('ddl')">
                DDL
              </button>
            </div>

            <!-- Columns 서브패널 -->
            <div class="te-subpane active" data-sub-pane="columns">
              <div class="te-table-wrapper">
                <table class="grid te-grid" id="teColumnsGrid">
                  <thead>
                    <tr>
                      <th>#</th>
                      <th>Column</th>
                      <th>Type</th>
                      <th>Nullable</th>
                      <th>Default</th>
                      <th>Comment</th>
                    </tr>
                  </thead>
                  <tbody>
                    <!-- JS로 채움 -->
                  </tbody>
                </table>
              </div>
              <p class="muted" style="margin-top:4px;font-size:11px;">
                ※ 현재는 SQL 힌트 테이블에 있는 컬럼 정보만 사용하며,
                실제 DB 메타데이터 연동은 백엔드 구현 후 적용됩니다.
              </p>
            </div>

            <!-- 나머지 서브패널: 일단 플레이스홀더 -->
            <div class="te-subpane" data-sub-pane="constraints">
              <div class="te-placeholder">Constraints 정보는 추후 DB 메타데이터 연동 시 채워집니다.</div>
            </div>
            <div class="te-subpane" data-sub-pane="fks">
              <div class="te-placeholder">Foreign Keys 정보는 추후 DB 메타데이터 연동 시 채워집니다.</div>
            </div>
            <div class="te-subpane" data-sub-pane="indexes">
              <div class="te-placeholder">Indexes 정보는 추후 DB 메타데이터 연동 시 채워집니다.</div>
            </div>
            <div class="te-subpane" data-sub-pane="deps">
              <div class="te-placeholder">Dependencies 정보는 추후 DB 메타데이터 연동 시 채워집니다.</div>
            </div>
            <div class="te-subpane" data-sub-pane="refs">
              <div class="te-placeholder">References 정보는 추후 DB 메타데이터 연동 시 채워집니다.</div>
            </div>
            <div class="te-subpane" data-sub-pane="parts">
              <div class="te-placeholder">Partitions 정보는 추후 DB 메타데이터 연동 시 채워집니다.</div>
            </div>
            <div class="te-subpane" data-sub-pane="triggers">
              <div class="te-placeholder">Triggers 정보는 추후 DB 메타데이터 연동 시 채워집니다.</div>
            </div>
            <div class="te-subpane" data-sub-pane="rules">
              <div class="te-placeholder">Rules 정보는 추후 DB 메타데이터 연동 시 채워집니다.</div>
            </div>
            <div class="te-subpane" data-sub-pane="stats">
              <div class="te-placeholder">Statistics 정보는 추후 DB 메타데이터 연동 시 채워집니다.</div>
            </div>
            <div class="te-subpane" data-sub-pane="perms">
              <div class="te-placeholder">Permissions 정보는 추후 DB 메타데이터 연동 시 채워집니다.</div>
            </div>
            <div class="te-subpane" data-sub-pane="ddl">
              <pre id="teDdlText" class="te-ddl"></pre>
            </div>
          </div>

          <!-- Data 탭 -->
          <div id="tePaneData" class="te-pane" data-main-pane="data">
            <div class="te-table-wrapper">
              <table class="grid te-grid" id="teDataGrid">
                <thead>
                  <tr>
                    <th>데이터 조회는 추후 SQL 실행엔진 연동 시 구현 예정입니다.</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td>예: SELECT * FROM SCHEMA.TABLE FETCH FIRST 100 ROWS ONLY</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <p class="muted" style="margin-top:4px;font-size:11px;">
              ※ 현재는 데모 메시지만 표시하며, 실제 데이터 조회는 에디터의 SQL 실행과 연동해서 구현해야 합니다.
            </p>
          </div>

          <!-- ER Diagram 탭 (UI만) -->
          <div id="tePaneErd" class="te-pane" data-main-pane="erd">
            <div class="te-placeholder">
              ER Diagram 탭은 아직 구현되지 않았습니다. (레이아웃만 준비)
            </div>
          </div>
        </div>
      </div>

      <div class="export-modal-footer"
           style="border-top:1px solid #e5e7eb;padding:8px 12px;display:flex;justify-content:flex-end;gap:8px;">
        <button type="button" class="btn" onclick="tableEditor.close()">닫기</button>
      </div>
    </div>
  </div>

<!-- 내 설정 모달 (관리 콘솔 스타일) -->
  <div id="passwordChangeBackdrop"
       class="export-modal-backdrop hidden"
       role="dialog" aria-modal="true" aria-hidden="true">
    <div class="export-modal" style="max-width: 420px;">
      <div style="display:flex; align-items:center; justify-content:space-between; border-bottom:1px solid #e5e7eb; padding:10px 12px;">
        <div style="display:flex; align-items:center; gap:8px;">
          <div style="width:28px; height:28px; border-radius:50%; background:rgba(0,132,133,0.06); display:flex; align-items:center; justify-content:center; color:var(--hana-primary,#008485);">
            <i class="fa-solid fa-key"></i>
          </div>
          <div>
            <div style="font-size:14px; font-weight:600; color:var(--ink,#111827);">비밀번호 변경</div>
            <div style="font-size:11px; color:#6b7280; margin-top:2px;">현재 비밀번호 확인 후 새 비밀번호를 설정합니다.</div>
          </div>
        </div>
        <button type="button"
                style="border:none; background:transparent; cursor:pointer; padding:2px; color:#6b7280;"
                onclick="closePasswordChangeModal()"
                aria-label="닫기">
          <i class="fa-solid fa-xmark"></i>
        </button>
      </div>

      <div style="padding:12px 14px 10px 14px; font-size:12px;">
        <div style="margin-bottom:8px; color:#6b7280;">
          데모 UI 상태이며 실제 비밀번호 변경은 서버 API 연동 후 적용됩니다.
        </div>

        <div class="export-group" style="margin-bottom:8px;">
          <label for="pcCurrentPwd" style="display:block; margin-bottom:3px;">현재 비밀번호</label>
          <input type="password"
                 id="pcCurrentPwd"
                 class="export-input"
                 autocomplete="off"
                 style="width:100%; box-sizing:border-box;">
        </div>

        <div class="export-group" style="margin-bottom:8px;">
          <label for="pcNewPwd" style="display:block; margin-bottom:3px;">새 비밀번호</label>
          <input type="password"
                 id="pcNewPwd"
                 class="export-input"
                 autocomplete="off"
                 style="width:100%; box-sizing:border-box;">
        </div>

        <div class="export-group" style="margin-bottom:4px;">
          <label for="pcNewPwdConfirm" style="display:block; margin-bottom:3px;">새 비밀번호 확인</label>
          <input type="password"
                 id="pcNewPwdConfirm"
                 class="export-input"
                 autocomplete="off"
                 style="width:100%; box-sizing:border-box;">
        </div>

        <div style="font-size:11px; color:#9ca3af; margin-top:2px;">
          ※ 실제 비밀번호 규칙(길이/조합 등)은 시스템 정책에 따라 검증합니다.
        </div>
      </div>

      <div class="export-modal-footer" style="border-top:1px solid #e5e7eb; padding:8px 12px; display:flex; justify-content:flex-end; gap:8px;">
        <button type="button" class="btn" onclick="closePasswordChangeModal()">취소</button>
        <button type="button" class="btn primary" onclick="confirmPasswordChange()">변경</button>
      </div>
    </div>
  </div>


  <!-- 부재중 & 대결자 관리 모달 -->
  <div id="absenceModalBackdrop" class="modal-backdrop" aria-hidden="true">
    <div class="modal" role="dialog" aria-modal="true" aria-labelledby="absenceModalTitle">
      <div class="modal-header">
        <div class="modal-title" id="absenceModalTitle">부재중 &amp; 대결자 관리</div>
        <button type="button" class="modal-close-btn" id="absenceModalCloseBtn" aria-label="닫기">×</button>
      </div>
      <div class="modal-body">
        <!-- 탭 헤더 -->
        <div class="tab-header">
          <button type="button" class="tab-btn active" data-tab="form">부재 설정</button>
          <button type="button" class="tab-btn" data-tab="history">이력</button>
        </div>

        <!-- 현재 상태 카드 -->
        <div id="currentStatusCard" class="status-card inactive">
          <div>
            <div class="status-chip expired" id="currentStatusChip">부재 설정 없음</div>
            <div class="status-meta" id="currentStatusText">
              현재 부재/대결자 설정이 없습니다.
            </div>
            <div class="helper-text" id="currentStatusSubText">
              부재 기간과 대결자를 등록하면, 지정된 기간 동안 결재 권한이 대결자에게 위임됩니다.
            </div>
          </div>
          <div class="status-actions">
            <button type="button" class="btn btn-outline btn-sm" id="btnCurrentEnd" disabled>지금 해제</button>
            <button type="button" class="btn btn-ghost btn-sm" id="btnCurrentExtend" disabled>기간 연장</button>
          </div>
        </div>

        <!-- 탭 패널: 부재 설정 -->
        <div id="tab-form" class="tab-panel active">
          <div class="form-section">
            <div class="form-grid">
              <div class="form-group">
                <label class="form-label" for="absenceType">
                  부재 유형<span class="req">*</span>
                </label>
                <select id="absenceType" class="form-select">
                  <option value="연차">연차</option>
                  <option value="반차">반차</option>
                  <option value="출장">출장</option>
                  <option value="기타">기타</option>
                </select>
                <div class="helper-text">
                  연차/출장 등 부재 사유를 선택하세요.
                </div>
              </div>
              <div class="form-group">
                <label class="form-label">
                  부재 기간<span class="req">*</span>
                </label>
                <div class="inline-row">
                  <input type="datetime-local" id="startDate" class="form-control" />
                  <span style="font-size:12px;">~</span>
                  <input type="datetime-local" id="endDate" class="form-control" />
                </div>
                <div id="dateError" class="error-text" style="display:none;"></div>
              </div>
              <div class="form-group">
                <label class="form-label">
                  대결자<span class="req">*</span>
                </label>
                <div class="inline-row">
                  <input type="text" id="delegateName" class="form-control" placeholder="대결자는 [찾기] 버튼으로만 선택 가능합니다" readonly />
                  <button type="button" class="btn btn-outline btn-sm" id="btnSearchDelegate">찾기</button>
                </div>
                <div class="helper-text">
                  조직도에서 [찾기] 버튼을 눌러 대결자를 선택하세요.
                </div>
                <div id="delegateError" class="error-text" style="display:none;"></div>
              </div>
            </div>
          </div>

          <div class="form-section">
            <div class="form-grid">
              <div class="form-group">
                <label class="form-label">알림 설정</label>
                <div class="checkbox-group">
                  <label class="checkbox-item">
                    <input type="checkbox" id="notifyDelegate" checked /> 대결자에게 알림 보내기
                  </label>
                  <label class="checkbox-item">
                    <input type="checkbox" id="notifyMe" /> 나에게도 알림 사본 보내기
                  </label>
                </div>
                <div class="helper-text">
                  실제 시스템에서는 메일/메신저/알림센터 등과 연계할 수 있습니다.
                </div>
              </div>

              <div class="form-group form-group-wide">
                <label class="form-label">사유</label>
                <textarea id="reason" class="form-textarea" placeholder="예) 12/10~12/12 연차로 인한 결재 대행 요청"></textarea>
              </div>
            </div>
          </div>

          <div class="form-section">
            <div class="form-group" style="margin-top:4px;">
              <label class="form-label">빠른 기간 설정</label>
              <div class="quick-buttons">
                <button type="button" class="btn btn-outline btn-sm" data-quick="today">오늘 하루</button>
                <button type="button" class="btn btn-outline btn-sm" data-quick="tomorrow">내일 하루</button>
                <button type="button" class="btn btn-outline btn-sm" data-quick="thisWeek">이번 주까지</button>
              </div>
            </div>
          </div>
        </div>

        <!-- 탭 패널: 이력 -->
        <div id="tab-history" class="tab-panel">
          <div style="margin-bottom:6px;font-size:12px;color:#4b5563;">
            최근 등록된 부재/대결자 설정 목록입니다. 상태, 종료 유형 등을 통해 실제 적용 이력을 확인할 수 있습니다.
          </div>
          <div id="historyEmpty" class="empty-text">
            등록된 부재/대결자 이력이 없습니다.
          </div>
          <div id="historyTableWrapper" style="display:none;">
            <table>
              <thead>
                <tr>
                  <th style="width:80px;text-align:center;">상태</th>
                  <th style="width:210px;text-align:center;">부재 기간</th>
                  <th style="width:110px;text-align:center;">대결자</th>
                  <th style="width:160px;text-align:center;">사유</th>
                  <th style="width:90px;text-align:center;">종료 유형</th>
                  <th style="width:120px;text-align:center;">조작</th>
                </tr>
              </thead>
              <tbody id="historyTbody">
              </tbody>
            </table>
          </div>
        </div>

      </div>
      <div class="modal-footer">
        <div class="helper-text">
          저장 후 즉시 적용되며, 지정된 기간이 지나면 자동으로 해제됩니다.
        </div>
        <div class="right">
          <button type="button" class="btn btn-ghost" id="absenceModalCancelBtn">취소</button>
          <button type="button" class="btn btn-primary" id="absenceModalSaveBtn">저장</button>
        </div>
      </div>
    </div>
  </div>

  

  <div id="mySettingsBackdrop"
       class="export-modal-backdrop hidden"
       role="dialog" aria-modal="true" aria-hidden="true">
    <div class="export-modal" style="max-width: 960px; padding: 0;">
      <div style="display:flex; border-bottom:1px solid #e5e7eb; padding:14px 16px 10px 16px; align-items:center; gap:10px;">
        <div style="width:32px; height:32px; border-radius:50%; background:var(--hana-primary-soft,#e2f3f0); display:flex; align-items:center; justify-content:center; color:var(--hana-primary,#008485);">
          <i class="fa-solid fa-user-gear"></i>
        </div>
        <div style="flex:1;">
          <div style="font-size:15px; font-weight:600; color:var(--ink,#111827);">내 설정</div>
          <div style="font-size:12px; color:#6b7280; margin-top:2px;">알림·MFA, 부재중 대결자, 기타 기본값을 한 번에 관리합니다.</div>
        </div>
      </div>

      
      <div style="min-height:320px;">
        <section style="padding:14px 16px 12px 16px; font-size:12px;">

            <div class="admin-card" style="margin-bottom:10px;">
              <div style="font-weight:600; margin-bottom:4px; display:flex; align-items:center; gap:6px;">
                <i class="fa-solid fa-bell"></i>
                <span>알림 채널 / MFA</span>
              </div>
              <div style="font-size:11px; color:#6b7280; margin-bottom:8px;">
                승인 알림, 경고 알림, MFA 인증 코드를 어떤 채널로 받을지 선택합니다.
              </div>
              <div style="display:flex; flex-wrap:wrap; gap:10px;">
                <label style="display:flex; align-items:center; gap:4px;">
                  <input type="radio" name="msNotifyChannel" id="msNotifyChannelMail" value="MAIL" checked> 이메일
                </label>
                <label style="display:flex; align-items:center; gap:4px;">
                  <input type="radio" name="msNotifyChannel" id="msNotifyChannelMessenger" value="MESSENGER"> 메신저
                </label>
                <label style="display:flex; align-items:center; gap:4px;">
                  <input type="radio" name="msNotifyChannel" id="msNotifyChannelBoth" value="MAIL_MESSENGER"> 이메일+메신저
                </label>
              </div>
              <div style="margin-top:8px; font-size:11px; color:#6b7280;">
                ※ 실제 발송 채널은 조직 보안 정책에 따라 제한될 수 있습니다.
              </div>
            </div>

            
          

            <div class="admin-card">
              <div style="font-weight:600; margin-bottom:4px; display:flex; align-items:center; gap:6px;">
                <i class="fa-solid fa-sliders"></i>
                <span>기타 기본값</span>
              </div>
              <div style="font-size:11px; color:#6b7280; margin-bottom:8px;">
                개인별로 선호하는 기본 적용값을 설정합니다. (예: 기본 쿼리 타임아웃, SQL 서식 정리 등)
              </div>
              <div style="display:flex; flex-direction:column; gap:8px; max-width:380px;">
                
                <div>
                  <label style="display:block; font-weight:600; margin-bottom:4px;">기본 쿼리 타임아웃(초)</label>
                  <input type="number" id="msDefaultTimeout" class="export-input" min="0" step="1" placeholder="예: 60">
                </div>
                <div>
                  <label style="display:block; font-weight:600; margin-bottom:4px;">SQL 서식 정리</label>
                  <label style="display:flex; align-items:center; gap:6px; font-size:12px; color:#4b5563;">
                    <input type="checkbox" id="msFormatBreakLines">
                    <span>예약어/콤마 기준으로 줄바꿈 적용 (SQL Developer 형식 유사)</span>
                  </label>
                  <label style="display:flex; align-items:center; gap:6px; font-size:12px; color:#4b5563; margin-top:4px;">
                    <input type="checkbox" id="msFormatUpperAll">
                    <span>예약어 외 컬럼/조건 등 식별자도 대문자로 변환</span>
                  </label>
                </div>
                <div style="margin-top:6px;">
                  <label style="display:block; font-weight:600; margin-bottom:4px;">에디터 자동 임시저장</label>
                  <label style="display:flex; align-items:center; gap:6px; font-size:12px; color:#4b5563;">
                    <input type="checkbox" id="msAutoSaveEditor">
                    <span style="white-space:nowrap;">에디터 내용을 브라우저에 자동 임시저장 (세션 타임아웃/창닫힘 대비)</span>
                  </label>
                  <div style="margin-top:4px; display:flex; align-items:center; gap:6px; font-size:12px; color:#4b5563;">
                    <span>주기(초)</span>
                    <input type="number" id="msAutoSaveInterval" class="export-input" min="3" step="1" style="width:70px;" placeholder="예: 5">
                  </div>
                </div>
              </div>
            </div>
          
        </section>
      </div>

      <div style="border-top:1px solid #e5e7eb; padding:8px 12px; display:flex; justify-content:flex-end; gap:8px;">
        <button type="button" class="btn" onclick="closeMySettings()">닫기</button>
        <button type="button" class="btn primary" onclick="saveMySettings()">저장</button>
      </div>
    </div>
  </div>

  <script>

    function openDelegateSettingsModal() {
      var el = document.getElementById('delegateSettingsBackdrop');
      if (!el) return;
      el.classList.remove('hidden');
      el.classList.add('show');
      el.setAttribute('aria-hidden','false');
    }

    function closeDelegateSettingsModal() {
      var el = document.getElementById('delegateSettingsBackdrop');
      if (!el) return;
      el.classList.remove('show');
      el.classList.add('hidden');
      el.setAttribute('aria-hidden','true');
    }

    function saveDelegateSettings() {
      // TODO: 서버 연동 시 실제 저장 로직 추가
      alert('부재중 / 대결자 설정은 데모 상태입니다.\n실제 저장은 서버 연동 후 구현해야 합니다.');
      closeDelegateSettingsModal();
    }

    function openMySettings() {
      var el = document.getElementById('mySettingsBackdrop');
      if (!el) return;
      // 현재 state 값으로 기본 타임아웃 및 서식 옵션 초기화
      try {
        var t = document.getElementById('msDefaultTimeout');
        if (t && typeof state !== 'undefined') {
          var ms = state.queryTimeoutMs || 15000;
          t.value = Math.round(ms / 1000);
        }
        var f = document.getElementById('msFormatBreakLines');
        if (f && typeof state !== 'undefined') {
          f.checked = !!state.formatBreakLines;
        }
        var u = document.getElementById('msFormatUpperAll');
        if (u && typeof state !== 'undefined') {
          u.checked = !!state.formatUpperAll;
        }
        var a = document.getElementById('msAutoSaveEditor');
        if (a && typeof state !== 'undefined') {
          a.checked = !!state.autoSaveEditor;
        }
        var ai = document.getElementById('msAutoSaveInterval');
        if (ai && typeof state !== 'undefined') {
          var isec = state.autoSaveIntervalSec || 5;
          ai.value = isec;
        }
      } catch (e) {}
      el.classList.remove('hidden');
      el.classList.add('show');
      el.setAttribute('aria-hidden','false');
    }
    function closeMySettings() {
      var el = document.getElementById('mySettingsBackdrop');
      if (!el) return;
      el.classList.remove('show');
      el.classList.add('hidden');
      el.setAttribute('aria-hidden','true');
    }
    ;
    function saveMySettings() {
      try {
        var t = document.getElementById('msDefaultTimeout');
        if (t && t.value !== '') {
          var sec = parseInt(t.value, 10);
          if (!isNaN(sec) && sec > 0 && typeof state !== 'undefined') {
            state.queryTimeoutMs = sec * 1000;
          }
        }
        var f = document.getElementById('msFormatBreakLines');
        if (f && typeof state !== 'undefined') {
          state.formatBreakLines = !!f.checked;
        }
        var u = document.getElementById('msFormatUpperAll');
        if (u && typeof state !== 'undefined') {
          state.formatUpperAll = !!u.checked;
        }
        var a = document.getElementById('msAutoSaveEditor');
        if (a && typeof state !== 'undefined') {
          state.autoSaveEditor = !!a.checked;
        }
        var ai = document.getElementById('msAutoSaveInterval');
        if (ai && ai.value !== '' && typeof state !== 'undefined') {
          var isec = parseInt(ai.value, 10);
          if (!isNaN(isec) && isec >= 3 && isec <= 600) {
            state.autoSaveIntervalSec = isec;
          }
        }
        if (typeof initAutoSaveTimer === 'function') {
          initAutoSaveTimer();
        }
      } catch (e) {}
      alert('내 설정 값은 이 세션에서만 적용됩니다.\n실제 영구 저장은 서버 연동 후 구현해야 합니다.');
      closeMySettings();
    }

    function openPasswordChangeModal() {
      var backdrop = document.getElementById('passwordChangeBackdrop');
      if (!backdrop) return;

      var curr = document.getElementById('pcCurrentPwd');
      var np   = document.getElementById('pcNewPwd');
      var npc  = document.getElementById('pcNewPwdConfirm');

      if (curr) curr.value = '';
      if (np)   np.value   = '';
      if (npc)  npc.value  = '';

      backdrop.classList.remove('hidden');
      backdrop.classList.add('show');
      backdrop.setAttribute('aria-hidden','false');

      setTimeout(function(){
        if (curr) curr.focus();
      }, 10);
    }

    function closePasswordChangeModal() {
      var backdrop = document.getElementById('passwordChangeBackdrop');
      if (!backdrop) return;
      backdrop.classList.remove('show');
      backdrop.classList.add('hidden');
      backdrop.setAttribute('aria-hidden','true');
    }

    function confirmPasswordChange() {
      var curr = document.getElementById('pcCurrentPwd');
      var np   = document.getElementById('pcNewPwd');
      var npc  = document.getElementById('pcNewPwdConfirm');

      var currVal = curr ? curr.value : '';
      var npVal   = np   ? np.value   : '';
      var npcVal  = npc  ? npc.value  : '';

      if (!currVal || !npVal || !npcVal) {
        alert('현재 비밀번호와 새 비밀번호, 확인 값을 모두 입력하세요.');
        return;
      }
      if (npVal !== npcVal) {
        alert('새 비밀번호와 확인 값이 일치하지 않습니다.');
        if (npc) npc.focus();
        return;
      }

      alert('비밀번호 변경 요청은 서버 연동 후 적용됩니다.\n현재는 UI 동작만 확인하는 상태입니다.');
      closePasswordChangeModal();
    }

  </script>

  <script>
    // 간단한 환경 필터 + 검색 기능
    (function(){
      const toolbar = document.querySelector('.db-access-toolbar');
      if(!toolbar) return;
      const buttons = toolbar.querySelectorAll('button[data-env]');
      const searchInput = document.getElementById('dbSearchInput');
      const rows = document.querySelectorAll('#dbAccessTable tbody tr');

      let currentEnv = 'ALL';
      let currentText = '';

      function applyFilter(){
        const text = currentText.trim().toLowerCase();
        rows.forEach(function(tr){
          const env = tr.getAttribute('data-env') || 'DEV';
          let ok = true;

          if(currentEnv !== 'ALL' && env !== currentEnv){
            ok = false;
          }
          if(ok && text){
            const content = tr.textContent.toLowerCase();
            if(content.indexOf(text) === -1){
              ok = false;
            }
          }
          tr.style.display = ok ? '' : 'none';
        });
      }

      buttons.forEach(function(btn){
        btn.addEventListener('click', function(){
          const env = btn.getAttribute('data-env') || 'ALL';
          currentEnv = env;
          buttons.forEach(function(b){ b.classList.remove('is-active'); });
          btn.classList.add('is-active');
          applyFilter();
        });
      });

      if(searchInput){
        searchInput.addEventListener('input', function(){
          currentText = searchInput.value || '';
          applyFilter();
        });
      }
    })();
  </script>

<script>
document.addEventListener('DOMContentLoaded', function(){
    try{
      var userToggle = document.getElementById('headerUserToggle');
      var userDropdown = document.getElementById('headerUserDropdown');
      if (userToggle && userDropdown) {
        userToggle.addEventListener('click', function(e){
          e.stopPropagation();
          var isOpen = userDropdown.classList.contains('open');
          if (isOpen) {
            userDropdown.classList.remove('open');
            userToggle.setAttribute('aria-expanded','false');
          } else {
            userDropdown.classList.add('open');
            userToggle.setAttribute('aria-expanded','true');
          }
        });
        document.addEventListener('click', function(e){
          if (!userDropdown.classList.contains('open')) return;
          if (userDropdown.contains(e.target) || userToggle.contains(e.target)) return;
          userDropdown.classList.remove('open');
          userToggle.setAttribute('aria-expanded','false');
        });
        userDropdown.addEventListener('click', function(e){
          var btn = e.target.closest('button[data-action]');
          if (!btn) return;

          var action = btn.getAttribute('data-action');
          if (action === 'profile') {
            if (window.ui && typeof ui.openMyInfoModal === 'function') {
              ui.openMyInfoModal();
            }
          } else if (action === 'settings') {
            if (typeof openMySettings === 'function') {
              openMySettings();
            } else {
              alert('내 설정 화면은 서버 연동 후 구현 예정입니다.');
            }
          } else if (action === 'delegate') {
            if (typeof openDelegateSettingsModal === 'function') {
              openDelegateSettingsModal();
            } else {
              alert('부재중 / 대결자 설정 모달 스크립트가 로딩되지 않았습니다.');
            }
          } else if (action === 'password') {
            if (typeof openPasswordChangeModal === 'function') {
              openPasswordChangeModal();
            } else {
              alert('비밀번호 변경 기능은 스크립트 로딩 후 동작합니다.');
            }
          } else if (action === 'logout') {
            alert('로그아웃은 서버 세션 연동 후 구현해야 합니다.');
          }
          userDropdown.classList.remove('open');
          userToggle.setAttribute('aria-expanded','false');
        });
      }
      var notifBtn = document.getElementById('headerNotifBtn');
      if (notifBtn) {
        notifBtn.addEventListener('click', function(e){
          e.preventDefault();
          e.stopPropagation();
          alert('알림 센터는 서버 연동 전입니다.\n샘플 알림만 표시됩니다.');
        });
      }

      // 탭 오버플로 메뉴 바깥 클릭 시 자동 닫기
      try{
        var overflowBtn = document.getElementById('tabOverflowBtn');
        var overflowMenu = document.getElementById('tabOverflowMenu');
        if (overflowBtn) {
          overflowBtn.addEventListener('click', function(e){
            // 버튼 클릭 시에는 문서 클릭 핸들러로 전파되지 않도록
            e.stopPropagation();
          });
        }
        if (overflowMenu) {
          overflowMenu.addEventListener('click', function(e){
            // 메뉴 내부 클릭 시 닫히지 않도록
            e.stopPropagation();
          });
        }
        document.addEventListener('click', function(e){
          try{
            var menu = document.getElementById('tabOverflowMenu');
            var btn  = document.getElementById('tabOverflowBtn');
            if (!menu || !btn) return;
            if (menu.classList.contains('hidden')) return;
            if (menu.contains(e.target) || btn.contains(e.target)) return;
            if (window.ui && typeof ui.closeTabOverflowMenu === 'function') {
              ui.closeTabOverflowMenu();
            } else {
              menu.classList.add('hidden');
            }
          }catch(err){
            console.warn('global click for tabOverflowMenu error', err);
          }
        });
      }catch(e2){
        console.warn('init tab overflow auto-close error', e2);
      }
    } catch(e){}
  });
  </script>




  <!-- Query progress overlay -->
  <div id="queryProgressOverlay" class="query-progress-overlay" aria-hidden="true">
    <div class="qp-inner">
      <div class="qp-logo-wrap">
        <div class="qp-logo-pulse">
          <div class="qp-logo-circle">
            <div class="qp-logo-bar"></div>
          </div>
        </div>
        <div class="qp-logo-label">Hana DBAM</div>
      </div>
      <div class="qp-bar">
        <div class="qp-bar-fill"></div>
      </div>
      <div class="qp-text">쿼리 실행 중입니다…</div>
    </div>
  </div>

<div id="approvalRequestBackdrop"
       class="export-modal-backdrop hidden"
       role="dialog"
       aria-modal="true"
       aria-hidden="true">
    <div class="export-modal approval-modal" style="max-width:720px;">
      <div class="export-modal-header">
        <h2>
          <i class="fa-solid fa-stamp"></i>
          <span style="margin-left:4px;" data-role="apReqTitleText">위험 쿼리 승인 요청</span>
        </h2>
        <button type="button"
                class="btn-icon approval-close-btn"
                onclick="approvalCenter.closeRequestModal()"
                aria-label="닫기">
          <i class="fa-solid fa-xmark"></i>
        </button>
      </div>
      <div class="export-modal-body" style="display:flex;flex-direction:column;gap:8px;">
        <div style="font-size:12px; color:#4b5563;" data-role="apReqGuide">
          개인정보/민감 테이블에 대한 쿼리는 바로 실행하지 않고 승인 요청 후 실행하도록 설계된 데모입니다.
        </div>
        <div style="display:grid;grid-template-columns:120px 1fr;gap:4px 8px;font-size:12px;">
          <div style="text-align:right;color:#6b7280;">DB / 연결</div>
          <div data-field="connLabel" style="font-weight:600;"></div>
          <div style="text-align:right;color:#6b7280;">스키마</div>
          <div data-field="schemaName"></div>
          <div style="text-align:right;color:#6b7280;">요청자</div>
          <div data-field="requester"></div>
          <div style="text-align:right;color:#6b7280;">업무명</div>
          <div data-field="bizName"></div>
          <div style="text-align:right;color:#6b7280;">위험 사유</div>
          <div data-field="riskReasons" style="white-space:pre-line;"></div>
        </div>
        <div>
          <label style="font-size:12px; color:#374151; display:block; margin-bottom:4px;">수행 쿼리</label>
          <textarea id="apReqSql"
                    readonly
                    style="width:100%;min-height:120px;font-family:var(--mono,monospace);font-size:12px;padding:6px 8px;border-radius:4px;border:1px solid #d1d5db;background:#f9fafb;"></textarea>
        </div>
        <div style="display:flex; flex-direction:column; gap:6px;">
          <label style="font-size:12px; color:#374151;" data-role="apReqReasonLabel">
            사유
            <textarea id="apReqReason"
                      style="width:100%;min-height:60px;font-size:12px;padding:4px 6px;border-radius:4px;border:1px solid #d1d5db;"
                      placeholder="왜 이 쿼리를 실행해야 하는지 업무 사유를 입력하세요."></textarea>
          </label>
          <div style="display:grid;grid-template-columns:1fr 1fr;gap:8px;font-size:12px;">
            <label>
              ITSM/작업요청 번호 (선택)
              <input id="apReqTicket"
                     type="text"
                     placeholder="예: CHG-2025-000123"
                     style="width:100%;padding:4px 6px;border-radius:4px;border:1px solid #d1d5db;">
            </label>
          </div>
          <div style="display:grid;grid-template-columns:1fr 1fr;gap:8px;font-size:12px; margin-top:4px;">
            <label data-role="apReqExecCountLabel">
              허용 실행 횟수
              <select id="apReqExecCount" style="width:100%;padding:4px 6px;border-radius:4px;border:1px solid #d1d5db;">
                <option value="1">1회</option>
                <option value="3">3회</option>
                <option value="5">5회</option>
              </select>
            </label>
            <label>
              유효 기간
              <div style="display:flex; align-items:center; gap:4px;">
                <input id="apReqValidFrom"
                       type="datetime-local"
                       style="flex:1 1 auto;padding:4px 6px;border-radius:4px;border:1px solid #d1d5db;">
                <span style="font-size:11px;color:#6b7280;">~</span>
                <input id="apReqValidTo"
                       type="datetime-local"
                       style="flex:1 1 auto;padding:4px 6px;border-radius:4px;border:1px solid #d1d5db;">
              </div>
            </label>
          </div>
        </div>
      </div>

          <div style="margin-top:8px;border-top:1px dashed #e5e7eb;padding-top:8px;">
            <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:4px;">
              <div style="font-size:12px;color:#374151;font-weight:600;">결재선</div>
              <button type="button"
                      class="btn btn-sm"
                      id="openApprovalModal">
                <i class="fa-solid fa-sitemap"></i>
                <span style="margin-left:4px;">결재선 지정</span>
              </button>
            </div>
            <div style="border-radius:6px;border:1px dashed #e5e7eb;background:#f9fafb;padding:6px 8px;">
              <div style="display:flex;flex-wrap:wrap;align-items:center;gap:6px;" id="apReqApprovalPreviewLine">
                <span style="font-size:12px;color:#9ca3af;">결재선 미지정 상태입니다.</span>
              </div>
              <div style="margin-top:6px;margin-bottom:8px;font-size:12px;display:flex;flex-wrap:wrap;gap:6px;align-items:center;" id="apReqApprovalPreviewRef"></div>
              <input id="apReqApprover" type="hidden" value="">
            </div>
          </div>

      <div class="export-modal-footer" style="border-top:1px solid #e5e7eb;margin-top:8px;padding:8px 12px;display:flex;justify-content:flex-end;gap:8px;">
        <button type="button" class="btn" onclick="approvalCenter.closeRequestModal()">취소</button>
        <button type="button" class="btn btn-primary" onclick="approvalCenter.submitCurrentRequest()">
          <i class="fa-solid fa-paper-plane"></i>
          <span style="margin-left:4px;">승인 요청</span>
        </button>
      </div>
    </div>
  </div>

  <!-- 쿼리 결재 상세/실행 모달 (데모용) -->
  <div id="approvalDetailBackdrop"
       class="export-modal-backdrop hidden"
       role="dialog"
       aria-modal="true"
       aria-hidden="true">
    <div class="export-modal approval-modal" style="max-width:860px;">
      <div class="export-modal-header">
        <h2>
          <i class="fa-solid fa-stamp"></i>
          <span style="margin-left:4px;" data-role="apDetailTitleText">쿼리 결재 상세</span>
        </h2>
        <button type="button"
                class="btn-icon approval-close-btn"
                onclick="approvalCenter.closeDetailModal()"
                aria-label="닫기">
          <i class="fa-solid fa-xmark"></i>
        </button>
      </div>
      <div class="export-modal-body" style="display:flex;flex-direction:column;gap:8px;">
        <div style="display:flex; flex-direction:column; align-items:flex-start; font-size:12px; gap:2px;">
          <div>
            상태:
            <span data-field="status"></span>
          </div>
          <div data-field="meta" style="color:#6b7280;font-size:11px;line-height:1.3;"></div>
        </div>
        <div style="display:grid;grid-template-columns:120px 1fr;gap:4px 8px;font-size:12px;">
          <div style="text-align:right;color:#6b7280;">DB / 연결</div>
          <div data-field="connLabel"></div>
          <div style="text-align:right;color:#6b7280;">스키마</div>
          <div data-field="schemaName"></div>
          <div style="text-align:right;color:#6b7280;">요청자</div>
          <div data-field="requester"></div>
          <div style="text-align:right;color:#6b7280;">업무명</div>
          <div data-field="bizName"></div>
          <div style="text-align:right;color:#6b7280;">승인자</div>
          <div>
          <div data-field="approver"></div>
          <div id="apDetailApprovalBox"
               style="margin-top:4px;border-radius:6px;border:1px dashed #e5e7eb;background:#f9fafb;padding:6px 8px;display:none;">
            <div id="apDetailApprovalLine"
                 style="display:flex;flex-wrap:wrap;align-items:center;gap:6px;"></div>
            <div id="apDetailApprovalRef"
                 style="margin-top:6px;font-size:12px;display:flex;flex-wrap:wrap;gap:6px;align-items:center;"></div>
          </div>
        </div>
          <div style="text-align:right;color:#6b7280;">위험 사유</div>
          <div data-field="riskReasons" style="white-space:pre-line;"></div>
          <div style="text-align:right;color:#6b7280;" data-role="apDetailReasonLabel">승인 요청 사유</div>
          <div data-field="requestReason" style="white-space:pre-line;"></div>
          <div id="apDetailRejectRow" style="text-align:right;color:#6b7280;">반려 사유</div>
          <div data-field="rejectReason" style="white-space:pre-line;"></div>
        </div>
        <div>
          <label id="apDetailSqlLabel" style="font-size:12px; color:#374151; display:block; margin-bottom:4px;">승인된 쿼리</label>
          <textarea id="apDetailSql"
                    readonly
                    style="width:100%;min-height:140px;font-family:var(--mono,monospace);font-size:12px;padding:6px 8px;border-radius:4px;border:1px solid #d1d5db;background:#f9fafb;"></textarea>
        </div>
        <div style="font-size:12px; color:#4b5563;" data-field="execInfo"></div>
        <div style="display:flex; align-items:center; gap:8px; font-size:12px;">
          <label data-role="apDetailExecCountLabel">
            허용 실행 횟수
            <select id="apDetailExecCount" style="margin-left:4px; padding:2px 6px; font-size:12px;">
              <option value="1">1회</option>
              <option value="3">3회</option>
              <option value="5">5회</option>
            </select>
          </label>
          <span class="muted" style="font-size:11px;">승인 단계에서만 수정됩니다.</span>
        </div>
        <div id="apDetailValidRange" style="font-size:12px; font-weight:600; margin:4px 0 10px 0;"></div>
      </div>
      <div class="export-modal-footer" style="border-top:1px solid #e5e7eb;padding:8px 12px;display:flex;justify-content:space-between;gap:8px;align-items:center;">
        <div style="font-size:11px; color:#6b7280;">
          승인된 쿼리는 이 화면에서만 실행되며, 에디터에서 수정된 SQL은 별도 승인 절차가 필요합니다.
        </div>
        <div style="display:flex; gap:8px;">
          <button type="button" id="apDetailReject" class="btn" onclick="approvalCenter.rejectCurrent()">반려</button>
          <button type="button" id="apDetailApprove" class="btn btn-primary" onclick="approvalCenter.approveCurrent()">
            <i class="fa-solid fa-check"></i>
            <span style="margin-left:4px;">승인</span>
          </button>
          <button type="button" id="apDetailRefConfirm" class="btn" onclick="approvalCenter.confirmRefCurrent()">
            <i class="fa-solid fa-check"></i>
            <span style="margin-left:4px;">참조확인</span>
          </button>
          <button type="button" id="apDetailExcelDownload" class="btn" onclick="approvalCenter.downloadExcelForCurrent()">
            <i class="fa-solid fa-file-excel"></i>
            <span style="margin-left:4px;">엑셀 다운로드</span>
          </button>
          <button type="button" id="apDetailExecute" class="btn" onclick="approvalCenter.executeCurrent()">
            <i class="fa-solid fa-play"></i>
            <span style="margin-left:4px;">승인된 쿼리 실행</span>
          </button>
        </div>
      </div>
    </div>
  </div>





  <script>

    // 간단한 in-memory 데이터 구조
    let delegations = [];
    let editingId = null;
    let nextId = 1;

    function syncDelegationsToGlobalAbsence() {
      try {
        var curId = (window.DBAM_CURRENT_USER || 'demoUser').trim();
        if (!curId) {
          console.warn('[부재중/대결자] DBAM_CURRENT_USER가 없어 부재 정보를 전파하지 않습니다.');
          return;
        }
        if (!Array.isArray(window.DBAM_ABSENCE)) {
          window.DBAM_ABSENCE = [];
        }

        // 현재 로그인 사용자(empId) 기준 기존 부재 정보 제거
        window.DBAM_ABSENCE = window.DBAM_ABSENCE.filter(function(item) {
          return !(item && item.empId === curId);
        });

        // 모달 내부 delegations 배열 기준으로 재구성
        (delegations || []).forEach(function(d) {
          if (!d) return;
          window.DBAM_ABSENCE.push({
            empId: curId,
            start: d.start,
            end: d.end,
            status: d.status || 'ACTIVE',
            reason: d.reason || '',
            // delegate: "개발1팀 홍길동 책임" 형식의 라벨
            delegate: d.delegate || '',
            // delegateId는 현재는 따로 저장하지 않지만,
            // findDelegateMember()에서 delegate 라벨로도 매핑하므로 없어도 동작함
            delegateId: d.delegateId || null
          });
        });

        console.log('[부재중/대결자] window.DBAM_ABSENCE 동기화 완료:', window.DBAM_ABSENCE);
      } catch (e) {
        console.warn('[부재중/대결자] syncDelegationsToGlobalAbsence 오류:', e);
      }
    }


    const profileBtn = document.getElementById('profileBtn');
    const profileMenu = document.getElementById('profileMenu');
    const absenceModalBackdrop = document.getElementById('absenceModalBackdrop');
    const absenceModalCloseBtn = document.getElementById('absenceModalCloseBtn');
    const absenceModalCancelBtn = document.getElementById('absenceModalCancelBtn');
    const absenceModalSaveBtn = document.getElementById('absenceModalSaveBtn');

    const tabButtons = document.querySelectorAll('.tab-btn');
    const tabForm = document.getElementById('tab-form');
    const tabHistory = document.getElementById('tab-history');

    const currentStatusCard = document.getElementById('currentStatusCard');
    const currentStatusChip = document.getElementById('currentStatusChip');
    const currentStatusText = document.getElementById('currentStatusText');
    const currentStatusSubText = document.getElementById('currentStatusSubText');
    const btnCurrentEnd = document.getElementById('btnCurrentEnd');
    const btnCurrentExtend = document.getElementById('btnCurrentExtend');

    const absenceTypeEl = document.getElementById('absenceType');
    const startDateEl = document.getElementById('startDate');
    const endDateEl = document.getElementById('endDate');
    const delegateNameEl = document.getElementById('delegateName');
    const btnSearchDelegate = document.getElementById('btnSearchDelegate');
    const notifyDelegateEl = document.getElementById('notifyDelegate');
    const notifyMeEl = document.getElementById('notifyMe');
    const reasonEl = document.getElementById('reason');

    const dateErrorEl = document.getElementById('dateError');
    const delegateErrorEl = document.getElementById('delegateError');

    const quickButtons = document.querySelectorAll('.quick-buttons .btn');

    const historyEmpty = document.getElementById('historyEmpty');
    const historyTableWrapper = document.getElementById('historyTableWrapper');
    const historyTbody = document.getElementById('historyTbody');

        if (profileBtn && profileMenu) {
// 프로필 메뉴 토글
    profileBtn.addEventListener('click', function () {
      profileMenu.classList.toggle('open');
    });

    document.addEventListener('click', function (e) {
      if (!profileMenu.contains(e.target) && !profileBtn.contains(e.target)) {
        profileMenu.classList.remove('open');
      }
    });

    profileMenu.addEventListener('click', function (e) {
      const item = e.target.closest('.profile-menu-item');
      if (!item) return;
      const menu = item.getAttribute('data-menu');
      if (menu === 'absence') {
        openAbsenceModal();
      } else if (menu === 'password') {
        alert('비밀번호 변경 모달은 기존 구현과 연계하세요.');
      }
      profileMenu.classList.remove('open');
    });

    
    }

function openAbsenceModal() {
      editingId = null;
      resetForm();
      renderCurrentStatus();
      renderHistory();
      syncDelegationsToGlobalAbsence();
      switchTab('form');
      absenceModalBackdrop.classList.add('open');
    }

    function closeAbsenceModal() {
      absenceModalBackdrop.classList.remove('open');
    }

    absenceModalCloseBtn.addEventListener('click', closeAbsenceModal);
    absenceModalCancelBtn.addEventListener('click', closeAbsenceModal);

    absenceModalBackdrop.addEventListener('click', function (e) {
      if (e.target === absenceModalBackdrop) {
        closeAbsenceModal();
      }
    });

    document.addEventListener('keydown', function (e) {
      if (e.key === 'Escape' && absenceModalBackdrop.classList.contains('open')) {
        // ESC는 전역 핸들러에서 처리
      }
    });

    // 탭 전환
    tabButtons.forEach(function (btn) {
      btn.addEventListener('click', function () {
        const tab = btn.getAttribute('data-tab');
        switchTab(tab);
      });
    });

    function switchTab(tab) {
      tabButtons.forEach(function (btn) {
        btn.classList.toggle('active', btn.getAttribute('data-tab') === tab);
      });
      tabForm.classList.toggle('active', tab === 'form');
      tabHistory.classList.toggle('active', tab === 'history');
    }

    // 현재 상태 렌더링
    function renderCurrentStatus() {
      const now = new Date();
      let active = null;
      let planned = null;

      delegations.forEach(function (d) {
        const start = new Date(d.start);
        const end = new Date(d.end);
        if (d.status === 'ACTIVE' && start <= now && now <= end) {
          if (!active || new Date(active.start) < start) {
            active = d;
          }
        } else if (d.status === 'PLANNED' && start > now) {
          if (!planned || new Date(planned.start) > start) {
            planned = d;
          }
        }
      });

      if (active) {
        currentStatusCard.classList.remove('inactive');
        currentStatusChip.className = 'status-chip active';
        currentStatusChip.textContent = '사용중';

        const periodText = formatDateTime(active.start) + ' ~ ' + formatDateTime(active.end);

        currentStatusText.textContent = '현재 부재 설정이 적용 중입니다.';
        currentStatusSubText.textContent =
          '기간: ' + periodText + ' / 대결자: ' + active.delegate;

        btnCurrentEnd.disabled = false;
        btnCurrentExtend.disabled = false;
        btnCurrentEnd.onclick = function () {
          endDelegation(active.id, 'USER_END');
        };
        btnCurrentExtend.onclick = function () {
          loadDelegationToForm(active.id);
        };
      } else if (planned) {
        currentStatusCard.classList.remove('inactive');
        currentStatusChip.className = 'status-chip planned';
        currentStatusChip.textContent = '예정';

        const periodText = formatDateTime(planned.start) + ' ~ ' + formatDateTime(planned.end);
        currentStatusText.textContent = '예약된 부재 설정이 있습니다.';
        currentStatusSubText.textContent =
          '기간: ' + periodText + ' / 대결자: ' + planned.delegate;

        btnCurrentEnd.disabled = true;
        btnCurrentExtend.disabled = false;
        btnCurrentEnd.onclick = null;
        btnCurrentExtend.onclick = function () {
          loadDelegationToForm(planned.id);
        };
      } else {
        currentStatusCard.classList.add('inactive');
        currentStatusChip.className = 'status-chip expired';
        currentStatusChip.textContent = '부재 설정 없음';
        currentStatusText.textContent = '현재 부재/대결자 설정이 없습니다.';
        currentStatusSubText.textContent =
          '부재 기간과 대결자를 등록하면, 지정된 기간 동안 결재 권한이 대결자에게 위임됩니다.';
        btnCurrentEnd.disabled = true;
        btnCurrentExtend.disabled = true;
        btnCurrentEnd.onclick = null;
        btnCurrentExtend.onclick = null;
      }
    }

    // 이력 렌더링
    function renderHistory() {
      if (!delegations.length) {
        historyEmpty.style.display = 'block';
        historyTableWrapper.style.display = 'none';
        historyTbody.innerHTML = '';
        return;
      }
      historyEmpty.style.display = 'none';
      historyTableWrapper.style.display = 'block';

      const sorted = [...delegations].sort(function (a, b) {
        return new Date(b.createdAt) - new Date(a.createdAt);
      });

      historyTbody.innerHTML = '';
      sorted.forEach(function (d) {
        const tr = document.createElement('tr');

        const statusTd = document.createElement('td');
        statusTd.className = 'nowrap';
        const badge = document.createElement('span');
        const now = new Date();
        const start = new Date(d.start);
        const end = new Date(d.end);

        let label = '';
        if (d.status === 'ACTIVE' && start <= now && now <= end) {
          badge.className = 'badge badge-used';
          label = '사용중';
        } else if (d.status === 'PLANNED' && start > now) {
          badge.className = 'badge badge-planned';
          label = '예정';
        } else {
          badge.className = 'badge badge-expired';
          label = '만료';
        }
        badge.textContent = label;
        statusTd.appendChild(badge);
        tr.appendChild(statusTd);

        const periodTd = document.createElement('td');
        periodTd.className = 'nowrap';
        periodTd.textContent = formatDateTime(d.start) + ' ~ ' + formatDateTime(d.end);
        tr.appendChild(periodTd);

        const delegateTd = document.createElement('td');
        delegateTd.className = 'nowrap';
        delegateTd.textContent = d.delegate;
        tr.appendChild(delegateTd);

        const reasonTd = document.createElement('td');
        reasonTd.className = 'reason-cell';
        reasonTd.textContent = d.reason || '-';
        tr.appendChild(reasonTd);

        const endTypeTd = document.createElement('td');
        const endBadge = document.createElement('span');
        if (!d.endType) {
          endBadge.className = 'badge badge-expired';
          endBadge.textContent = '-';
        } else if (d.endType === 'AUTO') {
          endBadge.className = 'badge badge-expired';
          endBadge.textContent = '자동 종료';
        } else if (d.endType === 'USER_END') {
          endBadge.className = 'badge badge-used';
          endBadge.textContent = '사용자 해제';
        } else if (d.endType === 'ADMIN_FORCE') {
          endBadge.className = 'badge badge-force';
          endBadge.textContent = '관리자 해제';
        } else {
          endBadge.className = 'badge badge-expired';
          endBadge.textContent = d.endType;
        }
        endTypeTd.appendChild(endBadge);
        tr.appendChild(endTypeTd);

        const actionTd = document.createElement('td');
        actionTd.className = 'nowrap';
        const btnEdit = document.createElement('button');
        btnEdit.type = 'button';
        btnEdit.className = 'btn btn-ghost btn-sm';
        btnEdit.textContent = '수정';
        btnEdit.addEventListener('click', function () {
          switchTab('form');
          loadDelegationToForm(d.id);
        });
        actionTd.appendChild(btnEdit);

        const btnEnd = document.createElement('button');
        btnEnd.type = 'button';
        btnEnd.className = 'btn btn-ghost btn-sm';
        btnEnd.textContent = '즉시해제';
        btnEnd.addEventListener('click', function () {
          endDelegation(d.id, 'USER_END');
        });
        actionTd.appendChild(btnEnd);

        const btnCopy = document.createElement('button');
        btnCopy.type = 'button';
        btnCopy.className = 'btn btn-ghost btn-sm';
        btnCopy.textContent = '복사';
        btnCopy.addEventListener('click', function () {
          copyDelegationToForm(d.id);
        });
        actionTd.appendChild(btnCopy);

        const btnDelete = document.createElement('button');
        btnDelete.type = 'button';
        btnDelete.className = 'btn btn-ghost btn-sm';
        btnDelete.textContent = '삭제';
        btnDelete.addEventListener('click', function () {
          deleteDelegation(d.id);
        });
        actionTd.appendChild(btnDelete);

        tr.appendChild(actionTd);
        historyTbody.appendChild(tr);
      });
    }

    // 저장 버튼
    absenceModalSaveBtn.addEventListener('click', function () {
      if (!validateForm()) return;

      const now = new Date();
      const start = new Date(startDateEl.value);
      const end = new Date(endDateEl.value);
      const delegate = delegateNameEl.value.trim();
      const reason = reasonEl.value.trim();
      const notifyDelegate = !!notifyDelegateEl.checked;
      const notifyMe = !!notifyMeEl.checked;

      const startIso = start.toISOString();
      const endIso = end.toISOString();

      const duplicate = delegations.some(function (d) {
        return d.id !== editingId &&
               d.start === startIso &&
               d.end === endIso &&
               d.delegate === delegate;
      });
      if (duplicate) {
        alert('같은 기간과 대결자로 등록된 부재 설정이 이미 있습니다.');
        return;
      }

      let status;
      if (end < now) {
        status = 'EXPIRED';
      } else if (start > now) {
        status = 'PLANNED';
      } else {
        status = 'ACTIVE';
      }

      if (editingId) {
        const idx = delegations.findIndex(d => d.id === editingId);
        if (idx >= 0) {
          delegations[idx] = {
            ...delegations[idx],
            type: absenceTypeEl.value,
            start: startIso,
            end: endIso,
            delegate,
            reason,
            notifyDelegate,
            notifyMe,
            status,
            updatedAt: now.toISOString(),
          };
        }
      } else {
        delegations.push({
          id: nextId++,
          type: absenceTypeEl.value,
          start: startIso,
          end: endIso,
          delegate,
          reason,
          notifyDelegate,
          notifyMe,
          status,
          createdAt: now.toISOString(),
          updatedAt: now.toISOString(),
          endType: null,
        });
      }

      renderCurrentStatus();
      renderHistory();
      syncDelegationsToGlobalAbsence();
      editingId = null;
      alert('부재/대결자 설정이 저장되었습니다.');
    });

    // 폼 검증
    function validateForm() {
      let ok = true;
      dateErrorEl.style.display = 'none';
      delegateErrorEl.style.display = 'none';

      if (!startDateEl.value || !endDateEl.value) {
        dateErrorEl.textContent = '부재 시작/종료 일시는 필수입니다.';
        dateErrorEl.style.display = 'block';
        ok = false;
      } else {
        const start = new Date(startDateEl.value);
        const end = new Date(endDateEl.value);
        if (end < start) {
          dateErrorEl.textContent = '종료 일시는 시작 일시보다 빠를 수 없습니다.';
          dateErrorEl.style.display = 'block';
          ok = false;
        }
      }

      if (!delegateNameEl.value.trim()) {
        delegateErrorEl.textContent = '대결자를 입력하세요.';
        delegateErrorEl.style.display = 'block';
        ok = false;
      }

      return ok;
    }

        function resetForm() {
      const now = new Date();
      const startIso = new Date(now.getTime() + 5 * 60000).toISOString().slice(0, 16);
      const endIso = new Date(now.getTime() + 8 * 60 * 60000).toISOString().slice(0, 16);

      absenceTypeEl.value = '연차';
      startDateEl.value = startIso;
      endDateEl.value = endIso;
      delegateNameEl.value = '';
      reasonEl.value = '';
      notifyDelegateEl.checked = true;
      notifyMeEl.checked = false;
      dateErrorEl.style.display = 'none';
      delegateErrorEl.style.display = 'none';
    }

    function loadDelegationToForm(id) {
      const d = delegations.find(function (x) { return x.id === id; });
      if (!d) return;
      editingId = id;
      absenceTypeEl.value = d.type;
      startDateEl.value = d.start.slice(0, 16);
      endDateEl.value = d.end.slice(0, 16);
      delegateNameEl.value = d.delegate;
      reasonEl.value = d.reason || '';
      notifyDelegateEl.checked = !!d.notifyDelegate;
      notifyMeEl.checked = !!d.notifyMe;

    }

    function copyDelegationToForm(id) {
      const d = delegations.find(function (x) { return x.id === id; });
      if (!d) return;
      editingId = null;
      absenceTypeEl.value = d.type;
      delegateNameEl.value = d.delegate;
      reasonEl.value = d.reason || '';
      notifyDelegateEl.checked = !!d.notifyDelegate;
      notifyMeEl.checked = !!d.notifyMe;

      const now = new Date();
      const startIso = new Date(now.getTime() + 5 * 60000).toISOString().slice(0, 16);
      const endIso = new Date(now.getTime() + 8 * 60 * 60000).toISOString().slice(0, 16);
      startDateEl.value = startIso;
      endDateEl.value = endIso;


      switchTab('form');
    }

    function endDelegation(id, endType) {
      const now = new Date();
      const idx = delegations.findIndex(d => d.id === id);
      if (idx < 0) return;

      const d = delegations[idx];
      d.end = now.toISOString();
      d.status = 'EXPIRED';
      d.endType = endType;
      d.updatedAt = now.toISOString();
      delegations[idx] = d;

      renderCurrentStatus();
      renderHistory();
      syncDelegationsToGlobalAbsence();
      alert('해당 부재/대결자 설정이 종료 처리되었습니다.');
    }


    function deleteDelegation(id) {
      const idx = delegations.findIndex(d => d.id === id);
      if (idx < 0) return;
      const d = delegations[idx];

      if (!confirm('선택한 부재/대결자 설정을 삭제하시겠습니까?\n기간: ' +
        formatDateTime(d.start) + ' ~ ' + formatDateTime(d.end) +
        '\n대결자: ' + d.delegate)) {
        return;
      }

      delegations = delegations.filter(function (x) { return x.id !== id; });
      renderCurrentStatus();
      renderHistory();
      syncDelegationsToGlobalAbsence();
    }

    function formatDateTime(iso) {
      const d = new Date(iso);
      if (isNaN(d.getTime())) return '-';
      const yyyy = d.getFullYear();
      const mm = String(d.getMonth() + 1).padStart(2, '0');
      const dd = String(d.getDate()).padStart(2, '0');
      const hh = String(d.getHours()).padStart(2, '0');
      const mi = String(d.getMinutes()).padStart(2, '0');
      return yyyy + '-' + mm + '-' + dd + ' ' + hh + ':' + mi;
    }

    // 빠른 기간 설정
    quickButtons.forEach(function (btn) {
      btn.addEventListener('click', function () {
        const type = btn.getAttribute('data-quick');
        const now = new Date();
        let start, end;
        if (type === 'today') {
          start = new Date(now.getFullYear(), now.getMonth(), now.getDate(), 9, 0, 0);
          end = new Date(now.getFullYear(), now.getMonth(), now.getDate(), 18, 0, 0);
        } else if (type === 'tomorrow') {
          const t = new Date(now.getFullYear(), now.getMonth(), now.getDate() + 1);
          start = new Date(t.getFullYear(), t.getMonth(), t.getDate(), 9, 0, 0);
          end = new Date(t.getFullYear(), t.getMonth(), t.getDate(), 18, 0, 0);
        } else if (type === 'thisWeek') {
          const day = now.getDay();
          const mondayOffset = (day === 0 ? -6 : 1 - day);
          const monday = new Date(now.getFullYear(), now.getMonth(), now.getDate() + mondayOffset);
          const friday = new Date(monday.getFullYear(), monday.getMonth(), monday.getDate() + 4);
          start = new Date(now);
          end = new Date(friday.getFullYear(), friday.getMonth(), friday.getDate(), 18, 0, 0);
        } else {
          return;
        }
        startDateEl.value = start.toISOString().slice(0, 16);
        endDateEl.value = end.toISOString().slice(0, 16);
      });
    });

    // 대결자 검색 버튼 → 조직도 모달 연동
    btnSearchDelegate.addEventListener('click', function () {
      if (window.delegatePicker && typeof window.delegatePicker.open === 'function') {
        window.delegatePicker.open();
      } else {
        alert('조직도 기반 대결자 선택 모달이 아직 초기화되지 않았습니다.');
      }
    });

    // 메뉴바 드롭다운 항목 클릭 시 메뉴 닫기
    const menubarMenus = document.querySelectorAll('.menubar .menu');
    menubarMenus.forEach(function(menu) {
      const dropdown = menu.querySelector('.dropdown');
      if (!dropdown) return;
      // 각 메뉴 항목 클릭 시 드롭다운 닫기
      dropdown.querySelectorAll('a').forEach(function(link) {
        link.addEventListener('click', function() {
          dropdown.style.display = 'none';
        });
      });
      // 마우스가 메뉴 영역에서 벗어나면 display 초기화
      menu.addEventListener('mouseleave', function() {
        dropdown.style.display = '';
      });
    });

    // DBAM 연동: 기존 부재중/대결자 메뉴 함수와 연결
    function openDelegateSettingsModal() {
      openAbsenceModal();
    }
    function closeDelegateSettingsModal() {
      closeAbsenceModal();
    }
    function saveDelegateSettings() {
      // 기존 saveDelegateSettings 호출 시, 모달 내 저장 버튼과 동일하게 동작
      if (absenceModalSaveBtn) {
        absenceModalSaveBtn.click();
      }
    }

  </script>

  
  <!-- 세션 변경 모달 -->
  <div id="sessionSwitchBackdrop"
       class="export-modal-backdrop hidden"
       role="dialog"
       aria-modal="true"
       aria-hidden="true">
    <div class="export-modal approval-modal" style="max-width:600px;">
      <div class="export-modal-header">
        <h2>
          <i class="fa-solid fa-user-gear"></i>
          <span style="margin-left:4px;">세션 변경 (조직도 선택)</span>
        </h2>
        <button type="button"
                class="btn-icon approval-close-btn"
                onclick="window.sessionSwitcher && window.sessionSwitcher.close()"
                aria-label="닫기">
          <i class="fa-solid fa-xmark"></i>
        </button>
      </div>
      <div class="export-modal-body" style="display:flex;flex-direction:column;gap:8px;">
        <div style="font-size:12px;color:#4b5563;">
          결재 데모를 위해 현재 브라우저 세션의 사용자 정보를 조직도에서 선택한 사용자로 변경합니다. (실제 인증은 변경되지 않습니다.)
        </div>
        <div style="display:flex;gap:12px;min-height:0;">
          <div style="flex:0 0 45%;display:flex;flex-direction:column;gap:6px;min-height:0;">
            <div style="font-size:12px;font-weight:600;">조직도</div>
            <div id="sessionSwitchOrgTree"
                 style="border-radius:6px;border:1px solid #e5e7eb;background:#fff;padding:6px;max-height:320px;overflow:auto;font-size:12px;">
            </div>
          </div>
          <div style="flex:1;display:flex;flex-direction:column;gap:6px;min-height:0;">
            <div style="font-size:12px;font-weight:600;">선택한 사용자</div>
            <div id="sessionSwitchSelectedLabel"
                 style="font-size:12px;color:#374151;border-radius:6px;border:1px dashed #d1d5db;padding:8px;min-height:40px;display:flex;align-items:center;">
              아직 사용자를 선택하지 않았습니다.
            </div>
            <div style="font-size:11px;color:#9ca3af;">
              선택한 사용자 기준으로 결재함의 "내 승인할 건"과 상세 화면의 승인/반려 버튼 노출이 달라집니다.
            </div>
          </div>
        </div>
        <div style="font-size:11px;color:#9ca3af;">
          실제 사내 인증/권한과는 무관한 화면 데모용 기능입니다.
        </div>
      </div>
      <div class="export-modal-footer" style="display:flex;justify-content:flex-end;gap:6px;">
        <button type="button" class="btn btn-secondary" onclick="window.sessionSwitcher && window.sessionSwitcher.close()">취소</button>
        <button type="button" class="btn btn-primary" onclick="window.sessionSwitcher && window.sessionSwitcher.applySelected()">이 사용자로 세션 변경</button>
      </div>
    </div>
  </div>


  <!-- 대결자 선택 (조직도) 모달 -->
  <div id="delegateOrgBackdrop"
       class="export-modal-backdrop hidden"
       role="dialog"
       aria-modal="true"
       aria-hidden="true">
    <div class="export-modal approval-modal" style="max-width:760px; max-height:80vh;">
      <div class="export-modal-header">
        <h2>
          <i class="fa-solid fa-user-check"></i>
          <span style="margin-left:4px;">대결자 선택 (조직도)</span>
        </h2>
        <button type="button"
                class="btn-icon approval-close-btn"
                onclick="window.delegatePicker && window.delegatePicker.close()"
                aria-label="닫기">
          <i class="fa-solid fa-xmark"></i>
        </button>
      </div>
      <div class="export-modal-body" style="display:flex;flex-direction:column;gap:8px;">
        <div style="font-size:14px;color:#374151;">
          부재중일 때 결재를 대신 처리할 대결자를 조직도에서 선택합니다.
        </div>
        <div style="display:flex;gap:12px;min-height:0;">
          <div style="flex:0 0 45%;display:flex;flex-direction:column;gap:6px;min-height:0;">
            <div style="font-size:13px;font-weight:600;">조직도</div>
            <div id="delegateOrgTree"
                 style="border-radius:6px;border:1px solid #e5e7eb;background:#fff;padding:6px;max-height:420px;overflow:auto;font-size:12px;">
            </div>
          </div>
          <div style="flex:1;display:flex;flex-direction:column;gap:6px;min-height:0;">
            <div style="font-size:13px;font-weight:600;">선택한 대결자</div>
            <div id="delegateSelectedLabel"
                 style="font-size:13px;color:#111827;border-radius:6px;border:1px solid #e5e7eb;background:#f9fafb;padding:8px;min-height:40px;display:flex;align-items:center;">
              아직 대결자를 선택하지 않았습니다.
            </div>
            <div style="font-size:12px;color:#6b7280;">
              선택한 대결자가 부재 기간 동안 결재를 대신 수행합니다.
            </div>
          </div>
        </div>
      </div>
      <div class="export-modal-footer" style="display:flex;justify-content:flex-end;gap:6px;">
        <button type="button" class="btn btn-secondary"
                onclick="window.delegatePicker && window.delegatePicker.close()">취소</button>
        <button type="button" class="btn btn-primary"
                onclick="window.delegatePicker && window.delegatePicker.applySelected()">대결자 선택</button>
      </div>
    </div>
  </div>

  <!-- 결재선 지정 모달 -->
  <div id="approvalLineBackdrop"
       class="export-modal-backdrop hidden"
       role="dialog"
       aria-modal="true"
       aria-hidden="true">
    <div class="export-modal approval-modal" style="max-width:860px;">
      <div class="export-modal-header">
        <h2>
          <i class="fa-solid fa-sitemap"></i>
          <span style="margin-left:4px;">결재선 지정</span>
        </h2>
        <button type="button"
                class="btn-icon approval-close-btn"
                onclick="window.approvalLine && window.approvalLine.closeModal()"
                aria-label="닫기">
          <i class="fa-solid fa-xmark"></i>
        </button>
      </div>
      <div class="export-modal-body" style="display:flex;flex-direction:column;gap:8px;">
        <div style="display:flex;gap:12px;flex:1 1 auto;min-height:0;">
          <!-- 좌측: 조직도 -->
          <div style="flex:0 0 40%;display:flex;flex-direction:column;gap:6px;min-height:0;">
            <div style="font-size:12px;font-weight:600;">조직도</div>
            <div id="apLineOrgTree"
                 style="border-radius:6px;border:1px solid #e5e7eb;background:#fff;padding:6px;max-height:340px;overflow:auto;font-size:12px;">
            </div>
            <div style="font-size:11px;color:#9ca3af;margin-top:4px;">
              사용자 이름 앞의 라디오를 선택하면 결재선에 추가됩니다. (이름/직급 기준)
            </div>
          </div>

          <!-- 우측: 결재선 테이블 -->
          <div style="flex:1;display:flex;flex-direction:column;gap:6px;min-height:0;">
            <div style="font-size:12px;font-weight:600;">결재선</div>
            <table style="width:100%;border-collapse:collapse;font-size:12px;background:#fff;border-radius:8px;overflow:hidden;">
              <thead>
                <tr>
                  <th style="background:#f9fafb;border:1px solid #e5e7eb;padding:6px 8px;width:52px;text-align:center;">순서</th>
                  <th style="background:#f9fafb;border:1px solid #e5e7eb;padding:6px 8px;width:90px;text-align:center;">유형</th>
                  <th style="background:#f9fafb;border:1px solid #e5e7eb;padding:6px 8px;text-align:left;">결재자 / 직책</th>
                  <th style="background:#f9fafb;border:1px solid #e5e7eb;padding:6px 8px;width:150px;text-align:center;">정렬 / 삭제</th>
                </tr>
              </thead>
              <tbody id="apLineBody"></tbody>
            </table>
            <div id="apLineEmptyHint" style="font-size:11px;color:#9ca3af;margin-top:4px;">
              아직 선택된 결재선이 없습니다. 좌측 조직도에서 사용자를 선택하세요.
            </div>
          </div>
        </div>

        <!-- 하단: 결재선 미리보기 -->
        <div style="border-top:1px dashed #e5e7eb;padding-top:8px;">
          <div id="apLinePreviewLine"
               style="display:flex;flex-wrap:wrap;align-items:center;gap:6px;"></div>
          <div id="apLinePreviewRef"
               style="margin-top:6px;margin-bottom:8px;font-size:12px;display:flex;flex-wrap:wrap;gap:6px;align-items:center;"></div>
        </div>
      </div>
      <div class="export-modal-footer" style="border-top:1px solid #e5e7eb;padding:8px 12px;display:flex;justify-content:flex-end;gap:8px;">
        <button type="button" class="btn" onclick="window.approvalLine && window.approvalLine.closeModal()">취소</button>
        <button type="button" class="btn btn-primary" onclick="window.approvalLine && window.approvalLine.applyAndClose()">
          <span>확인</span>
        </button>
      </div>
    </div>
  </div>

  <script>
    // 위험 쿼리 결재선 지정 모듈
    (function(){
      const ORG_DATA = [
        {
          dept: "IT본부",
          teams: [
            {
              name: "개발1팀",
              members: [
                { id:"E001", name:"홍길동", title:"책임", dept:"IT본부/개발1팀" },
                { id:"E002", name:"김개발", title:"선임", dept:"IT본부/개발1팀" },
                { id:"demoUser", name:"demoUser", title:"테스트", dept:"IT본부/개발1팀" }
              ]
            },
            {
              name: "개발2팀",
              members: [
                { id:"E003", name:"이테스트", title:"책임", dept:"IT본부/개발2팀" },
                { id:"E004", name:"박프론트", title:"대리", dept:"IT본부/개발2팀" }
              ]
            }
          ]
        },
        {
          dept: "경영지원본부",
          teams: [
            {
              name: "인사팀",
              members: [
                { id:"E101", name:"최인사", title:"팀장", dept:"경영지원본부/인사팀" },
                { id:"E102", name:"오교육", title:"주임", dept:"경영지원본부/인사팀" }
              ]
            }
          ]
        }
      ];

      window.DBAM_ORG_DATA = ORG_DATA;

      const backdrop = document.getElementById('approvalLineBackdrop');
      const orgTree = document.getElementById('apLineOrgTree');
      const lineBody = document.getElementById('apLineBody');
      const lineEmptyHint = document.getElementById('apLineEmptyHint');
      const previewLine = document.getElementById('apLinePreviewLine');
      const previewRef = document.getElementById('apLinePreviewRef');
      const outerPreviewLine = document.getElementById('apReqApprovalPreviewLine');
      const outerPreviewRef  = document.getElementById('apReqApprovalPreviewRef');
      const outerApproverInput = document.getElementById('apReqApprover');
      const openBtn = document.getElementById('openApprovalModal');

      if(!backdrop || !orgTree || !lineBody || !previewLine || !previewRef || !openBtn){
        return;
      }

      let escHandler = null;

      // 결재선용 부재 정보 조회 (전역 window.DBAM_ABSENCE 기반)
      // window.DBAM_ABSENCE는 [{ empId, start, end, status, delegate }, ...] 형태를 가정한다.
      function getActiveAbsenceForEmp(empId){
        if (!window.DBAM_ABSENCE || !Array.isArray(window.DBAM_ABSENCE)) return null;
        const now = new Date();
        let active = null;
        window.DBAM_ABSENCE.forEach(function(d){
          if (!d || d.empId !== empId) return;
          try{
            const start = new Date(d.start);
            const end = new Date(d.end);
            if (d.status === 'ACTIVE' && start <= now && now <= end){
              if (!active || new Date(active.start) < start){
                active = d;
              }
            }
          }catch(err){
            console.warn('getActiveAbsenceForEmp parse error', err);
          }
        });
        return active;
      }

      function formatAbsencePeriodForBadge(abs){
        if (!abs || !abs.start || !abs.end) return '';
        try{
          const s = new Date(abs.start);
          const e = new Date(abs.end);
          const pad = (n)=> String(n).padStart(2,'0');
          const fmt = (d)=> d.getFullYear() + '-' + pad(d.getMonth()+1) + '-' + pad(d.getDate()) +
                           ' ' + pad(d.getHours()) + ':' + pad(d.getMinutes());
          return fmt(s) + ' ~ ' + fmt(e);
        }catch(err){
          console.warn('formatAbsencePeriodForBadge error', err);
          return '';
        }
      }


      

      // 부재 정보에 등록된 대결자 라벨을 ORG_DATA 멤버로 매핑
      // abs.delegateId가 있으면 ID 우선, 없으면 abs.delegate 문자열을
      // "팀명 이름 직책" 형식으로 ORG_DATA에서 찾아 매핑한다.
      function findDelegateMember(abs){
        if (!abs) return null;
        var baseOrg = (window.DBAM_ORG_DATA || window.ORG_DATA || ORG_DATA);
        if (!baseOrg) return null;

        // 1) delegateId 기반 매핑 (있을 때)
        if (abs.delegateId){
          try{
            for (var i=0; i<baseOrg.length; i++){
              var dept = baseOrg[i];
              if (!dept || !dept.teams) continue;
              for (var j=0; j<dept.teams.length; j++){
                var team = dept.teams[j];
                if (!team || !team.members) continue;
                for (var k=0; k<team.members.length; k++){
                  var m = team.members[k];
                  if (m && m.id === abs.delegateId){
                    return m;
                  }
                }
              }
            }
          }catch(e){
            console.warn('findDelegateMember delegateId error', e);
          }
        }

        // 2) delegate 문자열 기반 매핑 ("팀명 이름 직책")
        if (!abs.delegate) return null;
        var label = String(abs.delegate || '').trim();
        if (!label) return null;

        var found = null;
        try{
          outer:
          for (var i2=0; i2<baseOrg.length; i2++){
            var dept2 = baseOrg[i2];
            if (!dept2 || !dept2.teams) continue;
            for (var j2=0; j2<dept2.teams.length; j2++){
              var team2 = dept2.teams[j2];
              if (!team2 || !team2.members) continue;
              for (var k2=0; k2<team2.members.length; k2++){
                var m2 = team2.members[k2];
                if (!m2) continue;
                var fullDept = m2.dept || '';
                var seg = fullDept;
                if (fullDept.indexOf('/') >= 0){
                  var parts = fullDept.split('/');
                  seg = parts[parts.length-1] || fullDept;
                }
                var candidate = (seg + ' ' + m2.name + ' ' + m2.title).trim();
                if (candidate === label){
                  found = m2;
                  break outer;
                }
              }
            }
          }
        }catch(e){
          console.warn('findDelegateMember label match error', e);
        }
        return found;
            }

      // 전역에서 재사용할 수 있도록 부재/대결자 헬퍼를 window에 노출
      window.DBAM_getActiveAbsenceForEmp = getActiveAbsenceForEmp;
      window.DBAM_formatAbsencePeriodForBadge = formatAbsencePeriodForBadge;

function renderOrgTree(){
        orgTree.innerHTML = '';
        ORG_DATA.forEach(dept => {
          const deptLabel = document.createElement('div');
          deptLabel.style.fontWeight = '600';
          deptLabel.style.padding = '2px 4px';
          deptLabel.textContent = dept.dept;
          orgTree.appendChild(deptLabel);

          dept.teams.forEach(team => {
            const teamLabel = document.createElement('div');
            teamLabel.style.padding = '2px 4px 2px 10px';
            teamLabel.style.fontWeight = '500';
            teamLabel.style.color = '#4b5563';
            teamLabel.textContent = '└ ' + team.name;
            orgTree.appendChild(teamLabel);

            team.members.forEach(member => {
              const row = document.createElement('label');
              row.style.display = 'flex';
              row.style.alignItems = 'center';
              row.style.gap = '4px';
              row.style.padding = '2px 4px 2px 24px';
              row.style.borderRadius = '4px';
              row.style.cursor = 'pointer';

              row.addEventListener('mouseenter', function(){
                row.style.background = '#f3f4f6';
              });
              row.addEventListener('mouseleave', function(){
                row.style.background = '';
              });

              const radio = document.createElement('input');
              radio.type = 'radio';
              radio.name = 'orgUserSelectForApprovalLine';
              radio.dataset.id = member.id;
              radio.dataset.name = member.name;
              radio.dataset.dept = member.dept;
              radio.dataset.title = member.title;

              const textSpan = document.createElement('span');
              textSpan.style.fontSize = '12px';
              textSpan.textContent = member.name + ' / ' + member.title;

              row.appendChild(radio);
              row.appendChild(textSpan);

              // 부재중인 사용자는 Badge 및 Tooltip 표시
              try{
                const abs = getActiveAbsenceForEmp(member.id);
                if (abs){
                  const badge = document.createElement('span');
                  badge.textContent = '부재';
                  badge.style.marginLeft = '4px';
                  badge.style.fontSize = '10px';
                  badge.style.padding = '1px 4px';
                  badge.style.borderRadius = '999px';
                  badge.style.backgroundColor = '#fee2e2';
                  badge.style.color = '#b91c1c';

                  const periodText = formatAbsencePeriodForBadge(abs);
                  let titleParts = [];
                  if (periodText){
                    titleParts.push('부재 기간: ' + periodText);
                  }
                  if (abs.delegate){
                    titleParts.push('대결자: ' + abs.delegate);
                  }
                  if (titleParts.length){
                    badge.title = titleParts.join(' / ');
                  }
                  row.appendChild(badge);
                }
              }catch(err){
                console.warn('apLine orgTree absence badge error', err);
              }

              orgTree.appendChild(row);
            });
          });
        });
      }

            orgTree.addEventListener('change', function(e){
        const radio = e.target;
        if(!radio || radio.name !== 'orgUserSelectForApprovalLine') return;

        // 부재/대결 정보를 반영해 실제로 결재선에 추가할 대상(member)을 결정한다.
        let target = {
          id: radio.dataset.id,
          name: radio.dataset.name,
          dept: radio.dataset.dept,
          title: radio.dataset.title
        };
        let isDelegate = false;
        let originalInfo = null;

        // 부재중인 사용자 처리: 대결자 자동 치환 또는 경고
        try{
          const abs = getActiveAbsenceForEmp(radio.dataset.id);
          if (abs){
            const periodText = formatAbsencePeriodForBadge(abs);
            const delegateMember = findDelegateMember(abs);

            if (delegateMember){
              // 대결자 자동 치환 옵션
              let msg = radio.dataset.name + '님은 현재 부재중입니다.';
              if (periodText){
                msg += '\n부재 기간: ' + periodText;
              }
              msg += '\n\n대결자 "' + (abs.delegate || (delegateMember.name + ' ' + delegateMember.title)) + '"를 결재선에 추가하시겠습니까?';
              msg += '\n[확인: 대결자 추가 / 취소: 부재자 그대로 추가]';

              const useDelegate = window.confirm(msg);
              if (useDelegate){
                // 대결자를 결재선에 올리고, 원 결재자 정보는 별도로 보존
                target = {
                  id: delegateMember.id,
                  name: delegateMember.name,
                  dept: delegateMember.dept,
                  title: delegateMember.title
                };
                isDelegate = true;
                originalInfo = {
                  id: radio.dataset.id,
                  name: radio.dataset.name,
                  dept: radio.dataset.dept,
                  title: radio.dataset.title
                };
              }else{
                // 취소를 누른 경우: 부재자를 그대로 올린다.
                isDelegate = false;
                originalInfo = null;
              }
            }else{
              // 대결자 매핑 실패: 안내만 하고 추가 여부를 물어본다.
              let msg = radio.dataset.name + '님은 현재 부재중입니다.';
              if (periodText){
                msg += '\n부재 기간: ' + periodText;
              }
              if (abs.delegate){
                msg += '\n대결자: ' + abs.delegate;
              }
              msg += '\n\n그래도 이 사용자를 결재선에 추가하시겠습니까?';
              const ok = window.confirm(msg);
              if (!ok){
                // 사용자가 취소한 경우 라디오 선택도 해제
                try{
                  radio.checked = false;
                }catch(e2){}
                return;
              }
            }
          }
        }catch(err){
          console.warn('apLine absence / delegate confirm error', err);
        }

        // 최종적으로 결재선에 추가할 대상 기준으로 중복 체크
        try{
          if(lineBody && target && target.id){
            const rows = lineBody.querySelectorAll('tr');
            for(const row of rows){
              if(row.dataset && row.dataset.empId === target.id){
                // 이미 결재선에 있는 경우: 추가만 막고 선택 상태는 유지
                return;
              }
            }
          }
        }catch(err){
          console.warn('apLine duplicate check error', err);
        }

        const member = {
          id: target.id,
          name: target.name,
          dept: target.dept,
          title: target.title,
          isDelegate: isDelegate ? 'Y' : 'N',
          original: originalInfo
        };
        addLineFromMember(member);
      });


            function addLineFromMember(member){
        const tr = document.createElement('tr');
        tr.dataset.empId = member.id;
        tr.dataset.empName = member.name;
        tr.dataset.empDept = member.dept;
        tr.dataset.empTitle = member.title;
        tr.dataset.type = 'approval';

        // 대결 여부 및 원결재자 메타데이터 보존
        if (member && member.isDelegate === 'Y'){
          tr.dataset.isDelegate = 'Y';
          if (member.original){
            tr.dataset.originalEmpId = member.original.id || '';
            tr.dataset.originalEmpName = member.original.name || '';
            tr.dataset.originalEmpDept = member.original.dept || '';
            tr.dataset.originalEmpTitle = member.original.title || '';
          }
        }else{
          tr.dataset.isDelegate = 'N';
        }

        const tdOrder = document.createElement('td');
        tdOrder.className = 'order';
        tdOrder.style.border = '1px solid #e5e7eb';
        tdOrder.style.padding = '6px 8px';
        tdOrder.style.textAlign = 'center';

        const tdType = document.createElement('td');
        tdType.style.border = '1px solid #e5e7eb';
        tdType.style.padding = '6px 8px';
        tdType.style.textAlign = 'center';
        const sel = document.createElement('select');
        sel.style.width = '100%';
        sel.style.fontSize = '12px';
        sel.style.padding = '2px 4px';
        sel.style.borderRadius = '6px';
        sel.style.border = '1px solid #d1d5db';
        const optA = document.createElement('option');
        optA.value = 'approval';
        optA.textContent = '승인';
        const optR = document.createElement('option');
        optR.value = 'ref';
        optR.textContent = '참조';
        sel.appendChild(optA);
        sel.appendChild(optR);
        tdType.appendChild(sel);

        const tdInfo = document.createElement('td');
        tdInfo.style.border = '1px solid #e5e7eb';
        tdInfo.style.padding = '6px 8px';
        const infoDiv = document.createElement('div');
        infoDiv.style.fontSize = '12px';
        infoDiv.style.color = '#111827';

        // 기본 표기는 "이름 / 직책"
        infoDiv.textContent = member.name + ' / ' + member.title;

        // 대결 결재인 경우 "(대결)" 표기 및 Tooltip에 원결재자 정보 표시
        if (tr.dataset.isDelegate === 'Y' && tr.dataset.originalEmpName){
          infoDiv.textContent = member.name + ' / ' + member.title + ' (대결)';
          let tip = '원결재자: ' + tr.dataset.originalEmpName;
          if (tr.dataset.originalEmpTitle){
            tip += ' / ' + tr.dataset.originalEmpTitle;
          }
          infoDiv.title = tip;
        }

        tdInfo.appendChild(infoDiv);

        const tdAct = document.createElement('td');
        tdAct.style.border = '1px solid #e5e7eb';
        tdAct.style.padding = '6px 8px';
        tdAct.style.textAlign = 'center';
        tdAct.style.whiteSpace = 'nowrap';

        function makeSmallBtn(label, action){
          const btn = document.createElement('button');
          btn.type = 'button';
          btn.className = 'btn btn-sm btn-sort';
          btn.dataset.action = action;
          btn.textContent = label;
          btn.style.marginRight = '2px';
          return btn;
        }

        const btnUp = makeSmallBtn('▲', 'up');
        const btnDown = makeSmallBtn('▼', 'down');
        const btnDel = makeSmallBtn('삭제', 'delete');

        tdAct.appendChild(btnUp);
        tdAct.appendChild(btnDown);
        tdAct.appendChild(btnDel);

        tr.appendChild(tdOrder);
        tr.appendChild(tdType);
        tr.appendChild(tdInfo);
        tr.appendChild(tdAct);

        lineBody.appendChild(tr);
        refreshOrders();
        renderPreview();
      }


      lineBody.addEventListener('change', function(e){
        const sel = e.target;
        if(!(sel && sel.tagName === 'SELECT')) return;
        const row = sel.closest('tr');
        if(!row) return;
        row.dataset.type = sel.value;
        renderPreview();
      });

      lineBody.addEventListener('click', function(e){
        const btn = e.target.closest('button[data-action]');
        if(!btn) return;
        const action = btn.dataset.action;
        const row = btn.closest('tr');
        if(!row) return;

        if(action === 'delete'){
          row.remove();
        } else if(action === 'up'){
          const prev = row.previousElementSibling;
          if(prev){
            lineBody.insertBefore(row, prev);
          }
        } else if(action === 'down'){
          const next = row.nextElementSibling;
          if(next){
            lineBody.insertBefore(row, row.nextElementSibling);
          }
        }

        // 조직도 라디오 선택 해제 (삭제 시에만 해제: 동일 사용자를 다시 선택할 수 있도록)
        if(action === 'delete'){
          try{
            if(orgTree){
              const checked = orgTree.querySelector('input[name="orgUserSelectForApprovalLine"]:checked');
              if(checked){ checked.checked = false; }
            }
          }catch(err){
            console.warn('apLine orgTree radio clear error', err);
          }
        }

        refreshOrders();
        renderPreview();
      });

      function refreshOrders(){
        const rows = lineBody.querySelectorAll('tr');
        rows.forEach((row, idx)=>{
          const cell = row.querySelector('.order');
          if(cell){
            cell.textContent = String(idx + 1);
          }
        });
        if(lineEmptyHint){
          lineEmptyHint.style.display = rows.length === 0 ? 'block' : 'none';
        }
      }

            function renderPreview(){
        previewLine.innerHTML = '';
        previewRef.innerHTML = '';

        // 요청자 노드: 위=직급, 아래=이름 (샘플)
        const requesterNode = document.createElement('div');
        requesterNode.style.borderRadius = '8px';
        requesterNode.style.padding = '6px 10px';
        requesterNode.style.border = '1px solid #e5e7eb';
        requesterNode.style.background = '#f9fafb';
        requesterNode.style.textAlign = 'center';

        const rTop = document.createElement('div');
        rTop.style.fontSize = '11px';
        rTop.style.color = '#6b7280';
        rTop.style.marginBottom = '2px';
        rTop.textContent = '직급';

        const rBottom = document.createElement('div');
        rBottom.style.fontSize = '12px';
        rBottom.style.fontWeight = '500';
        rBottom.style.color = '#111827';
        rBottom.textContent = '로그인 사용자';

        requesterNode.appendChild(rTop);
        requesterNode.appendChild(rBottom);
        previewLine.appendChild(requesterNode);

        const rows = Array.from(lineBody.querySelectorAll('tr'));
        const approvals = rows.filter(r => (r.dataset.type || 'approval') === 'approval');
        const refs = rows.filter(r => (r.dataset.type || 'approval') === 'ref');

        // 결재선 노드들
        approvals.forEach((row)=>{
          const name = row.dataset.empName || '';
          const title = row.dataset.empTitle || '';
          const isDelegate = (row.dataset.isDelegate === 'Y');
          const originalName = row.dataset.originalEmpName || '';
          const originalTitle = row.dataset.originalEmpTitle || '';

          const arrow = document.createElement('span');
          arrow.textContent = '→';
          arrow.style.fontSize = '14px';
          arrow.style.color = '#9ca3af';
          previewLine.appendChild(arrow);

          const node = document.createElement('div');
          node.style.borderRadius = '8px';
          node.style.padding = '6px 10px';
          node.style.border = '1px solid #bbf7d0';
          node.style.background = '#ecfdf3';
          node.style.textAlign = 'center';

          const label = document.createElement('div');
          label.style.fontSize = '11px';
          label.style.color = '#16a34a';
          label.style.marginBottom = '2px';
          label.textContent = title || '직급';

          const text = document.createElement('div');
          text.style.fontSize = '12px';
          text.style.fontWeight = '500';
          text.style.color = '#111827';

          if (isDelegate && originalName){
            text.textContent = (name || '미지정') + ' (대결)';
            let tip = '원결재자: ' + originalName;
            if (originalTitle){
              tip += ' / ' + originalTitle;
            }
            node.title = tip;
          }else{
            text.textContent = name || '미지정';
          }

          node.appendChild(label);
          node.appendChild(text);
          previewLine.appendChild(node);
        });

        // 참조자 칩
        if(refs.length > 0){
          const label = document.createElement('span');
          label.style.color = '#6b7280';
          label.style.fontWeight = '500';
          label.style.fontSize = '12px';
          label.textContent = '참조';
          previewRef.appendChild(label);

          refs.forEach(row=>{
            const name  = row.dataset.empName || '미지정';
            const title = row.dataset.empTitle || '';
            const empId = row.dataset.empId   || '';

            let t = name;
            if(title){
              t += ' / ' + title;
            }

            const chip = document.createElement('span');
            chip.className = 'ap-ref-chip';
            chip.dataset.empId = empId;
            chip.dataset.empName = name;
            chip.style.borderRadius = '999px';
            chip.style.border = '1px solid #c4dafc';
            chip.style.padding = '2px 10px';
            chip.style.background = '#e8f2ff';
            chip.style.fontSize = '11px';
            chip.style.color = '#1a73e8';
            chip.textContent = t;
            previewRef.appendChild(chip);
          });
        }
      }

function buildApproverSummary(){
        const rows = Array.from(lineBody.querySelectorAll('tr'));
        const approvals = rows.filter(r => (r.dataset.type || 'approval') === 'approval');
        const refs = rows.filter(r => (r.dataset.type || 'approval') === 'ref');

        const approvalNames = approvals.map(r => {
          const n = r.dataset.empName || '';
          const t = r.dataset.empTitle || '';
          return t ? (n + ' ' + t) : n;
        }).filter(Boolean);

        const refNames = refs.map(r => {
          const n = r.dataset.empName || '';
          const t = r.dataset.empTitle || '';
          return t ? (n + ' ' + t) : n;
        }).filter(Boolean);

        let parts = [];
        if(approvalNames.length){
          parts.push('승인: ' + approvalNames.join(', '));
        }
        if(refNames.length){
          parts.push('참조: ' + refNames.join(', '));
        }
        return parts.join(' / ');
      }


      function buildApprovalSteps(){
        const rows = Array.from(lineBody.querySelectorAll('tr'));
        const steps = [];

        rows.forEach((row, idx) => {
          const type = row.dataset.type || 'approval';
          const empId = row.dataset.empId || '';
          const name = row.dataset.empName || '';
          const title = row.dataset.empTitle || '';
          const dept = row.dataset.empDept || '';
          const isDelegate = (row.dataset.isDelegate === 'Y');
          const originalEmpId = row.dataset.originalEmpId || '';
          const originalName = row.dataset.originalEmpName || '';
          const originalTitle = row.dataset.originalEmpTitle || '';
          const originalDept = row.dataset.originalEmpDept || '';

          steps.push({
            order: idx + 1,
            empId: empId,
            name: name,
            title: title,
            dept: dept,
            type: type,
            status: (type === 'approval' ? 'PENDING' : 'NONE'),
            decidedAt: null,
            isDelegate: isDelegate ? 'Y' : 'N',
            originalEmpId: originalEmpId,
            originalName: originalName,
            originalTitle: originalTitle,
            originalDept: originalDept
          });
        });

        return steps;
      }

      function syncOuterPreview(){
        if(outerPreviewLine){
          outerPreviewLine.innerHTML = previewLine.innerHTML;
        }
        if(outerPreviewRef){
          outerPreviewRef.innerHTML = previewRef.innerHTML;
        }
        if(outerApproverInput){
          outerApproverInput.value = buildApproverSummary();
        }

        // 결재선 테이블 → approvalCenter.currentDraft.approvalSteps 반영
        if(typeof approvalCenter !== 'undefined' && approvalCenter.currentDraft){
          const steps = buildApprovalSteps();
          approvalCenter.currentDraft.approvalSteps = steps;

          // 최초 승인 단계 인덱스 설정 (approval 타입 중 첫 번째)
          let firstIdx = null;
          for(let i=0;i<steps.length;i++){
            if(steps[i].type === 'approval'){
              firstIdx = i;
              break;
            }
          }
          approvalCenter.currentDraft.currentStepIndex = (firstIdx !== null ? firstIdx : null);
        }
      }

      function openModal(){
        // 모달을 열 때마다 조직도 내용을 재렌더링 해서 최신 부재/대결자 정보를 반영
        try{
          renderOrgTree();
        }catch(e){
          console.warn('approvalLine openModal renderOrgTree error', e);
        }
        backdrop.classList.remove('hidden');
        backdrop.classList.add('show');
        backdrop.setAttribute('aria-hidden','false');
        escHandler = function(e){
          if(e.key === 'Escape'){
            closeModal();
          }
        };
        document.addEventListener('keydown', escHandler);
      }

      function closeModal(){
        backdrop.classList.remove('show');
        backdrop.classList.add('hidden');
        backdrop.setAttribute('aria-hidden','true');
        if(escHandler){
          document.removeEventListener('keydown', escHandler);
          escHandler = null;
        }
      }

      function applyAndClose(){
        syncOuterPreview();
        closeModal();
      }

      openBtn.addEventListener('click', function(){
        openModal();
      });

      backdrop.addEventListener('click', function(e){
        if(e.target === backdrop){
          closeModal();
        }
      });

      renderOrgTree();
      renderPreview();

      window.approvalLine = {
        openModal: openModal,
        closeModal: closeModal,
        applyAndClose: applyAndClose
      };
    })();
  </script>

<div id="tabRenameToast" class="tab-rename-toast"></div>


  <script>
    (function(){
      const backdrop = document.getElementById('sessionSwitchBackdrop');
      const orgTree = document.getElementById('sessionSwitchOrgTree');
      const selectedLabel = document.getElementById('sessionSwitchSelectedLabel');
      const userLabel = document.getElementById('sessionUserLabel');
      const openBtn = document.getElementById('btnOpenSessionSwitch');
      let selected = null;

      function getOrgData(){
        if (window.DBAM_ORG_DATA && Array.isArray(window.DBAM_ORG_DATA)){
          return window.DBAM_ORG_DATA;
        }
        return [];
      }

      function buildOrgTree(){
        if(!orgTree) return;
        const data = getOrgData();
        const frag = document.createDocumentFragment();
        data.forEach(function(dept){
          const deptDiv = document.createElement('div');
          deptDiv.style.marginBottom = '4px';

          const deptTitle = document.createElement('div');
          deptTitle.textContent = dept.dept;
          deptTitle.style.fontWeight = '600';
          deptTitle.style.fontSize = '12px';
          deptDiv.appendChild(deptTitle);

          (dept.teams || []).forEach(function(team){
            const teamDiv = document.createElement('div');
            teamDiv.style.marginLeft = '8px';

            const teamTitle = document.createElement('div');
            teamTitle.textContent = team.name;
            teamTitle.style.fontSize = '11px';
            teamTitle.style.color = '#4b5563';
            teamDiv.appendChild(teamTitle);

            const ul = document.createElement('ul');
            ul.style.listStyle = 'none';
            ul.style.margin = '2px 0 4px';
            ul.style.padding = '0';

            (team.members || []).forEach(function(m){
              const li = document.createElement('li');
              li.style.margin = '1px 0';
              li.style.cursor = 'pointer';

              const radio = document.createElement('input');
              radio.type = 'radio';
              radio.name = 'sessionSwitchUser';
              radio.style.marginRight = '4px';
              radio.value = m.id;

              const label = document.createElement('span');
              label.textContent = m.name + ' ' + (m.title || '');
              label.title = (m.dept || '');

              radio.addEventListener('change', function(){
                selectUser(m);
              });
              li.addEventListener('click', function(e){
                if(e.target !== radio){
                  radio.checked = true;
                  selectUser(m);
                }
              });

              li.appendChild(radio);
              li.appendChild(label);

              // 부재중인 사용자는 Badge 및 Tooltip 표시 (결재선 조직도와 동일 로직 재사용)
              try{
                var abs = null;
                if (window.DBAM_getActiveAbsenceForEmp){
                  abs = window.DBAM_getActiveAbsenceForEmp(m.id);
                } else if (window.DBAM_ABSENCE && Array.isArray(window.DBAM_ABSENCE)){
                  // fallback: 간단히 DBAM_ABSENCE에서 직접 조회
                  var now = new Date();
                  window.DBAM_ABSENCE.forEach(function(d){
                    if (!d || d.empId !== m.id) return;
                    try{
                      var s = new Date(d.start);
                      var e = new Date(d.end);
                      if (d.status === 'ACTIVE' && s <= now && now <= e){
                        abs = d;
                      }
                    }catch(e){}
                  });
                }

                if (abs && window.DBAM_formatAbsencePeriodForBadge){
                  var badge = document.createElement('span');
                  badge.textContent = '부재';
                  badge.style.marginLeft = '4px';
                  badge.style.fontSize = '10px';
                  badge.style.padding = '1px 4px';
                  badge.style.borderRadius = '999px';
                  badge.style.backgroundColor = '#fee2e2';
                  badge.style.color = '#b91c1c';

                  var periodText = window.DBAM_formatAbsencePeriodForBadge(abs);
                  var titleParts = [];
                  if (periodText){
                    titleParts.push('부재 기간: ' + periodText);
                  }
                  if (abs.delegate){
                    titleParts.push('대결자: ' + abs.delegate);
                  }
                  if (titleParts.length){
                    badge.title = titleParts.join(' / ');
                  }
                  li.appendChild(badge);
                }
              }catch(err){
                console.warn('delegate orgTree absence badge error', err);
              }

              ul.appendChild(li);
            });

            teamDiv.appendChild(ul);
            deptDiv.appendChild(teamDiv);
          });

          frag.appendChild(deptDiv);
        });

        orgTree.innerHTML = '';
        orgTree.appendChild(frag);
      }

      function syncCurrentLabel(){
        if(!userLabel) return;
        var name = window.DBAM_CURRENT_USER_NAME || window.DBAM_CURRENT_USER || 'demoUser';
        userLabel.textContent = name;
      }

      function updateSelectedLabel(){
        if(!selected || !selectedLabel){
          if(selectedLabel){
            selectedLabel.textContent = '아직 사용자를 선택하지 않았습니다.';
          }
          return;
        }
        // 예: 개발1팀 홍길동 책임 (최종 부서명 + 이름 + 직급)
        var deptShort = selected.dept || '';
        if (deptShort && deptShort.indexOf('/') >= 0){
          var parts = deptShort.split('/');
          deptShort = parts[parts.length - 1];
        }
        var bits = [];
        if (deptShort){
          bits.push(deptShort);
        }
        if (selected.name){
          bits.push(selected.name);
        }
        if (selected.title){
          bits.push(selected.title);
        }
        var txt = bits.join(' ');
        selectedLabel.textContent = txt;
      }

      function selectUser(m){
        selected = {
          id: m.id,
          name: m.name,
          title: m.title,
          dept: m.dept
        };
        updateSelectedLabel();
      }

      function open(){
        if(!backdrop) return;
        if(orgTree && !orgTree.firstElementChild){
          buildOrgTree();
        }
        updateSelectedLabel();
        syncCurrentLabel();
        backdrop.classList.remove('hidden');
        backdrop.classList.add('show');
        backdrop.setAttribute('aria-hidden','false');
      }

      function close(){
        if(!backdrop) return;
        backdrop.classList.remove('show');
        backdrop.classList.add('hidden');
        backdrop.setAttribute('aria-hidden','true');
      }

      function applySelected(){
        if(!selected){
          alert('세션으로 변경할 사용자를 선택하세요.');
          return;
        }
        window.DBAM_CURRENT_USER = selected.id;
        window.DBAM_CURRENT_USER_NAME = selected.name + ' ' + (selected.title || '');
        syncCurrentLabel();

        if(typeof approvalCenter !== 'undefined'){
          approvalCenter.refresh();
          if(approvalCenter.currentDetailId){
            approvalCenter.openDetail(approvalCenter.currentDetailId);
          }
        }

        close();
      }

      if(openBtn){
        openBtn.addEventListener('click', function(){
          open();
        });
      }

      // 초기 라벨 세팅
      if(document.readyState === 'loading'){
        document.addEventListener('DOMContentLoaded', syncCurrentLabel);
      }else{
        syncCurrentLabel();
      }

      window.sessionSwitcher = {
        open: open,
        close: close,
        applySelected: applySelected
      };
    })();
  
    (function(){
      const backdrop = document.getElementById('delegateOrgBackdrop');
      const orgTree = document.getElementById('delegateOrgTree');
      const selectedLabel = document.getElementById('delegateSelectedLabel');
      const delegateInput = document.getElementById('delegateName');
      if (!backdrop || !orgTree || !selectedLabel || !delegateInput) {
        return;
      }

      let selected = null;
      let escHandler = null;

      function getOrgData(){
        if (window.DBAM_ORG_DATA && Array.isArray(window.DBAM_ORG_DATA)){
          return window.DBAM_ORG_DATA;
        }
        return [];
      }

      function buildOrgTree(){
        orgTree.innerHTML = '';
        const data = getOrgData();
        const frag = document.createDocumentFragment();

        data.forEach(function(dept){
          const deptDiv = document.createElement('div');
          deptDiv.style.marginBottom = '4px';

          const deptTitle = document.createElement('div');
          deptTitle.textContent = dept.dept;
          deptTitle.style.fontWeight = '600';
          deptTitle.style.fontSize = '12px';
          deptDiv.appendChild(deptTitle);

          (dept.teams || []).forEach(function(team){
            const teamDiv = document.createElement('div');
            teamDiv.style.marginLeft = '8px';

            const teamTitle = document.createElement('div');
            teamTitle.textContent = team.name;
            teamTitle.style.fontSize = '11px';
            teamTitle.style.color = '#4b5563';
            teamDiv.appendChild(teamTitle);

            const ul = document.createElement('ul');
            ul.style.listStyle = 'none';
            ul.style.margin = '2px 0 4px 0';
            ul.style.padding = '0';

            (team.members || []).forEach(function(m){
              const li = document.createElement('li');
              li.style.display = 'flex';
              li.style.alignItems = 'center';
              li.style.fontSize = '12px';

              const radio = document.createElement('input');
              radio.type = 'radio';
              radio.name = 'delegateUserSelect';
              radio.style.marginRight = '4px';
              radio.value = m.id;

              const label = document.createElement('span');
              label.textContent = m.name + ' ' + (m.title || '');
              label.title = (m.dept || '');

              radio.addEventListener('change', function(){
                selectUser(m);
              });
              li.addEventListener('click', function(e){
                if(e.target !== radio){
                  radio.checked = true;
                  selectUser(m);
                }
              });

              li.appendChild(radio);
              li.appendChild(label);

              // 부재중인 사용자는 Badge 및 Tooltip 표시 (결재선 조직도와 동일 로직 재사용)
              try{
                var abs = null;
                if (window.DBAM_getActiveAbsenceForEmp){
                  abs = window.DBAM_getActiveAbsenceForEmp(m.id);
                } else if (window.DBAM_ABSENCE && Array.isArray(window.DBAM_ABSENCE)){
                  // fallback: 간단히 DBAM_ABSENCE에서 직접 조회
                  var now = new Date();
                  window.DBAM_ABSENCE.forEach(function(d){
                    if (!d || d.empId !== m.id) return;
                    try{
                      var s = new Date(d.start);
                      var e = new Date(d.end);
                      if (d.status === 'ACTIVE' && s <= now && now <= e){
                        abs = d;
                      }
                    }catch(e){}
                  });
                }

                if (abs && window.DBAM_formatAbsencePeriodForBadge){
                  var badge = document.createElement('span');
                  badge.textContent = '부재';
                  badge.style.marginLeft = '4px';
                  badge.style.fontSize = '10px';
                  badge.style.padding = '1px 4px';
                  badge.style.borderRadius = '999px';
                  badge.style.backgroundColor = '#fee2e2';
                  badge.style.color = '#b91c1c';

                  var periodText = window.DBAM_formatAbsencePeriodForBadge(abs);
                  var titleParts = [];
                  if (periodText){
                    titleParts.push('부재 기간: ' + periodText);
                  }
                  if (abs.delegate){
                    titleParts.push('대결자: ' + abs.delegate);
                  }
                  if (titleParts.length){
                    badge.title = titleParts.join(' / ');
                  }
                  li.appendChild(badge);
                }
              }catch(err){
                console.warn('delegate orgTree absence badge error', err);
              }

              ul.appendChild(li);
            });

            teamDiv.appendChild(ul);
            deptDiv.appendChild(teamDiv);
          });

          frag.appendChild(deptDiv);
        });

        orgTree.appendChild(frag);
      }

      function updateSelectedLabel(){
        if(!selected){
          selectedLabel.textContent = '아직 대결자를 선택하지 않았습니다.';
          return;
        }
        // 예: 개발1팀 홍길동 책임 (최종 부서명 + 이름 + 직급)
        var deptShort = selected.dept || '';
        if (deptShort && deptShort.indexOf('/') >= 0){
          var parts = deptShort.split('/');
          deptShort = parts[parts.length - 1];
        }
        var bits = [];
        if (deptShort){
          bits.push(deptShort);
        }
        if (selected.name){
          bits.push(selected.name);
        }
        if (selected.title){
          bits.push(selected.title);
        }
        var txt = bits.join(' ');
        selectedLabel.textContent = txt;
      }

      function selectUser(m){
        selected = {
          id: m.id,
          name: m.name,
          title: m.title,
          dept: m.dept
        };
        updateSelectedLabel();
      }

      function open(){
        if(!backdrop) return;
        if(orgTree){
          buildOrgTree(); // 항상 최신 부재 정보를 반영하기 위해 매 오픈 시 트리 재구성
        }
        updateSelectedLabel();
        backdrop.classList.remove('hidden');
        backdrop.classList.add('show');
        backdrop.setAttribute('aria-hidden','false');
      }

      function close(){
        backdrop.classList.remove('show');
        backdrop.classList.add('hidden');
        backdrop.setAttribute('aria-hidden','true');
        // delegateOrg ESC 핸들링은 전역 ESC 로직에서 처리
        escHandler = null;
      }

      function applySelected(){
        if(!selected){
          alert('대결자를 선택해 주세요.');
          return;
        }
        if (delegateInput){
          // 형식: 최종 부서명 + 이름 + 직급 → "개발1팀 홍길동 책임"
          var dept = selected.dept || '';
          var teamName = dept;
          var idx = dept.lastIndexOf('/');
          if(idx >= 0){
            teamName = dept.substring(idx+1);
          }
          var parts = [];
          if(teamName){ parts.push(teamName); }
          if(selected.name){ parts.push(selected.name); }
          if(selected.title){ parts.push(selected.title); }
          delegateInput.value = parts.join(' ');
          delegateInput.dataset.empId = selected.id || '';
        }
        close();
      }

      window.delegatePicker = {
        open: open,
        close: close,
        applySelected: applySelected
      };
    })();
//@@tk-start//////////////////////////////

//@@tk-end//////////////////////////////
</script>
</body>
</html>